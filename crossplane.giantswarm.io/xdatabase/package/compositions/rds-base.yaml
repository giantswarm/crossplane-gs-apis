apiVersion: apiextensions.crossplane.io/v1
kind: Composition
metadata:
  creationTimestamp: null
  labels:
    component: database
    provider: aws
    type: base
  name: rds-base
spec:
  compositeTypeRef:
    apiVersion: xdatabase.crossplane.giantswarm.io/v1alpha1
    kind: RdsBase
  mode: Pipeline
  pipeline:
  - functionRef:
      name: function-patch-and-transform
    input:
      apiVersion: pt.crossplane.io/v1beta1
      kind: Resources
      metadata:
        creationTimestamp: null
      patchSets:
      - name: metadata
        patches:
        - fromFieldPath: metadata.labels
          policy:
            toFieldPath: MergeObjects
          toFieldPath: metadata.labels
          type: FromCompositeFieldPath
        - fromFieldPath: spec.region
          toFieldPath: metadata.labels.region
          type: FromCompositeFieldPath
        - fromFieldPath: spec.providerConfigRef
          toFieldPath: spec.providerConfigRef
          type: FromCompositeFieldPath
        - fromFieldPath: spec.deletionPolicy
          toFieldPath: spec.deletionPolicy
          type: FromCompositeFieldPath
      - name: commontags
        patches:
        - fromFieldPath: spec.tags
          policy:
            toFieldPath: MergeObjects
          toFieldPath: spec.forProvider.tags
          type: FromCompositeFieldPath
        - fromFieldPath: metadata.labels
          policy:
            toFieldPath: MergeObjects
          toFieldPath: spec.forProvider.tags
          type: FromCompositeFieldPath
        - fromFieldPath: spec.region
          toFieldPath: spec.forProvider.tags.region
          type: FromCompositeFieldPath
      resources:
      - base:
          apiVersion: kms.aws.upbound.io/v1beta1
          kind: Key
          metadata:
            creationTimestamp: null
          spec:
            forProvider:
              region: null
            initProvider: {}
          status:
            atProvider: {}
        name: kms
        patches:
        - fromFieldPath: spec.managementPolicies
          toFieldPath: spec.managementPolicies
          type: FromCompositeFieldPath
        - fromFieldPath: spec.region
          toFieldPath: spec.forProvider.region
          type: FromCompositeFieldPath
        - fromFieldPath: status.atProvider.arn
          toFieldPath: status.kmsKeyId
          type: ToCompositeFieldPath
        - combine:
            strategy: string
            string:
              fmt: '%s-%s'
            variables:
            - fromFieldPath: spec.claimRef.name
            - fromFieldPath: spec.region
          toFieldPath: spec.forProvider.tags.Name
          type: CombineFromComposite
        - patchSetName: commontags
          type: PatchSet
        - patchSetName: metadata
          type: PatchSet
      - base:
          apiVersion: rds.aws.upbound.io/v1beta1
          kind: SubnetGroup
          metadata:
            creationTimestamp: null
          spec:
            forProvider:
              region: null
            initProvider: {}
          status:
            atProvider: {}
        name: subnetgroup
        patches:
        - fromFieldPath: spec.region
          toFieldPath: spec.forProvider.region
          type: FromCompositeFieldPath
        - fromFieldPath: spec.subnetIds
          policy:
            fromFieldPath: Required
          toFieldPath: spec.forProvider.subnetIds
          type: FromCompositeFieldPath
        - patchSetName: commontags
          type: PatchSet
        - fromFieldPath: spec.managementPolicies
          toFieldPath: spec.managementPolicies
          type: FromCompositeFieldPath
        - patchSetName: metadata
          type: PatchSet
        - fromFieldPath: status.atProvider.id
          toFieldPath: status.dbSubnetGroupName
          type: ToCompositeFieldPath
        - combine:
            strategy: string
            string:
              fmt: '%s %s rds subnet group'
            variables:
            - fromFieldPath: spec.claimRef.name
            - fromFieldPath: spec.region
          toFieldPath: spec.forProvider.description
          type: CombineFromComposite
      - base:
          apiVersion: ec2.aws.upbound.io/v1beta1
          kind: SecurityGroup
          metadata:
            creationTimestamp: null
          spec:
            forProvider:
              region: null
              revokeRulesOnDelete: true
            initProvider: {}
          status:
            atProvider: {}
        name: securitygroup
        patches:
        - fromFieldPath: spec.vpcId
          toFieldPath: spec.forProvider.vpcId
          type: FromCompositeFieldPath
        - fromFieldPath: spec.region
          toFieldPath: spec.forProvider.region
          type: FromCompositeFieldPath
        - patchSetName: commontags
          type: PatchSet
        - fromFieldPath: spec.managementPolicies
          toFieldPath: spec.managementPolicies
          type: FromCompositeFieldPath
        - patchSetName: metadata
          type: PatchSet
        - combine:
            strategy: string
            string:
              fmt: '%s %s rds security group'
            variables:
            - fromFieldPath: spec.claimRef.name
            - fromFieldPath: spec.region
          toFieldPath: spec.forProvider.description
          type: CombineFromComposite
        - fromFieldPath: status.atProvider.id
          toFieldPath: status.securityGroupId
          type: ToCompositeFieldPath
    step: patch-and-transform
  - functionRef:
      name: function-kcl
    input:
      apiVersion: krm.kcl.dev/v1alpha1
      kind: KCLInput
      metadata:
        creationTimestamp: null
      spec:
        source: |-
          import regex

          _oxr = option("params").oxr
          _dxr = option("params").dxr
          _ocds = option("params").ocds
          _dcds = option("params").dcds

          get = lambda x: {:}, y: str, d: any -> any {
              """
              Get an item from a dictionary using a dot separated path.
              If the item is not found, return a default value.
              """
              p = regex.split(y, "\.")
              c = p[0]
              y = ".".join(p[1:])
              x[c] if len(p) == 1 and c in x else d if c not in x else get(x[c], y, d)
          }

          getwparent = lambda x: {:}, p: {:}, y: str, d: any -> any {
              """
              Get with fallback to parent
              Tries to get a path from a dictionary, if it fails,
              tries to get it from the parent dictionary.

              If that fails, falls back to the default value provided.
              """
              get(x, y, get(p, "spec.${y}", d))
          }

          ocdsspec = lambda x: str, y: str, d: any -> any {
              """
              Get an item from the spec of an ocds resource.
              """
              get(_ocds, "${x}.Resource.spec.${y}", d)
          }

          ocdsstatus = lambda x: str, y: str, d: any -> any {
              """
              Get an item from the status of an ocds resource.
              """
              get(_ocds, "${x}.Resource.status.atProvider.${y}", d)
          }

          exists = lambda x: any -> bool {
              """
              Check if a value exists.
              """
              x in list(_ocds)
          }

          ready = lambda x: str -> bool {
              """
              Check if a value is ready.
              """
              conditions = get(_ocds, "${x}.Resource.status.conditions", [])
              any_true([
                  all_true([
                      get(c, "status", "False") == "True" for c in conditions
                  ])
              ])
          }

          readystr = lambda x: str -> str {
              """
              Check if a value is ready.
              """
              "True" if ready(x) else "False"
          }

          appName = get(_oxr, "spec.claimRef.name", "")
          createCluster = get(_oxr, "spec.createCluster", True)
          engine = get(_oxr, "spec.engine", "")
          dp = get(_oxr, "spec.deletionPolicy", "Delete")
          keyId = get(_oxr, "status.kmsKeyId", False)
          namespace = get(_oxr, "spec.claimRef.namespace", "default")
          region = get(_oxr, "spec.region", "eu-central-1")
          pcr = get(_oxr, "spec.providerConfigRef", {"name": "default"})
          labels = get(_oxr, "metadata.labels", {}) | {"region": region}
          tags = labels | get(_oxr, "spec.tags", {})

          port = get(_oxr, "status.port", False)
          restoreToPointInTime = {
              if createCluster:
                  "sourceDbClusterIdentifier": get(_oxr, "spec.restoreToPointInTime.sourceDbClusterIdentifier", None),
                  "restoreType": get(_oxr, "spec.restoreToPointInTime.restoreType", "full-copy"),
              else:
                  "sourceDbInstanceIdentifier" = get(_oxr, "spec.restoreToPointInTime.sourceDbClusterIdentifier", None)
                  "sourceDbInstanceAutomatedBackupsArn" = get(_oxr, "spec.restoreToPointInTime.sourceDbInstanceAutomatedBackupsArn", None)
                  "sourceDbiResourceId" = get(_oxr, "spec.restoreToPointInTime.sourceDbiResourceId", None)

              _v = get(_oxr, "spec.restoreToPointInTime.restoreToTime", False)
              if _v:
                  "restoreToTime": get(_oxr, "spec.restoreToPointInTime.restoreToTime", None)
              else:
                  "useLatestRestorableTime": get(_oxr, "spec.restoreToPointInTime.useLatestRestorableTime", True)
          }

          s3import = get(_oxr, "spec.s3Import", False)

          masterInstance = ready("instance-0") and ocdsstatus("instance-0", "id", False)
          clusterIdentifier = ocdsstatus("rds-cluster", "id", "")
          clusterResourceId = ocdsstatus("rds-cluster", "clusterResourceId", "")
          endpoint = ocdsstatus("rds-cluster", "endpoint", "")
          clusterArn = ocdsstatus("rds-cluster", "arn", "")

          mgmtPolicy = get(_oxr, "spec.managementPolicies", [])
          publishConnection = get(_oxr, "spec.publishConnectionDetailsTo", {})

          _secretRef: bool|str = False
          if createCluster:
              if ready("rds-cluster"):
                  _secretRef = ocdsspec("rds-cluster", "writeConnectionSecretToRef.name", "")
          else:
              if ready("instance-0"):
                  _secretRef = ocdsspec("instance-0", "writeConnectionSecretToRef.name", "")
          _connectionSecret = _secretRef

          ipgn = get(_oxr, "spec.dbParameterGroup.name", "") if get(_oxr, "spec.allowMajorVersionUpgrade", False) else ""
          provisioned = get(_oxr, "spec.engineMode", "provisioned") == "provisioned"
          regionedAzs = ["${region}${az}" for az in get(_oxr, "spec.availabilityZones", ["a", "b", "c"])]
          subnetGroup = get(_oxr, "status.dbSubnetGroupName", False)
          serverless = get(_oxr, "spec.engineMode", "provisioned") == "serverless"
          scalingConfiguration = get(_oxr, "spec.scalingConfiguration", False) if serverless else False
          serverlessv2scaling = get(_oxr, "spec.serverlessv2scalingConfiguration", False) if provisioned else False

          cluster = {
              "apiVersion": "rds.aws.upbound.io/v1beta1"
              "kind": "Cluster"
              "metadata": {
                  "annotations": {
                      "krm.kcl.dev/composition-resource-name": "rds-cluster"
                      "krm.kcl.dev/ready": readystr("rds-cluster")
                      "crossplane.io/external-name": appName
                  }
                  "labels": labels
              }
              "spec": {
                  "deletionPolicy": dp
                  "initProvider": {
                      if get(_oxr, "spec.allowMajorVersionUpgrade", True):
                          if get(_oxr, "spec.engineVersion", False):
                              "engineVersion": _oxr.spec.engineVersion
                      if get(_oxr, "spec.globalClusterIdentifier", False):
                          "globalClusterIdentifier": _oxr.spec.globalClusterIdentifier
                      if get(_oxr, "spec.replicationSourceIdentifier", False):
                          "replicationSourceIdentifier": _oxr.spec.replicationSourceIdentifier
                  }

                  "forProvider": {
                      _managedMasterUserPassword = False
                      _autoGeneratePassword = get(_oxr, "spec.autoGeneratePassword", True),
                      if _autoGeneratePassword and not _managedMasterUserPassword:
                          "autoGeneratePassword": _autoGeneratePassword,
                          "masterPasswordSecretRef": {
                              "key": "password",
                              "namespace": get(_oxr, "spec.claimRef.namespace", "default"),
                              "name": "${appName}-${region}-rds-autogen-pass",
                          }

                      "copyTagsToSnapshot": True
                      "networkType": "IPV4"
                      "skipFinalSnapshot": True
                      "storageEncrypted": True
                      "region": region
                      "kmsKeyId": keyId
                      "dbSubnetGroupName": subnetGroup
                      "tags": tags | {
                          Name: "${appName}-${region}"
                      }

                      if get(_oxr, "spec.allocatedStorage", False):
                          "allocatedStorage": _oxr.spec.allocatedStorage
                      if get(_oxr, "spec.allowMajorVersionUpgrade", None) != None:
                          "allowMajorVersionUpgrade": _oxr.spec.allowMajorVersionUpgrade
                      if get(_oxr, "spec.applyImmediately", None) != None:
                          "applyImmediately": _oxr.spec.applyImmediately
                      if get(_oxr, "spec.availabilityZones", False):
                          "availabilityZones": regionedAzs
                      if get(_oxr, "spec.backupRetentionPeriod", False):
                          "backupRetentionPeriod": _oxr.spec.backupRetentionPeriod
                      if get(_oxr, "spec.backtrackWindow", False):
                          "backtrackWindow": _oxr.spec.backtrackWindow
                      if get(_oxr, "spec.clusterMembers", False):
                          "clusterMembers": _oxr.spec.clusterMembers
                      if get(_oxr, "spec.databaseName", False):
                          "databaseName": _oxr.spec.databaseName
                      if get(_oxr, "spec.dbClusterInstanceClass", False):
                          "dbClusterInstanceClass": _oxr.spec.dbClusterInstanceClass
                      if get(_oxr, "spec.dbClusterParameterGroup.name", False):
                          "dbClusterParameterGroupName": _oxr.spec.dbClusterParameterGroup.name
                      if get(_oxr, "spec.dbInstanceParameterGroup.name", False):
                          "dbInstanceParameterGroupName": _oxr.spec.dbInstanceParameterGroup.name
                      if get(_oxr, "spec.deletionProtection", None) != None:
                          "deletionProtection": _oxr.spec.deletionProtection
                      if get(_oxr, "spec.deleteAutomatedBackups", None) != None:
                          "deleteAutomatedBackups": _oxr.spec.deleteAutomatedBackups
                      if get(_oxr, "spec.domain", False):
                          "domain": _oxr.spec.domain
                      if get(_oxr, "spec.domainIAMRoleName", False):
                          "domainIAMRoleName": _oxr.spec.domainIAMRoleName
                      if get(_oxr, "spec.enableHttpEndpoint", False):
                          "enableHttpEndpoint": _oxr.spec.enableHttpEndpoint
                      if get(_oxr, "spec.enableGlobalWriteForwarding", None) != None:
                          "enableGlobalWriteForwarding": _oxr.spec.enableGlobalWriteForwarding
                      if get(_oxr, "spec.enableLocalWriteForwarding", None) != None:
                          "enableLocalWriteForwarding": _oxr.spec.enableLocalWriteForwarding
                      if get(_oxr, "spec.enabledCloudwatchLogsExports", False):
                          "enabledCloudwatchLogsExports": _oxr.spec.enabledCloudwatchLogsExports
                      if get(_oxr, "spec.engine", False):
                          "engine": _oxr.spec.engine
                      if get(_oxr, "spec.engineMode", False):
                          "engineMode": _oxr.spec.engineMode

                      if not get(_oxr, "spec.allowMajorVersionUpgrade", True):
                          if get(_oxr, "spec.engineVersion", False):
                              "engineVersion": get(_oxr, "spec.engineVersion", "")

                      if get(_oxr, "spec.claimRef.name", False):
                          "finalSnapshotIdentifier": _oxr.spec.claimRef.name
                      if get(_oxr, "spec.iamDatabaseAuthenticationEnabled", None) != None:
                          "iamDatabaseAuthenticationEnabled": _oxr.spec.iamDatabaseAuthenticationEnabled
                      if get(_oxr, "spec.iops", False):
                          "iops": _oxr.spec.iops
                      if get(_oxr, "spec.masterUsername", False):
                          "masterUsername": _oxr.spec.masterUsername
                      if get(_oxr, "spec.preferredBackupWindow", False):
                          "preferredBackupWindow": _oxr.spec.preferredBackupWindow
                      if get(_oxr, "spec.preferredMaintenanceWindow", False):
                          "preferredMaintenanceWindow": _oxr.spec.preferredMaintenanceWindow
                      if get(_oxr, "spec.restoreToPointInTime", False):
                          "restoreToPointInTime": [restoreToPointInTime]
                      if get(_oxr, "status.securityGroupId", False):
                          "vpcSecurityGroupIds": [_oxr.status.securityGroupId]
                      if get(_oxr, "spec.storageType", False):
                          "storageType": _oxr.spec.storageType
                      if get(_oxr, "spec.sourceRegion", False):
                          "sourceRegion": _oxr.spec.sourceRegion

                      if s3import:
                          "s3Import": [
                              s3import
                          ]
                      if scalingConfiguration:
                          "scalingConfiguration": [
                              scalingConfiguration
                          ]

                      if serverlessv2scaling:
                          "serverlessv2ScalingConfiguration": [
                              serverlessv2scaling
                          ]
                      if ipgn:
                          "dbInstanceParameterGroupName": ipgn
                  }
                  "managementPolicies": mgmtPolicy,
                  "providerConfigRef": pcr,
                  "writeConnectionSecretToRef": {
                      "name": "${appName}-${region}-rds"
                      "namespace": get(_oxr, "spec.claimRef.namespace", "default")
                  }
              }
          } if keyId and subnetGroup else {}

          _items = [
              x for x in [cluster]
              if x and createCluster
          ]

          items = _items
        target: ""
    step: function-kcl-create-cluster
  - functionRef:
      name: function-kcl
    input:
      apiVersion: krm.kcl.dev/v1alpha1
      kind: KCLInput
      metadata:
        creationTimestamp: null
      spec:
        source: |-
          import regex

          _oxr = option("params").oxr
          _dxr = option("params").dxr
          _ocds = option("params").ocds
          _dcds = option("params").dcds

          get = lambda x: {:}, y: str, d: any -> any {
              """
              Get an item from a dictionary using a dot separated path.
              If the item is not found, return a default value.
              """
              p = regex.split(y, "\.")
              c = p[0]
              y = ".".join(p[1:])
              x[c] if len(p) == 1 and c in x else d if c not in x else get(x[c], y, d)
          }

          getwparent = lambda x: {:}, p: {:}, y: str, d: any -> any {
              """
              Get with fallback to parent
              Tries to get a path from a dictionary, if it fails,
              tries to get it from the parent dictionary.

              If that fails, falls back to the default value provided.
              """
              get(x, y, get(p, "spec.${y}", d))
          }

          ocdsspec = lambda x: str, y: str, d: any -> any {
              """
              Get an item from the spec of an ocds resource.
              """
              get(_ocds, "${x}.Resource.spec.${y}", d)
          }

          ocdsstatus = lambda x: str, y: str, d: any -> any {
              """
              Get an item from the status of an ocds resource.
              """
              get(_ocds, "${x}.Resource.status.atProvider.${y}", d)
          }

          exists = lambda x: any -> bool {
              """
              Check if a value exists.
              """
              x in list(_ocds)
          }

          ready = lambda x: str -> bool {
              """
              Check if a value is ready.
              """
              conditions = get(_ocds, "${x}.Resource.status.conditions", [])
              any_true([
                  all_true([
                      get(c, "status", "False") == "True" for c in conditions
                  ])
              ])
          }

          readystr = lambda x: str -> str {
              """
              Check if a value is ready.
              """
              "True" if ready(x) else "False"
          }

          appName = get(_oxr, "spec.claimRef.name", "")
          createCluster = get(_oxr, "spec.createCluster", True)
          engine = get(_oxr, "spec.engine", "")
          dp = get(_oxr, "spec.deletionPolicy", "Delete")
          keyId = get(_oxr, "status.kmsKeyId", False)
          namespace = get(_oxr, "spec.claimRef.namespace", "default")
          region = get(_oxr, "spec.region", "eu-central-1")
          pcr = get(_oxr, "spec.providerConfigRef", {"name": "default"})
          labels = get(_oxr, "metadata.labels", {}) | {"region": region}
          tags = labels | get(_oxr, "spec.tags", {})

          port = get(_oxr, "status.port", False)
          restoreToPointInTime = {
              if createCluster:
                  "sourceDbClusterIdentifier": get(_oxr, "spec.restoreToPointInTime.sourceDbClusterIdentifier", None),
                  "restoreType": get(_oxr, "spec.restoreToPointInTime.restoreType", "full-copy"),
              else:
                  "sourceDbInstanceIdentifier" = get(_oxr, "spec.restoreToPointInTime.sourceDbClusterIdentifier", None)
                  "sourceDbInstanceAutomatedBackupsArn" = get(_oxr, "spec.restoreToPointInTime.sourceDbInstanceAutomatedBackupsArn", None)
                  "sourceDbiResourceId" = get(_oxr, "spec.restoreToPointInTime.sourceDbiResourceId", None)

              _v = get(_oxr, "spec.restoreToPointInTime.restoreToTime", False)
              if _v:
                  "restoreToTime": get(_oxr, "spec.restoreToPointInTime.restoreToTime", None)
              else:
                  "useLatestRestorableTime": get(_oxr, "spec.restoreToPointInTime.useLatestRestorableTime", True)
          }

          s3import = get(_oxr, "spec.s3Import", False)

          masterInstance = ready("instance-0") and ocdsstatus("instance-0", "id", False)
          clusterIdentifier = ocdsstatus("rds-cluster", "id", "")
          clusterResourceId = ocdsstatus("rds-cluster", "clusterResourceId", "")
          endpoint = ocdsstatus("rds-cluster", "endpoint", "")
          clusterArn = ocdsstatus("rds-cluster", "arn", "")

          mgmtPolicy = get(_oxr, "spec.managementPolicies", [])
          publishConnection = get(_oxr, "spec.publishConnectionDetailsTo", {})

          _secretRef: bool|str = False
          if createCluster:
              if ready("rds-cluster"):
                  _secretRef = ocdsspec("rds-cluster", "writeConnectionSecretToRef.name", "")
          else:
              if ready("instance-0"):
                  _secretRef = ocdsspec("instance-0", "writeConnectionSecretToRef.name", "")
          _connectionSecret = _secretRef

          import json

          clusterId = get(_oxr, "status.clusterIdentifier", None)
          monitoringRoleArn = get(_oxr, "status.monitoringRoleArn", None)
          dbSubnetGroupName = get(_oxr, "status.dbSubnetGroupName", None)

          partition = get(_oxr, "spec.partition", "aws")

          # Has the master instance been built?
          masterInstanceIdentifier = ocdsstatus("instance-0", "identifier", False)
          masterInstanceArn = ocdsstatus("instance-0", "arn", False)

          _specInstances = get(_oxr, "spec.instances", [])

          if not _specInstances and get(_oxr, "spec.instanceCount", 0) > 0:
              _specInstances = [{} for i in range(get(_oxr, "spec.instanceCount", 0))]

          # This will force the secondary (read) replicas to be built after the primary
          # instance has been built. This is to ensure that the primary instance is
          # available for binding.
          buildInstances = _specInstances[:1] if not masterInstance else _specInstances

          ##
          # Create Database Instances
          #
          # This block will create one of two kinds of instance. If the `createCluster`
          # option is set to `true`, then a kind of `ClusterInstance` will be created.
          # This has fewer options assigned to it as it is part of a cluster and by
          # default inherits settings from the Cluster configuration.
          #
          # The other kind of instance is an `Instance`. This is created when the cluster
          # is not being created and is a standalone instance. This instance has more
          # options available to it even though many of them can be inherited from the
          # Cluster configuration.
          #
          # In both instance types, the cluster configuration may be used to spedify
          # common settings across all instances being built-
          instances = [
              {
                  _availabilityZones = get(_oxr, "spec.availabilityZones", [])
                  _az = get(item, "availabilityZone", False)
                  if not _az and len(_availabilityZones) > 0:
                      _az = _availabilityZones[i % len(_availabilityZones)]
                  _az = "${region}${_az}" if _az else ""

                  _instanceRegion = get(item, "region", region)
                  _isCrossRegion = _instanceRegion != region

                  _cacert = get(_oxr, "status.caCertIdentifier", False),
                  _dbp = get(item, "parameterGroupName", get(_oxr, "spec.parameterGroup.name", False)),
                  _isPrimaryInstance = i == 0
                  _multiAz = getwparent(item, _oxr, "multiAz", False)
                  _instanceUseAz = not createCluster and not _multiAz
                  _pt = get(item, "promotionTier", False)

                  _name = "${appName}-${_az}" if not _multiAz else "${appName}-instance-${i}"
                  if createCluster and not _multiAz:
                      _name = "${appName}-clusterinstance-${i}"

                  _version = "v1beta1" if createCluster else "v1beta3"

                  "apiVersion": "rds.aws.upbound.io/${_version}"
                  "kind": "ClusterInstance" if createCluster else "Instance"
                  "metadata": {
                      "annotations": {
                          "krm.kcl.dev/composition-resource-name" = "instance-${i}"
                          "krm.kcl.dev/ready" = readystr("instance-${i}")
                      }
                      "labels": labels
                  }

                  "spec": {
                      "deletionPolicy": dp
                      "initProvider": {
                          if any_true([
                              getwparent(item, _oxr, "allowMajorVersionUpgrade",  True),
                              getwparent(item, _oxr, "autoMinorVersionUpgrade", True),
                          ]):
                              "engineVersion": getwparent(item, _oxr, "engineVersion", "14.0")
                      }
                      "forProvider": {
                          if not createCluster:
                              # These options are specific to the Instance kind
                              "allowMajorVersionUpgrade": getwparent(item, _oxr, "allowMajorVersionUpgrade", True)
                              "backupRetentionPeriod": getwparent(item, _oxr, "backupRetentionPeriod", 7)
                              "backupWindow": getwparent(item, _oxr, "preferredBackupWindow", "03:00-04:00")
                              "deleteAutomatedBackups": getwparent(item, _oxr, "deleteAutomatedBackups", True)
                              "deletionProtection": getwparent(item, _oxr, "deletionProtection", False)

                              _v = getwparent(item, _oxr, "domainIamRoleName",  False)
                              if _v:
                                  "domainIamRoleName": _v

                              "enabledCloudwatchLogsExports": getwparent(item, _oxr, "enabledCloudwatchLogsExports", [])

                              _v = getwparent(item, _oxr, "spec.finalSnapshotIdentifier", False)
                              if _v:
                                  "finalSnapshotIdentifier": _v,

                              "iamDatabaseAuthenticationEnabled": getwparent(item, _oxr, "iamDatabaseAuthenticationEnabled", False)
                              "iops": getwparent(item, _oxr, "iops", 0)
                              "kmsKeyId": keyId,

                              _v = getwparent(item, _oxr, "licenseModel", False)
                              if _v:
                                  "licenseModel": _v

                              "maintenanceWindow": getwparent(item, _oxr, "preferredMaintenanceWindow", "sun:05:00-sun:06:00"),
                              "multiAz": _multiAz,
                              "networkType": getwparent(item, _oxr, "networkType", "ipv4")

                              "identifierPrefix": appName
                              # Option group is specific to non-postgresql instances but
                              # may be set for mysql and mssql instance types
                              _v = getwparent(item, _oxr, "optionGroupName", False)
                              if _v:
                                  "optionGroupName": _v

                              if restoreToPointInTime and get(_oxr, "spec.restoreToPointInTime.identifier", False):
                                  "restoreToPointInTime": [
                                      restoreToPointInTime
                                  ],

                              _skipFS = getwparent(item, _oxr, "skipFinalSnapshot", True)
                              "skipFinalSnapshot": _skipFS
                              if not _skipFS:
                                  "snapshotIdentifier": getwparent(item, _oxr, "snapshotIdentifier", appName)

                              "storageEncrypted": getwparent(item, _oxr, "storageEncrypted", True)

                              _storageType = getwparent(item, _oxr, "storageType", "gp2")
                              if _storageType == "gp3":
                                  "storageThroughput": getwparent(item, _oxr, "spec.storageThroughput", 0)
                              "storageType": _storageType
                              "vpcSecurityGroupIds": [
                                  get(_oxr, "status.securityGroupId", "")
                                  for _ in [True]
                                  if get(_oxr, "status.securityGroupId", False)
                              ],

                              # You cannot have read replicas with manage master user password
                              #
                              # This means that in the longer term, this will be removed as an option
                              # and instead, the password will be pushed to secretsmanager via ESO
                              _managedMasterUserPassword = False # get(item, "manageMasterUserPassword", get(_oxr, "spec.manageMasterUserPassword", True)),
                              _autoGeneratePassword = getwparent(item, _oxr, "autoGeneratePassword", True)

                              # If this is the primary (non-cluster) instance, set
                              # the database name and master user password. Additionally,
                              # if s3Import has been defined, this is configured here.
                              if _isPrimaryInstance:
                                  if _autoGeneratePassword and not _managedMasterUserPassword:
                                      "autoGeneratePassword": _autoGeneratePassword,
                                      "passwordSecretRef": {
                                          "key": "password",
                                          "namespace": namespace,
                                          "name": "${appName}-${region}-rds-autogen-pass",
                                      }

                                  "allocatedStorage": getwparent(item, _oxr, "allocatedStorage", 20)

                                  _dbName = getwparent(item, _oxr, "databaseName", False)
                                  if _dbName:
                                      "dbName": _dbName,
                                  if _managedMasterUserPassword:
                                      "manageMasterUserPassword": _managedMasterUserPassword,
                                      # masterUserSecretKmsKeyId: _keyId,
                                  "username": get(item, "username", get(_oxr, "spec.masterUsername", "")),

                                  if s3import:
                                      "s3import": s3import,

                              # If this is not the primary (non-cluster) instance, the
                              # replication source
                              if all_true([
                                  not _isPrimaryInstance,
                                  masterInstance,
                                  masterInstanceIdentifier,
                              ]):
                                  "replicateSourceDb": masterInstanceIdentifier if not _isCrossRegion else masterInstanceArn,
                              if _dbp:
                                  "parameterGroupName": _dbp

                          "applyImmediately": getwparent(item, _oxr, "applyImmediately", True)
                          "autoMinorVersionUpgrade": getwparent(item, _oxr, "autoMinorVersionUpgrade", True)
                          "dbSubnetGroupName": dbSubnetGroupName,
                          "engine": engine,
                          if any_true([
                              not getwparent(item, _oxr, "allowMajorVersionUpgrade" True)
                              not getwparent(item, _oxr, "autoMinorVersionUpgrade", True)
                          ]):
                              "engineVersion": getwparent(item, _oxr, "engineVersion", "14.0"),

                          # cannot use getwparent here as the parameter names differ
                          "instanceClass": get(item, "instanceClass", get(_oxr, "spec.dbClusterInstanceClass", "db.t3.medium")),
                          "monitoringInterval": get(item, "monitoringInterval", get(_oxr, "spec.enhancedMonitoring.monitoringInterval", 0)),

                          if monitoringRoleArn:
                              "monitoringRoleArn": monitoringRoleArn,

                          _v = getwparent(item, _oxr, "performanceInsightsEnabled" False)
                          if _v:
                              "performanceInsightsEnabled": _v
                              "performanceInsightsKmsKeyId": getwparent(item, _oxr, "performanceInsightsKmsKeyId", keyId)
                              "performanceInsightsRetentionPeriod": getwparent(item, _oxr, "performanceInsightsRetentionPeriod", 7)

                          # Only set the availability zone if this is a cluster instance
                          # or if the instance is not multi-AZ and an availability zone is
                          # provided
                          if (createCluster or _instanceUseAz) and _az:
                              "availabilityZone": _az,

                          if _cacert:
                              "caCertIdentifier": _cacert

                          if createCluster:
                              "clusterIdentifier": clusterId,
                              if _pt:
                                  "promotionTier": _pt,
                              if _dbp:
                                  "dbParameterGroupName": _dbp,

                          "copyTagsToSnapshot": getwparent(item, _oxr, "copyTagsToSnapshot", True)
                          "publiclyAccessible": getwparent(item, _oxr, "publiclyAccessible", False)
                          "region": region,
                          "tags": tags | {
                              "Name": _name
                          },
                      }
                      "managementPolicies": mgmtPolicy,
                      "providerConfigRef": pcr
                      if not createCluster and _isPrimaryInstance:
                          "writeConnectionSecretToRef": {
                              "namespace": get(_oxr, "spec.claimRef.namespace", "default")
                              "name": "${appName}-${region}-rds",
                          }
                  }
              }
              for i, item in buildInstances if all_true([
                  any_true([
                      (createCluster and clusterId != None),
                      not createCluster,
                  ]),
                  keyId, dbSubnetGroupName
              ])
          ]

          _secretRef = False
          if all_true([
              not createCluster,
              ready("instance-0"),
          ]):
              _secretRef = get(_ocds, "instance-0.Resource.spec.writeConnectionSecretToRef", "")

          ##
          # OptionGroups may be specified for non-cluster, non-postgresql instances.
          # postgresql isntances do not use optiongroups but instead uses extensions.
          optionGroup = [
              {
                  "apiVersion": "rds.aws.upbound.io/v1beta1"
                  "kind": "OptionGroup"
                  "metadata": {
                      "annotations": {
                          "krm.kcl.dev/composition-resource-name" = "option-group"
                          "krm.kcl.dev/ready" = readystr("option-group")
                          "crossplane.io/external-name" = get(_oxr, "spec.optionGroup.name", "")
                      }
                      "labels": labels
                  }
                  "spec": {
                      "deletionPolicy": dp
                      "forProvider": {
                          "engineName": engine,
                          "majorEngineVersion": get(_oxr, "spec.engineVersion", "14.0"),
                          "option": [
                              {
                                  if get(item, "dbSecurityGroupMemberships", False):
                                      "dbSecurityGroupMemberships": get(item, "dbSecurityGroupMemberships", []),
                                  "optionName": get(item, "optionName", ""),
                                  "optionSettings": [
                                      {
                                          "name": key,
                                          "value": value,
                                      }
                                      for key, value in get(item, "optionSettings", [])
                                  ],
                              }
                              for i, item in get(_oxr, "spec.optionGroup.options", {})
                          ],

                          "region": region,
                          if get(_oxr, "spec.optionGroup.version", False):
                              "version": get(_oxr, "spec.optionGroup.version", ""),

                          "optionGroupDescription": get(_oxr, "spec.optionGroup.description", "${appName} Option group"),

                          "tags": tags | {
                              "Name": "${appName}-option-group"
                          }
                      }
                      "managementPolicies": mgmtPolicy,
                      "providerConfigRef": pcr
                  }
              } if not createCluster and get(_oxr, "spec.optionGroup.create", False) else {}
          ]

          endpoints = [
              {
                  "apiVersion": "rds.aws.upbound.io/v1beta1"
                  "kind": "ClusterEndpoint"
                  "metadata": {
                      "annotations": {
                          "krm.kcl.dev/composition-resource-name" = "endpoint-${i}"
                          "krm.kcl.dev/ready" = readystr("endpoint-${i}")
                          "crossplane.io/external-name" = "${appName}-${region}-${i}"
                      }
                      "labels": labels
                  }

                  spec: {
                      "deletionPolicy": dp
                      "forProvider": {
                          "clusterEndpointIdentifier": get(item, "clusterEndpointIdentifier", None),
                          "clusterIdentifier": clusterId,
                          "customEndpointType": get(item, "type", "ANY"),
                          "excludeMembers": get(item, "excludeMembers", []),
                          "staticMembers": get(item, "staticMembers", []),
                          "region": region,
                          "tags": tags | {
                              "Name": "${appName}-${region}-${i}"
                          }
                      }
                      "managementPolicies": mgmtPolicy,
                      "providerConfigRef": pcr
                  }
              }
              for i, item in get(_oxr, "spec.endpoints", []) if all_true([
                  createCluster, clusterId != None
              ])
          ]

          ##
          # Create IAM Role associations
          #
          # This will create one of two kinds of IAM Role associations. If the
          # `createCluster` option is set to `true`, then a kind of `ClusterRoleAssociation`
          # will be created.
          #
          # The other kind of IAM Role association is an `InstanceRoleAssociation`. This is
          # created when the cluster is not being created and is a standalone instance,
          # multiAz instance, or standalone with read replicas.
          iam_roles = [
              {
                  "apiVersion": "rds.aws.upbound.io/v1beta1"
                  "kind": "ClusterRoleAssociation" if createCluster else "InstanceRoleAssociation"
                  "metadata": {
                      "annotations": {
                          "krm.kcl.dev/composition-resource-name" = "iam-role-${i}"
                          "krm.kcl.dev/ready" = readystr("iam-role-${i}")
                          "crossplane.io/external-name" = "${appName}-${region}-${i}"
                      }
                      "labels": labels
                  }

                  "spec": {
                      "deletionPolicy": dp
                      "forProvider": {
                          if createCluster:
                              "dbClusterIdentifier": clusterId,
                          else:
                              _v = ocdsstatus("instance-0", "id", False)
                              if _v:
                                  "dbInstanceIdentifier": _v
                          "featureName": get(item, "featureName", "s3Import"),
                          "roleArn": get(item, "roleArn", ""),
                          "region": region,
                          "tags": tags | {
                              "Name": "${appName}-${region}-${i}"
                          }
                      }
                      "managementPolicies": mgmtPolicy,
                      "providerConfigRef": pcr
                  }
              }
              for i, item in get(_oxr, "spec.iamRoles", [])
          ]

          createMonitoringRole = all_true([
              get(_oxr, "spec.enhancedMonitoring.enabled", False),
              get(_oxr, "spec.enhancedMonitoring.monitoringInterval", 0) > 0,
          ])

          monitoringRole = [
              {
                  "apiVersion": "iam.aws.upbound.io/v1beta1"
                  "kind": "Role"
                  "metadata": {
                      "annotations": {
                          "krm.kcl.dev/composition-resource-name" = "enhanced-monitoring-role"
                          "krm.kcl.dev/ready" = readystr("enhanced-monitoring-role")
                          "crossplane.io/external-name" = appName
                      }
                      "labels": labels
                  }
                  "spec": {
                      "deletionPolicy": dp
                      "forProvider": {
                          "assumeRolePolicy": json.encode({
                              "Version": "2012-10-17",
                              "Statement": [
                                  {
                                      "Effect": "Allow",
                                      "Principal": {
                                          "Service": "monitoring.rds.amazonaws.com"
                                      },
                                      "Action": "sts:AssumeRole"
                                  }
                              ]
                          }, ignore_private=True),

                          "description": get(_oxr, "spec.enhancedMonitoring.description", "Role for RDS monitoring"),
                          "managedPolicyArns": get(_oxr, "spec.enhancedMonitoring.managedPolicyArns", None),
                          "permissionsBoundary": get(_oxr, "spec.enhancedMonitoring.permissionsBoundary", None),
                          "forceDetachPolicies": get(_oxr, "spec.enhancedMonitoring.forceDetachPolicies", False),
                          "maxSessionDuration": get(_oxr, "spec.enhancedMonitoring.maxSessionDuration", None),
                          "path": get(_oxr, "spec.enhancedMonitoring.path", "/"),
                          "name": "rds-monitoring-role",
                          "tags": tags | get(_oxr, "spec.enhancedMonitoring.tags", {}) | {
                              "Name": "${appName}-monitoring-role"
                          }
                      }
                      "managementPolicies": mgmtPolicy,
                      "providerConfigRef": pcr
                  }
              } if createMonitoringRole else {}
          ] + [
              {
                  "apiVersion": "iam.aws.upbound.io/v1beta1"
                  "kind": "RolePolicyAttachment"
                  "metadata": {
                      "annotations": {
                          "krm.kcl.dev/composition-resource-name" = "monitoring-role-attachment"
                          "krm.kcl.dev/ready" = readystr("monitoring-role-attachment")
                          "crossplane.io/external-name" = appName
                      }
                      "labels": labels
                  }
                  "spec": {
                      "deletionPolicy": get(_oxr, "spec.deletionPolicy", "Delete"),
                      "forProvider": {
                          "policyArn": "arn:${partition}:iam::aws:policy/service-role/AmazonRDSEnhancedMonitoringRole",
                          "role": "rds-monitoring-role",
                          "tags": tags | {
                              "Name": "${appName}-monitoring-role-attachment"
                          }
                      }
                      "managementPolicies": mgmtPolicy,
                      "providerConfigRef": pcr
                  }
              } if createMonitoringRole else {}
          ]

          instanceCreated = get(_ocds, "instance-0.Resource.status.atProvider.id", False) and createCluster

          # Define autoscaling if this is the required scaling mode for RDS Cluster builds
          autoscalingTarget = [
              {
                  "apiVersion": "appautoscaling.aws.upbound.io/v1beta1"
                  "kind": "Target"
                  "metadata": {
                      "annotations": {
                          "krm.kcl.dev/composition-resource-name" = "autoscaling-target"
                          "krm.kcl.dev/ready" = readystr("autoscaling-target")
                          "crossplane.io/external-name" = "${appName}-autoscaling"
                      }
                      "labels": labels
                  }
                  "spec": {
                      "deletionPolicy": dp
                      "forProvider": {
                          "maxCapacity": get(_oxr, "spec.autoscaling.maxCapacity", 2),
                          "minCapacity": get(_oxr, "spec.autoscaling.minCapacity", 2),
                          "resourceId": "cluster:${clusterId}",
                          "region": region,
                          "scalableDimension": "rds:cluster:ReadReplicaCount",
                          "serviceNamespace": "rds",
                          "tags": tags | get(_oxr, "spec.autoscaling.tags", {}) | {
                              "Name": "${appName}-autoscaling"
                          }
                      }
                      "managementPolicies": mgmtPolicy,
                      "providerConfigRef": pcr
                  }
              } if all_true([
                  instanceCreated,
                  get(_oxr, "spec.autoscaling.enabled", False),
                  createCluster,
               ]) else {}
          ]

          _metricTypes = {
              "RDSReaderAverageCPUUtilization": get(_oxr, "spec.autoscaling.targetCPU", 70),
              "RDSReaderAverageDatabaseConnections": get(_oxr, "spec.autoscaling.targetConnections", 700),
          }

          tc = get(_oxr, "spec.autoscaling.metricType", "RDSReaderAverageCPUUtilization")
          tv =  _metricTypes[tc]

          autoscalingTargetCreated = ocdsstatus("autoscaling-target", "id", False)

          autoscalingPolicy = [
              {
                  "apiVersion": "appautoscaling.aws.upbound.io/v1beta1"
                  "kind": "Policy"
                  "metadata": {
                      "annotations": {
                          "krm.kcl.dev/composition-resource-name" = "autoscaling-policy"
                          "krm.kcl.dev/ready" = readystr("autoscaling-policy")
                      }
                      "labels": labels
                  }
                  "spec": {
                      "deletionPolicy": dp
                      "forProvider": {
                          "policyType": "TargetTrackingScaling",
                          "resourceId": "cluster:${clusterId}",
                          "scalableDimension": "rds:cluster:ReadReplicaCount",
                          "serviceNamespace": "rds",
                          "targetTrackingScalingPolicyConfiguration": [
                              {
                                  "predefinedMetricSpecification": [
                                      {
                                          "predefinedMetricType": tc,
                                      },
                                  ],
                                  "disableScaleIn": get(_oxr, "spec.autoscaling.disableScaleIn", False),
                                  "scaleInCooldown": get(_oxr, "spec.autoscaling.scaleInCooldown", 60),
                                  "scaleOutCooldown": get(_oxr, "spec.autoscaling.scaleOutCooldown", 60),
                                  "targetValue": tv
                              },
                          ],
                          "region": region,
                      }
                      "managementPolicies": mgmtPolicy,
                      "providerConfigRef": pcr
                  }
              } if all_true([
                  autoscalingTargetCreated,
                  get(_oxr, "spec.autoscaling.enabled", False),
                  createCluster,
               ]) else {}
          ]

          autoscaling = autoscalingTarget + autoscalingPolicy

          optionGroupPort = get(_oxr, "spec.optionGroup.port", False)

          # Create security group rules for the cluster
          securityGroupRules = [
              {
                  "apiVersion": "ec2.aws.upbound.io/v1beta1"
                  "kind": "SecurityGroupRule"
                  "metadata": {
                      "annotations": {
                          "krm.kcl.dev/composition-resource-name" = "security-group-rule-${i}"
                          "krn.kcl.dev/ready" = readystr("security-group-rule-${i}")
                      }
                      "labels": labels
                  }
                  "spec": {
                      "deletionPolicy": dp
                      "forProvider": {
                          "securityGroupId": get(_oxr, "status.securityGroupId", ""),
                          "cidrBlocks": [cidr],
                          "fromPort": port,
                          "protocol": "tcp",
                          "region": region,
                          "toPort": port,
                          "type": "ingress",
                      }
                      "managementPolicies": mgmtPolicy,
                      "providerConfigRef": pcr
                  }
              }
              for i, cidr in get(_oxr, "spec.cidrBlocks", []) if all_true([
                  port, cidr,
                  get(_oxr, "status.securityGroupId", False),
              ])
          ] + [
              {
                  "apiVersion": "ec2.aws.upbound.io/v1beta1"
                  "kind": "SecurityGroupRule"
                  "metadata": {
                      "annotations": {
                          "krm.kcl.dev/composition-resource-name" = "security-group-rule-${i}"
                          "krn.kcl.dev/ready" = readystr("security-group-rule-${i}")
                          "crossplane.io/external-name" = "${appName}-sgr-${i}"
                      }
                      "labels": labels
                  }
                  "spec": {
                      "deletionPolicy": dp
                      "forProvider": {
                          "securityGroupId": get(_oxr, "status.securityGroupId", ""),
                          "cidrBlocks": [cidr],
                          "fromPort": optionGroupPort,
                          "protocol": "tcp",
                          "region": region,
                          "toPort": optionGroupPort,
                          type: "ingress",
                      }
                      "managementPolicies": mgmtPolicy,
                      "providerConfigRef": pcr
                  }
              }
              for i, cidr in get(_oxr, "spec.cidrBlocks", []) if all_true([
                  get(_oxr, "spec.optionGroup.enabled", False),
                  get(_oxr, "status.securityGroupId", False),
                  optionGroupPort, port,
                  optionGroupPort != port,
                  cidr
              ])
          ]

          # If the cluster parameter group is requested and we're creating a cluster
          clusterParameterGroup = [
              {
                  "apiVersion": "rds.aws.upbound.io/v1beta1"
                  "kind": "ClusterParameterGroup"
                  "metadata": {
                      "annotations": {
                          "krm.kcl.dev/composition-resource-name" = "cluster-parameter-group"
                          "krm.kcl.dev/ready" = readystr("cluster-parameter-group")
                          "crossplane.io/external-name" = get(_oxr, "spec.dbClusterParameterGroup.name", "")
                      }
                      "labels": labels
                  }
                  "spec": {
                      "deletionPolicy": dp
                      "forProvider": {
                          "description": get(_oxr, "spec.parameterGroup.description", "Cluster parameter group"),
                          "family": get(_oxr, "spec.parameterGroup.family", "aurora-postgresql11"),
                          "parameter": get(_oxr, "spec.parameterGroup.parameters", {}),
                          "region": region,
                          "tags": tags | {
                              "Name": "${appName}-cluster-parameter-group"
                          }
                      }
                      "managementPolicies": mgmtPolicy,
                      "providerConfigRef": pcr
                  }
              } if get(_oxr, "spec.dbClusterParameterGroup.create", False) and createCluster else {}
          ]

          # If the db parameter group is requested create it
          dbParameterGroup = [
              {
                  "apiVersion": "rds.aws.upbound.io/v1beta1"
                  "kind": "ParameterGroup"
                  "metadata": {
                      "annotations": {
                          "krm.kcl.dev/composition-resource-name" = "db-parameter-group"
                          "krm.kcl.dev/ready" = readystr("db-parameter-group")
                          "crossplane.io/external-name" = get(_oxr, "spec.dbParameterGroup.name", "")
                      }
                      "labels": labels
                  }
                  "spec": {
                      "deletionPolicy": get(_oxr, "spec.deletionPolicy", "Delete"),
                      "forProvider": {
                          "description": get(_oxr, "spec.parameterGroup.description", "DB parameter group"),
                          "family": get(_oxr, "spec.parameterGroup.family", "aurora-postgresql11"),
                          "parameter": get(_oxr, "spec.parameterGroup.parameters", {}),
                          "region": region,
                          "tags": tags | {
                              "Name": "${appName}-db-parameter-group"
                          }
                      }
                      "managementPolicies": mgmtPolicy,
                      "providerConfigRef": pcr
                  }
              } if get(_oxr, "spec.dbParameterGroup.create", False) else {}
          ]

          # Cloudwatch log groups
          logGroups = get(_oxr, "spec.enabledCloudwatchLogsExports", [])
          lgEnabled = get(_oxr, "spec.cloudwatchLogGroupParameters.create", False) and len(logGroups) > 0
          cloudwatchLogGroups = [
              {
                  "apiVersion": "cloudwatchlogs.aws.upbound.io/v1beta1"
                  "kind": "Group"
                  "metadata": {
                      "annotations": {
                          "krm.kcl.dev/composition-resource-name" = "log-group-${i}"
                          "krm.kcl.dev/ready" = readystr("log-group-${i}")
                          "crossplane.io/external-name" = "/aws/rds/cluster/${clusterId}/${item}"
                      }
                      "labels": labels
                  }
                  "spec": {
                      "deletionPolicy": dp,
                      "forProvider": {
                          "logGroupClass": get(item, "cloudwatchLogGroupParameters.class", "Standard"),
                          "retentionInDays": get(item, "cloudwatchLogGroupParameters.retentionInDays", 0),
                          "kmsKeyId": keyId,
                          "skipDestroy": get(item, "cloudwatchLogGroupParameters.skipDestroy", False),
                          "region": region,
                          "tags": tags | {
                              "Name": "${appName}-log-group-${i}"
                          }
                      }
                      "managementPolicies": mgmtPolicy,
                      "providerConfigRef": pcr
                  }
              }
              for i, item in logGroups if lgEnabled and keyId
          ]

          # If we're creating a cluster and the activity stream is enabled, create it
          clusterActivityStream = [
              {
                  "apiVersion": "rds.aws.upbound.io/v1beta1"
                  "kind": "ClusterActivityStream"
                  "metadata": {
                      "annotations": {
                          "krm.kcl.dev/composition-resource-name" = "activity-stream"
                          "krm.kcl.dev/ready" = readystr("activity-stream")
                          "crossplane.io/external-name" = appName
                      }
                      "labels": labels
                  }
                  "spec": {
                      "deletionPolicy": dp
                      "forProvider": {
                          "applyImmediately": get(_oxr, "spec.activityStream.applyImmediately", True),
                          "enabled": get(_oxr, "spec.activityStream.enabled", False),
                          "kmsKeyId": get(_oxr, "status.kmsKeyId", None),
                          "mode": get(_oxr, "spec.activityStream.mode", "sync"),
                          "region": region,
                          "tags": tags | {
                              "Name": "${appName}-activity-stream"
                          }
                      }
                      "managementPolicies": mgmtPolicy,
                      "providerConfigRef": pcr
                  }
              } if get(_oxr, "spec.activityStream.enabled", False) and createCluster else {}
          ]

          # If secret rotation is enabled, create the secret rotation resource
          secretRotation = [
              {
                  "apiVersion": "secretsmanager.aws.upbound.io/v1beta1"
                  "kind": "SecretRotation"
                  "metadata": {
                      "annotations": {
                          "krm.kcl.dev/composition-resource-name" = "secret-rotation"
                          "krm.kcl.dev/ready" = readystr("secret-rotation")
                          "crossplane.io/external-name" = appName
                      }
                      "labels": labels
                  }
                  "spec": {
                      "deletionPolicy": dp
                      "forProvider": {
                          "secretId": get(_oxr, "status.secretId", ""),
                          "region": region,
                          "rotateImmediately": get(_oxr, "spec.secretRotation.rotateImmediately", False),
                          "rotationRules": [
                              {
                                  "duration": get(_oxr, "spec.secretRotation.duration", 0),
                              } | {
                                  "automaticallyAfterDays": get(_oxr, "spec.secretRotation.afterDays", 30),
                              } if get(_oxr, "spec.secretRotation.afterDays", False) != False else {
                                  "scheduleExpression": get(_oxr, "spec.secretRotation.scheduleExpression", "")
                              }
                          ],
                      }
                      "managementPolicies": mgmtPolicy,
                      "providerConfigRef": pcr
                  }
              } if get(_oxr, "spec.secretRotation.enabled", False) else {}
          ]

          # Merge all resources into a single flat list
          _items = [
              i for r in [
                  instances, endpoints, iam_roles, monitoringRole,
                  autoscaling, securityGroupRules, clusterParameterGroup,
                  dbParameterGroup, cloudwatchLogGroups, clusterActivityStream,
                  secretRotation,
              ]
              for i in r if i
          ]

          items = _items
        target: ""
    step: function-kcl-create-resources
  - functionRef:
      name: function-kcl
    input:
      apiVersion: krm.kcl.dev/v1alpha1
      kind: KCLInput
      metadata:
        creationTimestamp: null
      spec:
        source: |-
          import regex

          _oxr = option("params").oxr
          _dxr = option("params").dxr
          _ocds = option("params").ocds
          _dcds = option("params").dcds

          get = lambda x: {:}, y: str, d: any -> any {
              """
              Get an item from a dictionary using a dot separated path.
              If the item is not found, return a default value.
              """
              p = regex.split(y, "\.")
              c = p[0]
              y = ".".join(p[1:])
              x[c] if len(p) == 1 and c in x else d if c not in x else get(x[c], y, d)
          }

          getwparent = lambda x: {:}, p: {:}, y: str, d: any -> any {
              """
              Get with fallback to parent
              Tries to get a path from a dictionary, if it fails,
              tries to get it from the parent dictionary.

              If that fails, falls back to the default value provided.
              """
              get(x, y, get(p, "spec.${y}", d))
          }

          ocdsspec = lambda x: str, y: str, d: any -> any {
              """
              Get an item from the spec of an ocds resource.
              """
              get(_ocds, "${x}.Resource.spec.${y}", d)
          }

          ocdsstatus = lambda x: str, y: str, d: any -> any {
              """
              Get an item from the status of an ocds resource.
              """
              get(_ocds, "${x}.Resource.status.atProvider.${y}", d)
          }

          exists = lambda x: any -> bool {
              """
              Check if a value exists.
              """
              x in list(_ocds)
          }

          ready = lambda x: str -> bool {
              """
              Check if a value is ready.
              """
              conditions = get(_ocds, "${x}.Resource.status.conditions", [])
              any_true([
                  all_true([
                      get(c, "status", "False") == "True" for c in conditions
                  ])
              ])
          }

          readystr = lambda x: str -> str {
              """
              Check if a value is ready.
              """
              "True" if ready(x) else "False"
          }

          appName = get(_oxr, "spec.claimRef.name", "")
          createCluster = get(_oxr, "spec.createCluster", True)
          engine = get(_oxr, "spec.engine", "")
          dp = get(_oxr, "spec.deletionPolicy", "Delete")
          keyId = get(_oxr, "status.kmsKeyId", False)
          namespace = get(_oxr, "spec.claimRef.namespace", "default")
          region = get(_oxr, "spec.region", "eu-central-1")
          pcr = get(_oxr, "spec.providerConfigRef", {"name": "default"})
          labels = get(_oxr, "metadata.labels", {}) | {"region": region}
          tags = labels | get(_oxr, "spec.tags", {})

          port = get(_oxr, "status.port", False)
          restoreToPointInTime = {
              if createCluster:
                  "sourceDbClusterIdentifier": get(_oxr, "spec.restoreToPointInTime.sourceDbClusterIdentifier", None),
                  "restoreType": get(_oxr, "spec.restoreToPointInTime.restoreType", "full-copy"),
              else:
                  "sourceDbInstanceIdentifier" = get(_oxr, "spec.restoreToPointInTime.sourceDbClusterIdentifier", None)
                  "sourceDbInstanceAutomatedBackupsArn" = get(_oxr, "spec.restoreToPointInTime.sourceDbInstanceAutomatedBackupsArn", None)
                  "sourceDbiResourceId" = get(_oxr, "spec.restoreToPointInTime.sourceDbiResourceId", None)

              _v = get(_oxr, "spec.restoreToPointInTime.restoreToTime", False)
              if _v:
                  "restoreToTime": get(_oxr, "spec.restoreToPointInTime.restoreToTime", None)
              else:
                  "useLatestRestorableTime": get(_oxr, "spec.restoreToPointInTime.useLatestRestorableTime", True)
          }

          s3import = get(_oxr, "spec.s3Import", False)

          masterInstance = ready("instance-0") and ocdsstatus("instance-0", "id", False)
          clusterIdentifier = ocdsstatus("rds-cluster", "id", "")
          clusterResourceId = ocdsstatus("rds-cluster", "clusterResourceId", "")
          endpoint = ocdsstatus("rds-cluster", "endpoint", "")
          clusterArn = ocdsstatus("rds-cluster", "arn", "")

          mgmtPolicy = get(_oxr, "spec.managementPolicies", [])
          publishConnection = get(_oxr, "spec.publishConnectionDetailsTo", {})

          _secretRef: bool|str = False
          if createCluster:
              if ready("rds-cluster"):
                  _secretRef = ocdsspec("rds-cluster", "writeConnectionSecretToRef.name", "")
          else:
              if ready("instance-0"):
                  _secretRef = ocdsspec("instance-0", "writeConnectionSecretToRef.name", "")
          _connectionSecret = _secretRef

          clusterCreated: bool = ready("rds-cluster")

          newdxr = {
              **_oxr,
              **{
                  "status": {
                      if get(_oxr, "spec.eso.enabled", True) and _connectionSecret:
                          "esoConnectionSecret" = "${appName}-rds-master"
                      if not createCluster and masterInstance:
                          "endpoint" = ocdsstatus("instance-0", "address", ""),
                          "port" = ocdsstatus("instance-0", "port", 0),
                      if _secretRef:
                          "connectionSecret" = _secretRef
                      if createCluster and clusterCreated:
                          if clusterIdentifier:
                              "clusterIdentifier" = clusterIdentifier
                          if clusterResourceId:
                              "clusterResourceId" = clusterResourceId,
                          if clusterArn:
                              "clusterArn" = clusterArn,
                          if endpoint:
                              "endpoint" = endpoint,

                          _port = ocdsstatus("rds-cluster", "port", False) if createCluster else ocdsstatus("instance-0", "port", False)
                          if _port:
                              "port" = _port

                  }
              }
          }

          _items = [newdxr]

          items = _items
        target: ""
    step: function-kcl-patching
  - functionRef:
      name: function-kcl
    input:
      apiVersion: krm.kcl.dev/v1alpha1
      kind: KCLInput
      metadata:
        creationTimestamp: null
      spec:
        source: |-
          import regex

          _oxr = option("params").oxr
          _dxr = option("params").dxr
          _ocds = option("params").ocds
          _dcds = option("params").dcds

          get = lambda x: {:}, y: str, d: any -> any {
              """
              Get an item from a dictionary using a dot separated path.
              If the item is not found, return a default value.
              """
              p = regex.split(y, "\.")
              c = p[0]
              y = ".".join(p[1:])
              x[c] if len(p) == 1 and c in x else d if c not in x else get(x[c], y, d)
          }

          getwparent = lambda x: {:}, p: {:}, y: str, d: any -> any {
              """
              Get with fallback to parent
              Tries to get a path from a dictionary, if it fails,
              tries to get it from the parent dictionary.

              If that fails, falls back to the default value provided.
              """
              get(x, y, get(p, "spec.${y}", d))
          }

          ocdsspec = lambda x: str, y: str, d: any -> any {
              """
              Get an item from the spec of an ocds resource.
              """
              get(_ocds, "${x}.Resource.spec.${y}", d)
          }

          ocdsstatus = lambda x: str, y: str, d: any -> any {
              """
              Get an item from the status of an ocds resource.
              """
              get(_ocds, "${x}.Resource.status.atProvider.${y}", d)
          }

          exists = lambda x: any -> bool {
              """
              Check if a value exists.
              """
              x in list(_ocds)
          }

          ready = lambda x: str -> bool {
              """
              Check if a value is ready.
              """
              conditions = get(_ocds, "${x}.Resource.status.conditions", [])
              any_true([
                  all_true([
                      get(c, "status", "False") == "True" for c in conditions
                  ])
              ])
          }

          readystr = lambda x: str -> str {
              """
              Check if a value is ready.
              """
              "True" if ready(x) else "False"
          }

          appName = get(_oxr, "spec.claimRef.name", "")
          createCluster = get(_oxr, "spec.createCluster", True)
          engine = get(_oxr, "spec.engine", "")
          dp = get(_oxr, "spec.deletionPolicy", "Delete")
          keyId = get(_oxr, "status.kmsKeyId", False)
          namespace = get(_oxr, "spec.claimRef.namespace", "default")
          region = get(_oxr, "spec.region", "eu-central-1")
          pcr = get(_oxr, "spec.providerConfigRef", {"name": "default"})
          labels = get(_oxr, "metadata.labels", {}) | {"region": region}
          tags = labels | get(_oxr, "spec.tags", {})

          port = get(_oxr, "status.port", False)
          restoreToPointInTime = {
              if createCluster:
                  "sourceDbClusterIdentifier": get(_oxr, "spec.restoreToPointInTime.sourceDbClusterIdentifier", None),
                  "restoreType": get(_oxr, "spec.restoreToPointInTime.restoreType", "full-copy"),
              else:
                  "sourceDbInstanceIdentifier" = get(_oxr, "spec.restoreToPointInTime.sourceDbClusterIdentifier", None)
                  "sourceDbInstanceAutomatedBackupsArn" = get(_oxr, "spec.restoreToPointInTime.sourceDbInstanceAutomatedBackupsArn", None)
                  "sourceDbiResourceId" = get(_oxr, "spec.restoreToPointInTime.sourceDbiResourceId", None)

              _v = get(_oxr, "spec.restoreToPointInTime.restoreToTime", False)
              if _v:
                  "restoreToTime": get(_oxr, "spec.restoreToPointInTime.restoreToTime", None)
              else:
                  "useLatestRestorableTime": get(_oxr, "spec.restoreToPointInTime.useLatestRestorableTime", True)
          }

          s3import = get(_oxr, "spec.s3Import", False)

          masterInstance = ready("instance-0") and ocdsstatus("instance-0", "id", False)
          clusterIdentifier = ocdsstatus("rds-cluster", "id", "")
          clusterResourceId = ocdsstatus("rds-cluster", "clusterResourceId", "")
          endpoint = ocdsstatus("rds-cluster", "endpoint", "")
          clusterArn = ocdsstatus("rds-cluster", "arn", "")

          mgmtPolicy = get(_oxr, "spec.managementPolicies", [])
          publishConnection = get(_oxr, "spec.publishConnectionDetailsTo", {})

          _secretRef: bool|str = False
          if createCluster:
              if ready("rds-cluster"):
                  _secretRef = ocdsspec("rds-cluster", "writeConnectionSecretToRef.name", "")
          else:
              if ready("instance-0"):
                  _secretRef = ocdsspec("instance-0", "writeConnectionSecretToRef.name", "")
          _connectionSecret = _secretRef

          externalSecretStores = [
              {
                  "name": get(_oxr, "spec.eso.kubernetesSecretStore", "default"),
                  "clusterScoped": False,
              }
          ]

          pushSecretStores = [
              {
                  "name": store.secretStore,
                  "clusterScoped": True,
              }
              for _, store in get(_oxr, "spec.eso.stores", [])
              if get(_oxr, "spec.eso.enabled", True) and store.enabled
          ]
          usernameField = "username" if not createCluster else "master_username"
          passwordField = "password" if not createCluster else "attribute.master_password"

          pushSecretData = [
              {
                  conversionStrategy: "None"
                  match: {
                      secretKey: k,
                      remoteRef: {
                          remoteKey: k
                      }

                  }
              }
              for _, k in [
                  "endpoint", "port",
                  "password", "username",
              ]
          ]

          deletionPolicy = "Delete" if dp == "Delete" else "Retain"
          esoSqlSecret = [
              {
                  "apiVersion": "kubernetes.crossplane.io/v1alpha2"
                  "kind": "Object"
                  "metadata": {
                      "annotations": {
                          "krm.kcl.dev/composition-resource-name" = "${appName}-externalsecret"
                          "krm.kcl.dev/ready": readystr("${appName}-externalsecret")
                      }
                  }
                  "spec": {
                      "deletionPolicy": dp,
                      "forProvider": {
                          manifest: {
                              "apiVersion": "external-secrets.io/v1alpha1"
                              "kind": "ExternalSecret"
                              "metadata": {
                                  "namespace": namespace
                              }
                              "spec": {
                                  "refreshInterval": "1h"
                                  "secretStoreRef": {
                                      "name": value.name
                                      "kind": "ClusterSecretStore" if value.clusterScoped else "SecretStore"
                                  }
                                  "data": [
                                      {
                                          "secretKey": k.r,
                                          "remoteRef": {
                                              "key": _connectionSecret,
                                              "property": k.p
                                          }
                                      }
                                      for _, k in [
                                          {r: "endpoint", p:"endpoint"},
                                          {r: "port", p: "port"},
                                          {r: "password", p: passwordField},
                                          {r: "username", p: usernameField},
                                      ]
                                  ]
                                  "target": {
                                      "name": "${appName}-rds-master"
                                      "deletionPolicy": deletionPolicy
                                  }
                              }
                          }
                      }
                      "managementPolicies": mgmtPolicy,
                      "providerConfigRef": {
                          "name": get(_oxr, "spec.kubernetesProviderConfig.name", "")
                      }
                  }
              }
              for _, value in externalSecretStores
              if _connectionSecret and get(_oxr, "spec.eso.enabled", True)
          ]

          pushSecret = [
              {
                  "apiVersion": "kubernetes.crossplane.io/v1alpha2"
                  "kind": "Object"
                  "metadata": {
                      "annotations": {
                          "krm.kcl.dev/composition-resource-name" = "${appName}-pushsecret"
                          "krm.kcl.dev/ready": readystr("${appName}-pushsecret")
                      }
                  }
                  "spec": {
                      "deletionPolicy": dp
                      "forProvider": {
                          "manifest": {
                              "apiVersion": "external-secrets.io/v1alpha1"
                              "kind": "PushSecret"
                              "metadata": {
                                  "namespace": get(_oxr, "spec.claimRef.namespace", "default")
                              }
                              "spec": {
                                  "refreshInterval": "10s"
                                  "secretStoreRefs": [
                                      {
                                          "name": value.name
                                          "kind": "ClusterSecretStore" if value.clusterScoped else "SecretStore"
                                      }
                                      for _, value in pushSecretStores
                                  ]
                                  "data": pushSecretData
                                  "deletionPolicy": deletionPolicy
                                  "selector": {
                                      "secret": {
                                          "name": "${appName}-rds-master"
                                      }
                                  }
                                  updatePolicy: "Replace"
                              }
                          }
                      }
                      "managementPolicies": mgmtPolicy,
                      "providerConfigRef": {
                          name: get(_oxr, "spec.kubernetesProviderConfig.name", "")
                      }
                  }
              } for _ in [True] if pushSecretStores and get(_oxr, "spec.eso.enabled", True)
          ]

          _items = [
              i for r in [esoSqlSecret, pushSecret]
              for i in r if i
          ]

          items = _items
        target: ""
    step: function-provision-eso
  - functionRef:
      name: function-kcl
    input:
      apiVersion: krm.kcl.dev/v1alpha1
      kind: KCLInput
      metadata:
        creationTimestamp: null
      spec:
        source: |-
          import regex

          _oxr = option("params").oxr
          _dxr = option("params").dxr
          _ocds = option("params").ocds
          _dcds = option("params").dcds

          get = lambda x: {:}, y: str, d: any -> any {
              """
              Get an item from a dictionary using a dot separated path.
              If the item is not found, return a default value.
              """
              p = regex.split(y, "\.")
              c = p[0]
              y = ".".join(p[1:])
              x[c] if len(p) == 1 and c in x else d if c not in x else get(x[c], y, d)
          }

          getwparent = lambda x: {:}, p: {:}, y: str, d: any -> any {
              """
              Get with fallback to parent
              Tries to get a path from a dictionary, if it fails,
              tries to get it from the parent dictionary.

              If that fails, falls back to the default value provided.
              """
              get(x, y, get(p, "spec.${y}", d))
          }

          ocdsspec = lambda x: str, y: str, d: any -> any {
              """
              Get an item from the spec of an ocds resource.
              """
              get(_ocds, "${x}.Resource.spec.${y}", d)
          }

          ocdsstatus = lambda x: str, y: str, d: any -> any {
              """
              Get an item from the status of an ocds resource.
              """
              get(_ocds, "${x}.Resource.status.atProvider.${y}", d)
          }

          exists = lambda x: any -> bool {
              """
              Check if a value exists.
              """
              x in list(_ocds)
          }

          ready = lambda x: str -> bool {
              """
              Check if a value is ready.
              """
              conditions = get(_ocds, "${x}.Resource.status.conditions", [])
              any_true([
                  all_true([
                      get(c, "status", "False") == "True" for c in conditions
                  ])
              ])
          }

          readystr = lambda x: str -> str {
              """
              Check if a value is ready.
              """
              "True" if ready(x) else "False"
          }

          appName = get(_oxr, "spec.claimRef.name", "")
          createCluster = get(_oxr, "spec.createCluster", True)
          engine = get(_oxr, "spec.engine", "")
          dp = get(_oxr, "spec.deletionPolicy", "Delete")
          keyId = get(_oxr, "status.kmsKeyId", False)
          namespace = get(_oxr, "spec.claimRef.namespace", "default")
          region = get(_oxr, "spec.region", "eu-central-1")
          pcr = get(_oxr, "spec.providerConfigRef", {"name": "default"})
          labels = get(_oxr, "metadata.labels", {}) | {"region": region}
          tags = labels | get(_oxr, "spec.tags", {})

          port = get(_oxr, "status.port", False)
          restoreToPointInTime = {
              if createCluster:
                  "sourceDbClusterIdentifier": get(_oxr, "spec.restoreToPointInTime.sourceDbClusterIdentifier", None),
                  "restoreType": get(_oxr, "spec.restoreToPointInTime.restoreType", "full-copy"),
              else:
                  "sourceDbInstanceIdentifier" = get(_oxr, "spec.restoreToPointInTime.sourceDbClusterIdentifier", None)
                  "sourceDbInstanceAutomatedBackupsArn" = get(_oxr, "spec.restoreToPointInTime.sourceDbInstanceAutomatedBackupsArn", None)
                  "sourceDbiResourceId" = get(_oxr, "spec.restoreToPointInTime.sourceDbiResourceId", None)

              _v = get(_oxr, "spec.restoreToPointInTime.restoreToTime", False)
              if _v:
                  "restoreToTime": get(_oxr, "spec.restoreToPointInTime.restoreToTime", None)
              else:
                  "useLatestRestorableTime": get(_oxr, "spec.restoreToPointInTime.useLatestRestorableTime", True)
          }

          s3import = get(_oxr, "spec.s3Import", False)

          masterInstance = ready("instance-0") and ocdsstatus("instance-0", "id", False)
          clusterIdentifier = ocdsstatus("rds-cluster", "id", "")
          clusterResourceId = ocdsstatus("rds-cluster", "clusterResourceId", "")
          endpoint = ocdsstatus("rds-cluster", "endpoint", "")
          clusterArn = ocdsstatus("rds-cluster", "arn", "")

          mgmtPolicy = get(_oxr, "spec.managementPolicies", [])
          publishConnection = get(_oxr, "spec.publishConnectionDetailsTo", {})

          _secretRef: bool|str = False
          if createCluster:
              if ready("rds-cluster"):
                  _secretRef = ocdsspec("rds-cluster", "writeConnectionSecretToRef.name", "")
          else:
              if ready("instance-0"):
                  _secretRef = ocdsspec("instance-0", "writeConnectionSecretToRef.name", "")
          _connectionSecret = _secretRef

          esoEnabled = get(_oxr, "spec.eso.enabled", False)
          esoConnectionSecret = get(_oxr, "status.esoConnectionSecret", False)
          sqlEnabled = get(_oxr, "spec.provisionSql.enabled", True)

          if createCluster and sqlEnabled:
              assert esoEnabled != False, "ESO must be enabled when creating a cluster with SQL provisioning enabled."

          useConnectionSecret: str|bool = esoConnectionSecret if esoEnabled else _connectionSecret

          _items = [
              {
                  apiVersion: "xdatabase.crossplane.giantswarm.io/v1alpha1"
                  kind: "RdsProvisioning"
                  metadata: {
                      annotations: {
                          "krm.kcl.dev/composition-resource-name": "${appName}-rds-provisioning"
                          "krm.kcl.dev/ready": readystr("${appName}-rds-provisioning")
                      }
                  }
                  spec: {
                      "deletionPolicy": dp,
                      "engine": get(_oxr, "spec.engine", "postgres")
                      "claimRef": get(_oxr, "spec.claimRef", {})
                      "connectionSecretName": useConnectionSecret
                      "databases": get(_oxr, "spec.databases", {})
                      "kubernetesProviderConfig": get(_oxr, "spec.kubernetesProviderConfig", {"name": "default"})
                      "managementPolicies": mgmtPolicy,
                  }
              }
              for _ in [True]
              if get(_oxr, "spec.provisionSql.enabled", True) and useConnectionSecret
          ]

          items = _items
        target: ""
    step: function-provision-sql
  - functionRef:
      name: function-auto-ready
    step: function-auto-ready
