apiVersion: apiextensions.crossplane.io/v1
kind: Composition
metadata:
  creationTimestamp: null
  labels:
    component: elasticache
    provider: aws
    type: base
  name: cache-base
spec:
  compositeTypeRef:
    apiVersion: xcache.crossplane.giantswarm.io/v1alpha1
    kind: Elasticache
  mode: Pipeline
  pipeline:
  - functionRef:
      name: function-patch-and-transform
    input:
      apiVersion: pt.crossplane.io/v1beta1
      kind: Resources
      metadata:
        creationTimestamp: null
      patchSets:
      - name: metadata
        patches:
        - fromFieldPath: metadata.labels
          policy:
            toFieldPath: MergeObjects
          toFieldPath: metadata.labels
          type: FromCompositeFieldPath
        - fromFieldPath: spec.region
          toFieldPath: metadata.labels.region
          type: FromCompositeFieldPath
        - fromFieldPath: spec.providerConfigRef
          toFieldPath: spec.providerConfigRef
          type: FromCompositeFieldPath
        - fromFieldPath: spec.deletionPolicy
          toFieldPath: spec.deletionPolicy
          type: FromCompositeFieldPath
      - name: commontags
        patches:
        - fromFieldPath: spec.tags
          policy:
            toFieldPath: MergeObjects
          toFieldPath: spec.forProvider.tags
          type: FromCompositeFieldPath
        - fromFieldPath: metadata.labels
          policy:
            toFieldPath: MergeObjects
          toFieldPath: spec.forProvider.tags
          type: FromCompositeFieldPath
        - fromFieldPath: spec.region
          toFieldPath: spec.forProvider.tags.region
          type: FromCompositeFieldPath
      resources:
      - base:
          apiVersion: kms.aws.upbound.io/v1beta1
          kind: Key
          metadata:
            creationTimestamp: null
          spec:
            forProvider:
              region: null
            initProvider: {}
          status:
            atProvider: {}
        name: kms
        patches:
        - fromFieldPath: spec.region
          toFieldPath: spec.forProvider.region
          type: FromCompositeFieldPath
        - fromFieldPath: status.atProvider.arn
          toFieldPath: status.kmsKeyId
          type: ToCompositeFieldPath
        - combine:
            strategy: string
            string:
              fmt: '%s-%s'
            variables:
            - fromFieldPath: spec.claimRef.name
            - fromFieldPath: spec.region
          toFieldPath: spec.forProvider.tags.Name
          type: CombineFromComposite
        - patchSetName: commontags
          type: PatchSet
        - patchSetName: metadata
          type: PatchSet
      - base:
          apiVersion: elasticache.aws.upbound.io/v1beta1
          kind: SubnetGroup
          metadata:
            creationTimestamp: null
          spec:
            forProvider:
              region: null
            initProvider: {}
          status:
            atProvider: {}
        name: subnetgroup
        patches:
        - fromFieldPath: spec.region
          toFieldPath: spec.forProvider.region
          type: FromCompositeFieldPath
        - fromFieldPath: spec.subnetIds
          policy:
            fromFieldPath: Required
          toFieldPath: spec.forProvider.subnetIds
          type: FromCompositeFieldPath
        - patchSetName: commontags
          type: PatchSet
        - patchSetName: metadata
          type: PatchSet
        - fromFieldPath: status.atProvider.id
          toFieldPath: status.subnetGroupName
          type: ToCompositeFieldPath
        - combine:
            strategy: string
            string:
              fmt: '%s %s elasticache subnet group'
            variables:
            - fromFieldPath: spec.claimRef.name
            - fromFieldPath: spec.region
          toFieldPath: spec.forProvider.description
          type: CombineFromComposite
      - base:
          apiVersion: ec2.aws.upbound.io/v1beta1
          kind: SecurityGroup
          metadata:
            creationTimestamp: null
          spec:
            forProvider:
              region: null
              revokeRulesOnDelete: true
            initProvider: {}
          status:
            atProvider: {}
        name: securitygroup
        patches:
        - fromFieldPath: spec.vpcId
          toFieldPath: spec.forProvider.vpcId
          type: FromCompositeFieldPath
        - fromFieldPath: spec.region
          toFieldPath: spec.forProvider.region
          type: FromCompositeFieldPath
        - patchSetName: commontags
          type: PatchSet
        - patchSetName: metadata
          type: PatchSet
        - combine:
            strategy: string
            string:
              fmt: '%s %s elasticache security group'
            variables:
            - fromFieldPath: spec.claimRef.name
            - fromFieldPath: spec.region
          toFieldPath: spec.forProvider.description
          type: CombineFromComposite
        - fromFieldPath: status.atProvider.id
          toFieldPath: status.securityGroupId
          type: ToCompositeFieldPath
    step: patch-and-transform
  - functionRef:
      name: function-kcl
    input:
      apiVersion: krm.kcl.dev/v1alpha1
      kind: KCLInput
      metadata:
        creationTimestamp: null
      spec:
        source: |-
          import regex

          _oxr = option("params").oxr
          _dxr = option("params").dxr
          _ocds = option("params").ocds
          _dcds = option("params").dcds

          get = lambda x: any, y: str, d: any -> any {
              """
              Get an item from a dictionary using a dot separated path.
              If the item is not found, return a default value.
              """
              p = regex.split(y, "\.")
              c = p[0]
              y = ".".join(p[1:])
              x[c] if len(p) == 1 and c in x else d if c not in x else get(x[c], y, d)
          }

          if get(_oxr, "spec.createReplicationGroup", False):
              assert get(_oxr, "spec.engine", "redis") == "redis", "engine must be redis when createReplicationGroup is true"

          _appName = get(_oxr, "spec.claimRef.name", "")
          _created = get(_ocds, "elasticache-replication-group.Resource", {})
          _createReplicationGroup = get(_oxr, "spec.createReplicationGroup", True)
          _clusterModeEnabled = get(_oxr, "spec.clusterMode.enabled", False)
          _region = get(_oxr, "spec.region", "eu-central-1")
          _azs = [
              "${_region}${az}"
              for az in get(_oxr, "spec.availabilityZones", [])
          ]

          _subnetGroup = get(_oxr, "status.subnetGroupName", False)
          _keyId = get(_oxr, "status.kmsKeyId", False)
          _ipgn = get(_oxr, "status.parameterGroupName", "") if get(_oxr, "spec.allowMajorVersionUpgrade", False) else ""
          _labels = get(_oxr, "metadata.labels", {}) | {
              "region": get(_oxr, "spec.region", "eu-central-1"),
          }

          _securityGroupIds = [
              get(_oxr, "status.securityGroupId", None),
          ] + [
              i for r in get(_oxr, "spec.securityGroupIds", []) for i in r
          ]

          # Currently Crossplane does not support the GlobalReplicationGroup resource
          #
          # Until this CRD is implemented, we will be defining, but force disabling the
          # following block - this saves having to extend the composition to support this
          # in the future but would just require re-enabling the block by removing `False`
          # from the `all_true` check.
          # https://github.com/crossplane-contrib/provider-upjet-aws/issues/1333

          # In order to create a global replication group, we must be creating a
          # local replication group as well. Global is secondary.
          _globalEnabled = all_true([
              False,
              _createReplicationGroup,
              get(_oxr, "spec.globalReplicationGroup.enabled", False)
          ])

          _primaryGlobalRID = get(_oxr, "spec.globalReplicationGroupId", "") if _globalEnabled else ""
          _replicationGlobalRID = get(_oxr, "status.globalReplicationGroupId", "") if _globalEnabled else get(_oxr, "spec.globalReplicationGroupId", "")

          _parameterGroup = [
              {
                  apiVersion: "elasticache.aws.upbound.io/v1beta1"
                  kind: "ParameterGroup"
                  "metadata": {
                      annotations: {
                          "krm.kcl.dev/composition-resource-name": "elasticache-parameter-group"
                      }
                      labels: _labels
                  }
                  spec: {
                      deletionPolicy: _oxr.spec.deletionPolicy
                      forProvider: {
                          description: _appName + " Parameter Group"
                          family: get(_oxr, "spec.parameterGroupFamily", "redis6.x")
                          name: _appName + "-parameter-group"
                          if get(_oxr, "spec.parameters", False):
                              parameter = [
                                  {
                                      name: k,
                                      value: v,
                                  }
                                  for k, v in get(_oxr, "spec.parameterGroupConfiguration.parameters", {})
                              ]
                          region = _region
                          tags = _labels | {
                              "Name": "${_appName}-${_region}"
                          } | get(_oxr, "spec.tags", {}) | get(_oxr, "spec.parameterGroupConfiguration.tags", {})
                      }
                      providerConfigRef: get(_oxr, "spec.providerConfigRef", {"name": "default"})
                  }
              }
          ] if get(_oxr, "spec.parameterGroupConfiguration", False) else []

          _globalReplicationGroup = [{
              apiVersion: "elasticache.aws.upbound.io/v1beta1"
              kind: "GlobalReplicationGroup"
              "metadata": {
                  annotations: {
                      "krm.kcl.dev/composition-resource-name": "global-elasticache-replication-group"
                  }
                  labels: _labels
              }
              spec: {
                  deletionPolicy: _oxr.spec.deletionPolicy
                  forProvider: {
                      automaticFailoverEnabled: get(_oxr, "spec.globalReplicationGroup.automaticFailoverEnabled", False)
                      cacheNodeType: get(_oxr, "spec.globalReplicationGroup.cacheNodeType", "cache.t3.micro")
                      globalReplicationGroupIdSuffix: get(_oxr, "spec.globalReplicationGroup.suffix", "")
                      globalReplicationGroupDescription: _appName + " Global Replication Group"
                      if get(_oxr, "spec.globalReplicationGroup.numNodeGroups", False):
                          numNodeGroups: _oxr.spec._globalReplicationGroup.numNodeGroups

                      if _primaryGlobalRID:
                          primaryReplicationGroupId: _primaryGlobalRID
                  }
                  providerConfigRef: get(_oxr, "spec.providerConfigRef", {"name": "default"})
              }
          }] if _globalEnabled else []

          _enabledReplicationGroups = [
              "global" if _globalEnabled else "",
              # We don't want to create the local replication group if global replication
              # is enabled until the GlobalReplicationGroup is ready.
              "local" if any_true([
                  all_true([
                      _globalEnabled,
                      get(_ocds, "global-elasticache-replication-group.Resource.status.id", False),
                  ]),
                  not _globalEnabled,
              ]) else "",
          ]

          _replicationGroups = [
              {
                  apiVersion: "elasticache.aws.upbound.io/v1beta1"
                  kind: "ReplicationGroup"
                  "metadata": {
                      annotations: {
                          "krm.kcl.dev/composition-resource-name": "elasticache-replication-group-${i}"
                      }
                      labels: _labels
                  }
                  spec: {
                      deletionPolicy: _oxr.spec.deletionPolicy
                      initProvider: {
                          if get(_oxr, "spec.autoMinorVersionUpgrade", False):
                              if get(_oxr, "spec.engineVersion", False):
                                  engineVersion: _oxr.spec.engineVersion
                      }
                      forProvider: {
                          if get(_oxr, "spec.applyImmediately", None) != None:
                              applyImmediately: _oxr.spec.applyImmediately
                          if get(_oxr, "spec.atRestEncryptionEnabled", None) != None:
                              atRestEncryptionEnabled: _oxr.spec.atRestEncryptionEnabled
                          if get(_oxr, "spec.authToken", False):
                              authToken: _oxr.spec.authToken
                          if get(_oxr, "spec.authTokenUpdateStrategy", False):
                              authTokenUpdateStrategy: _oxr.spec.authTokenUpdateStrategy
                          if get(_oxr, "spec.autoMinorVersionUpgrade", None) != None:
                              autoMinorVersionUpgrade: _oxr.spec.autoMinorVersionUpgrade
                          if get(_oxr, "spec.automaticFailoverEnabled", None) != None:
                              automaticFailoverEnabled: _oxr.spec.automaticFailoverEnabled
                          if get(_oxr, "spec.dataTieringEnabled", False):
                              dataTieringEnabled: _oxr.spec.dataTieringEnabled

                          if i == "global":
                              description: _appName + " Replication Group ${_region} (Global)"

                          if i == "local":
                              description: _appName + " Replication Group ${_region} (Local)"

                          if get(_oxr, "spec.engine", False):
                              engine: _oxr.spec.engine

                          if not get(_oxr, "spec.autoMinorVersionUpgrade", False):
                              if get(_oxr, "spec.engineVersion", False):
                                  engineVersion: _oxr.spec.engineVersion

                          if get(_oxr, "spec.finalSnapshotIdentifier", False):
                              finalSnapshotIdentifier: _oxr.spec.finalSnapshotIdentifier

                          if _replicationGlobalRID:
                              globalReplicationGroupId: _replicationGlobalRID

                          if get(_oxr, "spec.ipDiscovery", False):
                              ipDiscovery: _oxr.spec.ipDiscovery

                          kmsKeyId: _keyId

                          if get(_oxr, "spec.maintenanceWindow", False):
                              maintenanceWindow: _oxr.spec.maintenanceWindow
                          if get(_oxr, "spec.multiAzEnabled", None) != None:
                              multiAzEnabled: _oxr.spec.multiAzEnabled
                          if get(_oxr, "spec.networkType", False):
                              networkType: _oxr.spec.networkType

                          if get(_oxr, "spec.notificationTopicArn", False):
                              notificationTopicArn: _oxr.spec.notificationTopicArn

                          if all_true([
                              get(_oxr, "spec.numCacheClusters", False),
                              not get(_oxr, "spec.numNodeGroups", False),
                              not _clusterModeEnabled
                          ]):
                              numCacheClusters: get(_oxr, "spec.numCacheClusters", 1)

                          # numNodeGroups cannot be set if global replication group id is set
                          if any_true([
                              get(_oxr, "spec.globalReplicationGroupId", False),
                              i == "global"
                              all_true([
                                  not get(_oxr, "spec.globalReplicationGroup.enabled", False),
                                  not get(_oxr, "spec.globalReplicationGroupId", False),
                                  i == "local"
                              ])
                          ]):
                              if get(_oxr, "spec.nodeType", False):
                                  nodeType: _oxr.spec.nodeType
                              if all_true([
                                  _clusterModeEnabled,
                                  get(_oxr, "spec.numNodeGroups", False)
                              ]):
                                  numNodeGroups: _oxr.spec.numNodeGroups
                          if _ipgn:
                              parameterGroupName: _ipgn

                          if get(_oxr, "spec.port", False):
                              port: _oxr.spec.port

                          if _azs:
                              preferredCacheClusterAzs: _azs

                          if get(_oxr, "spec.replicasPerNodeGroup", None) != None:
                              replicasPerNodeGroup: get(_oxr, "spec.replicasPerNodeGroup", 0)

                          region: _region

                          if _securityGroupIds:
                              securityGroupIds: [i for i in _securityGroupIds if i]

                          if any_true([
                              all_true([
                                  i == "global",
                                  get(_oxr, "status.subnetGroupName", False),
                              ]),
                              all_true([
                                  not get(_oxr, "spec.globalReplicationGroup.enabled", False),
                                  i == "local",
                                  get(_oxr, "status.subnetGroupName", False),
                              ])
                          ]):
                              subnetGroupName: _subnetGroup

                          if get(_oxr, "spec.snapshotRetentionLimit", False):
                              snapshotRetentionLimit: _oxr.spec.snapshotRetentionLimit
                          if get(_oxr, "spec.snapshotWindow", False):
                              snapshotWindow: _oxr.spec.snapshotWindow
                          if get(_oxr, "spec.transitEncryptionEnabled", None) != None:
                              transitEncryptionEnabled: _oxr.spec.transitEncryptionEnabled
                          if get(_oxr, "spec.userGroupIds", False):
                              userGroupIds: _oxr.spec.userGroupIds

                          tags: _labels | {
                              "Name": "${_appName}-${_region}-${i}"
                          } | get(_oxr, "spec.tags", {})
                      }
                      providerConfigRef: get(_oxr, "spec.providerConfigRef", {"name": "default"})
                  }
              } for _, i in _enabledReplicationGroups if all_true([
                  _createReplicationGroup,
                  i,
                  get(_oxr, "spec.engine", "redis") == "redis",
                  any_true([
                      i == "global",
                      all_true([i == "local", not _globalEnabled]),
                      all_true([i == "local", _globalEnabled, _replicationGlobalRID]),
                  ]),
                  get(_oxr, "status.subnetGroupName", False)
                  get(_oxr, "status.securityGroupId", False)
                  _keyId
              ])
          ]

          _items = [_replicationGroups, _globalReplicationGroup]
          items = [i for r in _items for i in r if i]
        target: ""
    step: function-kcl-create-replicationgroup
  - functionRef:
      name: function-kcl
    input:
      apiVersion: krm.kcl.dev/v1alpha1
      kind: KCLInput
      metadata:
        creationTimestamp: null
      spec:
        source: |-
          import regex

          _oxr = option("params").oxr
          _dxr = option("params").dxr
          _ocds = option("params").ocds
          _dcds = option("params").dcds

          get = lambda x: any, y: str, d: any -> any {
              """
              Get an item from a dictionary using a dot separated path.
              If the item is not found, return a default value.
              """
              p = regex.split(y, "\.")
              c = p[0]
              y = ".".join(p[1:])
              x[c] if len(p) == 1 and c in x else d if c not in x else get(x[c], y, d)
          }

          # If we are not creating a replication group, check how many cache clusters have
          # been requested and default a list of empty dictionaries as being the cache
          # cluster template.
          _requiredClusters = get(_oxr, "spec.cacheClusters", []) if get(_oxr, "spec.cacheClusters", False) else [
              {}
              for i in range(get(_oxr, "spec.numCacheClusters", 1))
              if not get(_oxr, "spec.createReplicationGroup", False)
          ]

          _region = get(_oxr, "spec.region", "eu-central-1")
          _appName = get(_oxr, "spec.claimRef.name", "")

          _azs = [
              "${_region}${az}"
              for az in get(_oxr, "spec.availabilityZones", [])
          ]

          _clusters = [
              {
                  apiVersion: "elasticache.aws.upbound.io/v1beta1"
                  kind: "Cluster"
                  "metadata": {
                      annotations: {
                          "krm.kcl.dev/composition-resource-name": "elasticache-cluster-${i}"
                      }
                  }
                  "spec": {
                      deletionPolicy: _oxr.spec.deletionPolicy
                      initProvider: {
                          if get(_oxr, "spec.autoMinorVersionUpgrade", False):
                              if get(_oxr, "spec.engineVersion", False):
                                  engineVersion: _oxr.spec.engineVersion
                      }

                      forProvider: {
                          if get(cluster, "applyImmediately", get(_oxr, "spec.applyImmediately", False)):
                              applyImmediately: get(cluster, "applyImmediately", get(_oxr, "spec.applyImmediately", True))
                          if get(cluster, "autoMinorVersionUpgrade", get(_oxr, "spec.autoMinorVersionUpgrade", False)):
                              autoMinorVersionUpgrade: get(cluster, "autoMinorVersionUpgrade", get(_oxr, "spec.autoMinorVersionUpgrade", True)),

                          _az = get(cluster, "availabilityZone", _azs[i % len(_azs)])
                          if get(cluster, "availabilityZone", False):
                              availabilityZone: _az,

                          if all_true([
                              get(cluster, "azMode", get(_oxr, "spec.azMode", False)),
                              get(cluster, "engine", get(_oxr, "spec.engine", False)) == "memcached",
                          ]):
                              azMode: get(cluster, "azMode", get(_oxr, "spec.azMode", "cross-az")),
                              numCacheNodes = get(cluster, "numCacheNodes", len(_azs)),

                          if get(cluster, "engine", get(_oxr, "spec.engine", False)):
                              engine = get(cluster, "engine", get(_oxr, "spec.engine", "redis")),

                          if not get(_oxr, "spec.autoMinorVersionUpgrade", False):
                              if get(cluster, "engineVersion", get(_oxr, "spec.engineVersion", False)):
                                  engineVersion = get(cluster, "engineVersion", get(_oxr, "spec.engineVersion", "6.x")),
                          if get(cluster, "finalSnapshotIdentifier", get(_oxr, "spec.finalSnapshotIdentifier", False)):
                              finalSnapshotIdentifier = get(cluster, "finalSnapshotIdentifier", get(_oxr, "spec.finalSnapshotIdentifier", "")),

                          if get(cluster, "ipDiscovery", get(_oxr, "spec.ipDiscovery", False)):
                              ipDiscovery = get(cluster, "ipDiscovery", get(_oxr, "spec.ipDiscovery", "dns")),

                          if all_true([
                              get(cluster, "spec.engine", get(_oxr, "spec.engine", "redis")) == "redis",
                              get(cluster, "logDeliveryConfiguration", get(_oxr, "spec.logDeliveryConfiguration", False)),
                          ]):
                              _config = get(cluster, "logDeliveryConfiguration", get(_oxr, "spec.logDeliveryConfiguration", []))
                              logDeliveryConfiguration = [{
                                  if get(c, "destination", False):
                                      destination: get(c, "destination", ""),
                                  if get(c, "destinationType", False):
                                      destinationType = c.destinationType,
                                  if get(c, "logFormat", False):
                                      logFormat = c.logFormat,
                                  if get(c, "logType", False):
                                      logType = c.logType,
                              } for c in _config],

                          if get(cluster, "maintenanceWindow", get(_oxr, "spec.maintenanceWindow", False)):
                              maintenanceWindow = get(cluster, "maintenanceWindow", get(_oxr, "spec.maintenanceWindow", "Sun:05:00-Mon:09:00")),

                          if get(cluster, "networkType", get(_oxr, "spec.networkType", False)):
                              networkType = get(cluster, "networkType", get(_oxr, "spec.networkType", "ipv4")),

                          if get(cluster, "nodeType", get(_oxr, "spec.nodeType", False)):
                              nodeType = get(cluster, "nodeType", get(_oxr, "spec.nodeType", "cache.t3.micro")),

                          if get(cluster, "notificationTopicArn", get(_oxr, "spec.notificationTopicArn", False)):
                              notificationTopicArn = get(cluster, "notificationTopicArn", get(_oxr, "spec.notificationTopicArn", "")),

                          if all_true([
                              get(cluster, "outpostMode", get(_oxr, "spec.outpostMode", False)),
                              get(cluster, "preferredOutpostArn", get(_oxr, "spec.preferredOutpostArn", False)),
                          ]):
                              outpostMode = get(cluster, "outpostMode", get(_oxr, "spec.outpostMode", "none")),
                              preferredOutpostArn = get(cluster, "preferredOutpostArn", get(_oxr, "spec.preferredOutpostArn", "")),

                          if get(_oxr, "status.parameterGroupName", False):
                              parameterGroupName = get(_oxr, "status.parameterGroupName", ""),

                          if get(cluster, "port", get(_oxr, "spec.port", False)):
                              port = get(cluster, "port", get(_oxr, "spec.port", 6379))

                          if not get(cluster, "availabilityZone", False):
                              preferredAvailabilityZones = _azs

                          region = _region,

                          if all_true([
                              get(_oxr, "spec.createReplicationGroup", False),
                              get(_oxr, "status.localReplicationGroupId", False),
                          ]):
                              replicationGroupId = get(_oxr, "status.localReplicationGroupId", ""),

                          if get(_oxr, "status.securityGroupId", False):
                              securityGroupIds = [
                                  get(_oxr, "status.securityGroupId", None),
                              ] + get(cluster, "securityGroupIds", get(_oxr, "spec.securityGroupIds", [])),

                          if get(cluster, "snapshotArns", get(_oxr, "spec.snapshotArns", False)):
                              snapshotArns = get(cluster, "snapshotArns", get(_oxr, "spec.snapshotArns", [])),

                          if get(cluster, "snapshotName", get(_oxr, "spec.snapshotName", False)):
                              snapshotName = get(cluster, "snapshotName", get(_oxr, "spec.snapshotName", "")),
                          if get(cluster, "snapshotRetentionLimit", get(_oxr, "spec.snapshotRetentionLimit", False)):
                              snapshotRetentionLimit = get(cluster, "snapshotRetentionLimit", get(_oxr, "spec.snapshotRetentionLimit", 1)),
                          if get(cluster, "snapshotWindow", get(_oxr, "spec.snapshotWindow", False)):
                              snapshotWindow = get(cluster, "snapshotWindow", get(_oxr, "spec.snapshotWindow", "00:00-01:00")),

                          # Only assign subnetGroup if we are not creating a replication group
                          if all_true([
                              get(_oxr, "status.subnetGroupName", False),
                              not get(cluster, "createReplicationGroup", get(_oxr, "spec.createReplicationGroup", False)),
                          ]):
                              subnetGroupName = get(cluster, "subnetGroupName", get(_oxr, "status.subnetGroupName", "")),

                          tags = get(cluster, "tags", get(_oxr, "spec.tags", {})) | {
                              "Name": "${_appName}-${_region}-${_az}"
                          },

                          if get(cluster, "transitEncryptionEnabled", get(_oxr, "spec.transitEncryptionEnabled", False)):
                              transitEncryptionEnabled = get(cluster, "transitEncryptionEnabled", get(_oxr, "spec.transitEncryptionEnabled", False)),
                      }
                      providerConfigRef: get(_oxr, "spec.providerConfigRef", {"name": "default"})
                  }
              }
              for i, cluster in _requiredClusters
              if all_true([
                  get(_oxr, "status.subnetGroupName", False)
                  get(_oxr, "status.securityGroupId", False)
              ])
          ]

          _port = get(_oxr, "status.port", False)
          _securityGroupRules = [
              {
                  apiVersion: "ec2.aws.upbound.io/v1beta1"
                  kind: "SecurityGroupRule"
                  "metadata": {
                      annotations: {
                          "krm.kcl.dev/composition-resource-name": "elasticache-security-group-rule-inbound"
                      }
                  }
                  "spec": {
                      deletionPolicy: _oxr.spec.deletionPolicy
                      forProvider: {
                          cidrBlocks: [cidr],
                          fromPort: _port,
                          protocol: "tcp",
                          region: _region,
                          securityGroupId: get(_oxr, "status.securityGroupId", ""),
                          type: "ingress",
                      }
                      providerConfigRef: get(_oxr, "spec.providerConfigRef", {"name": "default"})
                  }
              }
              for _, cidr in get(_oxr, "spec.cidrBlocks", [])
              if all_true([
                  get(_oxr, "status.securityGroupId", False),
                  _port
              ])
          ]

          _items = [_clusters, _securityGroupRules]
          items = [i for r in _items for i in r if i]
        target: ""
    step: function-kcl-create-cluster
  - functionRef:
      name: function-kcl
    input:
      apiVersion: krm.kcl.dev/v1alpha1
      kind: KCLInput
      metadata:
        creationTimestamp: null
      spec:
        source: |-
          import regex

          _oxr = option("params").oxr
          _ocds = option("params").ocds

          get = lambda x: any, y: str, d: any -> any {
              """
              Get an item from a dictionary using a dot separated path.
              If the item is not found, return a default value.
              """
              p = regex.split(y, "\.")
              c = p[0]
              y = ".".join(p[1:])
              x[c] if len(p) == 1 and c in x else d if c not in x else get(x[c], y, d)
          }

          _createReplicationGroup = get(_oxr, "spec.createReplicationGroup", True)
          _globalEnabled = all_true([
              False,
              _createReplicationGroup,
              get(_oxr, "spec.globalReplicationGroup.enabled", False)
          ])

          _globalEndpoint = get(_ocds, "elasticache-replication-group-global.Resource.status.atProvider.primaryEndpointAddress", "") if _globalEnabled else ""
          _globalROEndpoint = get(_ocds, "elasticache-replication-group-global.Resource.status.atProvider.readerEndpointAddress", "") if _globalEnabled else ""

          _endpoint = get(_ocds, "elasticache-replication-group-local.Resource.status.atProvider.primaryEndpointAddress", "") if _createReplicationGroup else ""
          _readerep = get(_ocds, "elasticache-replication-group-local.Resource.status.atProvider.readerEndpointAddress", "") if _createReplicationGroup else ""
          _port = 0
          if _globalEnabled:
              _port = get(_ocds, "elasticache-replication-group-global.Resource.status.atProvider.port", "")
          elif _createReplicationGroup:
              _port = get(_ocds, "elasticache-replication-group-local.Resource.status.atProvider.port", "")
          else:
              _port = get(_ocds, "elasticache-cluster-0.Resource.status.atProvider.port", "")


          _requiredClusters = len(get(_oxr, "spec.cacheClusters", [])) if get(_oxr, "spec.cacheClusters", False) else get(_oxr, "spec.numCacheClusters", 1)

          _clusterEndpoints = [
              get(_ocds, "elasticache-cluster-${i}.Resource.status.atProvider.clusterAddress", "")
              for i in range(_requiredClusters)
          ]
          _eps = [e for e in _clusterEndpoints if e]

          _globalReplicationId = get(_ocds, "elasticache-replication-group-global.Resource.status.atProvider.id", "")
          _localReplicationId = get(_ocds, "elasticache-replication-group-local.Resource.status.atProvider.id", "")

          _ipgn = get(_oxr, "spec.parameterGroupName", "")
          if get(_oxr, "spec.parameterGroupConfiguration", False):
              _ipgn = get(_oxr, "spec.parameterGroupConfiguration.name", "")

          items = [{
              **_oxr,
              **{
                  "status": {
                      if _eps:
                          clusterEndpoints = _eps,

                      if _endpoint:
                          endpoint: _endpoint,

                      if _globalEndpoint:
                          globalEndpoint: _globalEndpoint,

                      if _globalROEndpoint:
                          globalReaderEndpoint: _globalROEndpoint,

                      if _globalReplicationId:
                          globalReplicationGroupId: _globalReplicationId,

                      if _localReplicationId:
                          replicationGroupId: _localReplicationId,

                      if _ipgn:
                          parameterGroupName: _ipgn,

                      if _port:
                          port: _port,
                      if _readerep:
                          readerEndpoint: _readerep,
                  },
              }
          }]
        target: ""
    step: function-kcl-dynamic-patching
  - functionRef:
      name: function-auto-ready
    step: function-auto-ready
