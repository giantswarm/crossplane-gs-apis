apiVersion: apiextensions.crossplane.io/v1
kind: Composition
metadata:
  creationTimestamp: null
  labels:
    component: networking
    provider: aws
    type: vpc
  name: peered-vpc-network
spec:
  compositeTypeRef:
    apiVersion: xnetworks.crossplane.giantswarm.io/v1alpha1
    kind: PeeredVpcNetwork
  mode: Pipeline
  pipeline:
  - functionRef:
      name: function-network-discovery
    input:
      apiVersion: xnetworks.crossplane.giantswarm.io/v1beta1
      kind: Input
      metadata:
        creationTimestamp: null
      spec:
        enabledRef: spec.peering.enabled
        patchTo: status.vpcs
        providerConfigRef: spec.providerConfigRef.name
        regionRef: spec.region
        vpcRef: spec.peering.remoteVpcs
    step: network-discovery
  - functionRef:
      name: function-kcl
    input:
      apiVersion: krm.kcl.dev/v1alpha1
      kind: KCLInput
      metadata:
        creationTimestamp: null
      spec:
        config: {}
        credentials:
          password: ""
          username: ""
        source: |-
          _oxr = option("params").oxr
          _azl = len(_oxr.spec.subnetsets.availabilityZones)

          m = lambda x: str -> int {
              """
              Get the mask as an integer value
              """
              ip_mask = x.split("/")
              int(ip_mask[1]) if len(ip_mask) == 2 else int(ip_mask[0])
          }

          cb = lambda x: str, s: int, c: int -> [] {
              """
              Create 3 subnet bits for each subnet group requested

              :param x: The mask of the subnet
              :param s: The size of the subnet
              :param c: The number of subnets requested
              """
              [m(x) - s for _ in range(_azl) for _ in range(c) if c > 0 and x != ""]
          }

          {
              **_oxr
              status.subnetBits = [
                  {
                      _vpcSize = s.prefix.split("/")[1]
                      _public = s.public.count
                      _private = s.private.count
                      _x = int(_vpcSize)

                      prefix = s.prefix
                      offset = s.offset
                      newBits = cb(s.public.mask, _x, s.public.count) + cb(s.private.mask, _x, s.private.count)
                  }
                  for s in _oxr.spec.subnetsets.cidrs
              ]
          }
        target: ""
    step: function-kcl-subnet-bits
  - functionRef:
      name: function-cidr
    input:
      apiVersion: cidr.fn.crossplane.io/v1beta1
      cidrFunc: multiprefixloop
      kind: Parameters
      metadata:
        creationTimestamp: null
      multiPrefixField: status.subnetBits
      outputField: status.calculatedCidrs
    step: function-cidr
  - functionRef:
      name: function-kcl
    input:
      apiVersion: krm.kcl.dev/v1alpha1
      kind: KCLInput
      metadata:
        creationTimestamp: null
      spec:
        config: {}
        credentials:
          password: ""
          username: ""
        source: |-
          import regex
          _oxr = option("params").oxr
          _dxr = option("params").dxr
          _ocs = option("params").ocds

          _requestedSets = [
              c.public.count + c.private.count
              for c in _oxr.spec.subnetsets.cidrs
          ]

          _zones = _oxr.spec.subnetsets.availabilityZones

          assert sum(_requestedSets)*len(_zones) < 200, """
              The number of subnet sets you are requesting will exceed the maximum number
              of subnets allowed by AWS. The sum of all counts multiplied by the number of
              availability zones must be less than 200.
          """

          # The first entry in the `subnetsets.cidrs` list is the primary CIDR range for
          # the VPC.
          #
          # The remaining entries are additional CIDR ranges that can be attached with AWS
          # allowing up to 4 additional CIDR ranges.
          _additionalCidrs = [
              s.prefix
              for s in _oxr.spec.subnetsets.cidrs[1:]
          ]

          # The name of the application is used to prefix all resources
          _appName = _claimRef.name if bool(_claimRef) else ""
          _calculatedCidrs = _oxr.status.calculatedCidrs if _oxr.status and _oxr.status.calculatedCidrs else {}
          _claimRef = _oxr.spec.claimRef
          _clusterTags = _oxr.spec.tags.cluster if _oxr.spec.tags.cluster else {}
          _dp = _oxr.spec.deletionPolicy
          _labels = _oxr.metadata.labels
          _pcr = _oxr.spec.providerConfigRef
          _region = _oxr.spec.region

          _peeringEnabled = _oxr.spec.peering.enabled
          _tags = _labels | _oxr.spec.tags.common | {
              region: _region,
          }

          # Created checks
          _vpcs = _oxr.status.vpcs if _oxr.status and _oxr.status.vpcs else {}
          _self = _vpcs.self if _vpcs else {}

          _peeringConnections = [
              p.Resource for _, p in _ocs if _ocs and p.Resource.kind == "VPCPeeringConnection"
          ]
          _peeringCreated = len(_peeringConnections) == len(_peering)

          _ngw = [
              ngw.Resource for _, ngw in _ocs if _ocs and ngw.Resource.kind == "NATGateway"
          ]
          _natgatewaysCreated = len([ngw for ngw in _ngw if ngw]) == len(_zones)

          # Separate out created public and private subnets and route tables
          _pubsn = [
              x.Resource.status.subnets
              for _, x in _ocs
              if x.Resource.kind == "SubnetSet" and x.Resource.spec.type == "public" and _ocs
          ]
          _pubrtbls = [
              x.Resource.status.routeTables
              for _, x in _ocs
              if x.Resource.kind == "SubnetSet" and x.Resource.spec.type == "public" and _ocs
          ]
          _prisn = [
              x.Resource.status.subnets
              for _, x in _ocs
              if x.Resource.kind == "SubnetSet" and x.Resource.spec.type == "private" and _ocs
          ]
          _prirtbls = [
              x.Resource.status.routeTables
              for _, x in _ocs
              if x.Resource.kind == "SubnetSet" and x.Resource.spec.type == "private" and _ocs
          ]

          chunksplit = lambda size: int subnets: [] -> [] {
              # split the subnets array into chunks of size `size`
              [] if not subnets or subnets == Undefined else [
                  subnets[i:i + size:]
                  for i in range(0, len(subnets), size)
              ]
          }

          # Create the SubnetSets
          #
          # SubnetSets are a collection of Subnets and RouteTables per availability zone
          # Each set logically belongs together as they share consecutive CIDR ranges
          # and have one subnet and one route table per requested availability zone (3)
          _subnetsets = [
              {
                  _subnets = chunksplit(len(_zones), _calculatedCidrs[s.prefix])
                  _visibility = "public" if i < s.public.count else "private"
                  _index = i if _visibility == "public" else i - s.public.count

                  # this is needed for tagging the subnet sets independently of each other
                  # it creates a '-' (hyphen) separated copy of the IP address from the first
                  # subnet + the last octet from the last subnet, e.g. 192-168-0-0-255
                  _suffix = regex.split(regex.replace(_subnets[i][0], "\.", "-"), "/")[0] + "-" + regex.split(regex.split(_subnets[i][len(_zones)-1], "\.")[3], "/")[0]
                  _snlbtag = {Name: "${_appName}-${_visibility}-subnet-${_index}"} | {
                      **_clusterTags
                      "kubernetes.io/role/elb": "1"
                  } if _index == s.public.lbSetIndex and _visibility == "public" else {
                      **_clusterTags
                      "kubernetes.io/role/internal-elb": "1"
                  } if _index == s.private.lbSetIndex and _visibility == "private" else {}
                  apiVersion: "xnetworks.crossplane.giantswarm.io/v1alpha1"
                  kind: "SubnetSet"
                  metadata: {
                      annotations: {
                          "krm.kcl.dev/composition-resource-name" = "subnnetset-${_suffix}-${_visibility}-${_index}"
                      }
                      labels: _labels
                  }
                  spec: {
                      appIndex: _suffix
                      claimRef: _claimRef
                      deletionPolicy: _dp
                      region: _region
                      providerConfigRef: _pcr
                      subnets: {
                          a: {
                              cidrBlock: _subnets[i][0]
                              zone: _zones[0]
                          }
                          b: {
                              cidrBlock: _subnets[i][1]
                              zone: _zones[1]
                          }
                          c: {
                              cidrBlock: _subnets[i][2]
                              zone: _zones[2]
                          }
                      }
                      type: _visibility
                      tags: {
                          "all": _tags | _oxr.spec.tags.subnet
                          "subnet": _snlbtag
                      }
                      vpcId: _self.id
                  }
              }
              for s in _oxr.spec.subnetsets.cidrs
              for i in range(s.public.count + s.private.count)
              if _calculatedCidrs and _self and _self.id
          ]

          # Create Additional VPC CIDRs
          #
          # Each VPC may have up to 4 additional CIDRs attached
          _acs = [
              {
                  apiVersion: "ec2.aws.upbound.io/v1beta1"
                  kind: "VPCIPv4CidrBlockAssociation"
                  metadata: {
                      labels: _labels
                      annotations: {
                          "krm.kcl.dev/composition-resource-name" = "cidrassoc-${i}"
                      }
                  }
                  spec: {
                      deletionPolicy: _dp
                      forProvider: {
                          cidrBlock: cidr
                          region: _region
                          vpcIdSelector: {
                              matchControllerRef: True
                          }
                      }
                      _providerConfigRef: _pcr
                  }
              }
              for i, cidr in _additionalCidrs
          ]

          # Create Elastic IPs for the nat gateways
          #
          # Each NAT Gateway must be associated with an EIP
          _eips = [
              {
                  apiVersion: "ec2.aws.upbound.io/v1beta1"
                  kind: "EIP"
                  metadata: {
                      annotations: {
                          "krm.kcl.dev/composition-resource-name" = "eip-${i}"
                      }
                      labels: _labels | {
                          availabilityZone: az
                          utilization: "nat-gateway"
                      }
                  }
                  spec: {
                      deletionPolicy: _dp
                      forProvider: {
                          domain: "vpc"
                          region: _region
                          tags: _tags | {Name: "${_appName}-${_region}${az}-${i}"}
                      }
                      _providerConfigRef: _pcr
                  }
              }
              for i, az in _zones if _pubsn
          ]

          # NAT Gateways
          #
          # One NatGateway per availability zone is created and attached
          # to the first available public subnet set
          #_keys = [k for k in _pubsn[0]] if _pubsn and len(_pubsn) > 0 and len(_pubsn[0]) == len(_zones) else []
          _keys = ['a', 'b', 'c']
          _natgateways = [
              {
                  apiVersion: "ec2.aws.upbound.io/v1beta1"
                  kind: "NATGateway"
                  metadata: {
                      annotations: {
                          "krm.kcl.dev/composition-resource-name" = "ngw-${i}"
                      }
                      labels: {availabilityZone: az} | _labels
                  }
                  spec: {
                      deletionPolicy: _dp
                      forProvider: {
                          allocationIdSelector: {
                              matchControllerRef: True
                              matchLabels: {availabilityZone: az}
                          }
                          region: _region
                          subnetId: _pubsn[0][_keys[i]]
                          tags: {Name: "${_appName}-${_region}${az}"} | _tags
                      }
                      _providerConfigRef: _pcr
                  }
              }
              for i, az in _zones
              if _pubsn and _eips
          ]

          # Nat Gateway Routes
          #
          # One route per private route table
          _ngwRoutes = [
              {
                  apiVersion: "ec2.aws.upbound.io/v1beta1"
                  kind: "Route"
                  metadata: {
                      annotations: {
                          "krm.kcl.dev/composition-resource-name" = "ngw-rt-${i}"
                      }
                      labels: {availabilityZone: az} | _labels
                  }
                  spec: {
                      deletionPolicy: _dp
                      forProvider: {
                          destinationCidrBlock: "0.0.0.0/0"
                          natGatewayIdSelector: {
                              matchControllerRef: True
                              matchLabels: {availabilityZone: az}
                          }
                          region: _region
                          routeTableId: rtbl
                      }
                      providerConfigRef: _pcr
                  }
              }
              for i, x in _prirtbls
              for az, rtbl in x
              if _pubsn and _natgatewaysCreated
          ]

          # Internet Gateway Routes
          #
          # One IGW route per public route table
          _igwRoutes = [
              {
                  apiVersion: "ec2.aws.upbound.io/v1beta1"
                  kind: "Route"
                  metadata: {
                      annotations: {
                          "krm.kcl.dev/composition-resource-name" = "igw-rt-${i}"
                      }
                      labels: {availabilityZone: az} | _labels
                  }
                  spec: {
                      deletionPolicy: _dp
                      forProvider: {
                          destinationCidrBlock: "0.0.0.0/0"
                          gatewayIdSelector: {
                              matchControllerRef: True
                          }
                          region: _region
                          routeTableId: rtbl
                      }
                      providerConfigRef: _pcr
                  }
              }
              for i, x in _pubrtbls
              for az, rtbl in x if _pubsn
          ]

          # Create Peering connections
          #
          # One peering connection per remote VPC is created
          _peering = [
              {
                  apiVersion: "ec2.aws.upbound.io/v1beta1"
                  kind: "VPCPeeringConnection"
                  metadata: {
                      annotations: {
                          "krm.kcl.dev/composition-resource-name" = "peering-${x.name}"
                      }
                      labels: _labels | {vpcName: x.name}
                  }
                  spec: {
                      deletionPolicy: _dp
                      forProvider: {
                          autoAccept: True
                          peerVpcId: _vpcs[x.name].id
                          region: _region
                          tags: {Name: "${_appName}-${_region}-${x.name}"} | _tags
                          vpcId: _self.id
                      }
                      providerConfigRef: _pcr
                  }
              }
              for x in _oxr.spec.peering.remoteVpcs
              if _vpcs and _self and _vpcs[x.name] and _oxr.spec.peering.enabled and _self.id
          ]

          # This is the most complicated part of the setup, adding the peering connections
          # to the route tables
          #
          # The following blocks of code map route tables to CIDR ranges on either side of
          # the VPC peering connection.
          #
          # Remote VPC route tables take the CIDR range(s) of the VPC created by this
          # composition whilst route tables created by this composition take the remote
          # CIDR range(s)
          #
          # It is possible to disable peering on public route tables but not private route
          # tables in this composition. The options available are: public+private or
          # private only

          allowsPublic = lambda vpc: str -> bool {
              _a = [
                  x.allowPublic for x in _oxr.spec.peering.remoteVpcs if x.name == vpc
              ][0]
          }

          # First lets build a mapping from our own CIDR blocks to every route table that
          # is not ours
          _rmtTables = [] if not _vpcs else [ # public route tables if requested
              {id = i, vpcCidr = cidr, selector = name}
              for name, vpc in _vpcs
              for cidr in [vpc.cidrBlock] + vpc.additionalCidrBlocks
              for _, index in vpc.publicRouteTables or []
              for _, i in index
              if vpc and "publicRouteTables" in vpc and name != "self" and allowsPublic(name)
          ] + [ # private route tables
              {
                  id = i,
                  vpcCidr = vpc.cidrBlock,
                  selector = name
              }
              for name, vpc in _vpcs
              for cidr in [vpc.cidrBlock] + vpc.additionalCidrBlocks
              for _, index in vpc.privateRouteTables or []
              for _, i in index
              if vpc and "privateRouteTables" in vpc and name != "self"
          ]

          # Then map all remote CIDRs to our own route tables
          #
          # This is slightly different to the above as the `allowPublic` flag doesn't
          # need to be discovered for the current VPC (static location)
          _additionalCidrBlocks = _self.additionalCidrBlocks if _self and "additionalCidrBlocks" in _self else []
          _myRouteTables = [
              {
                  id = i,
                  vpcCidr = cidr,
                  selector = name
              }
              for cidr in [_self.cidrBlock] + _additionalCidrBlocks
              for _, index in [
                  r for r in _pubrtbls
                  if _oxr.spec.peering.allowPublic and _pubrtbls
              ] + [
                  r for r in _prirtbls
                  if _prirtbls
              ]
              for _, i in index
              for name, vpc in _vpcs
              if _vpcs and _self and name != "self"
          ]

          # Create the Peering routes
          #
          # This is achieved by combining the two lists _rmtTables and _myRouteTables
          # and then creating a route for each, with the peering ID selector set to the
          # name of the peering connection for that VPC
          _peeringRoutes = [
              {
                  apiVersion: "ec2.aws.upbound.io/v1beta1"
                  kind: "Route"
                  metadata: {
                      annotations: {
                          "krm.kcl.dev/composition-resource-name" = "peering-rt-${i}"
                      }
                      labels: _labels
                  }
                  spec: {
                      deletionPolicy: _dp
                      forProvider: {
                          destinationCidrBlock: r.vpcCidr
                          routeTableId: r.id
                          region: _region
                          vpcPeeringConnectionIdSelector: {
                              matchControllerRef: True
                              matchLabels: {
                                  vpcName: r.selector
                              }
                          }
                      }
                      providerConfigRef: _pcr
                  }
              }
              for i, r in _rmtTables + _myRouteTables
              # only create if peering is enabled and we have a VPC ID and peering
              # connections have been created
              if _self and _self.id and _oxr.spec.peering.enabled and _peeringCreated
          ]

          # Create the list of items to return
          _items = [
              _subnetsets, _acs, _eips, _natgateways,
              _ngwRoutes, _igwRoutes, _peering, _peeringRoutes
          ]
          # flatten items and exclude any empty elements
          items = [i for x in _items for i in x if i]
        target: ""
    step: function-kcl-create-resources
  - functionRef:
      name: function-kcl
    input:
      apiVersion: krm.kcl.dev/v1alpha1
      kind: KCLInput
      metadata:
        creationTimestamp: null
      spec:
        config: {}
        credentials:
          password: ""
          username: ""
        source: |-
          _oxr = option("params").oxr
          _ocs = option("params").ocds

          {
              **_oxr
              **{
                  "status": {
                      vpcs: {
                          self: {
                              cidrBlock: _oxr.spec.subnetsets.cidrs[0].prefix
                              additionalCidrBlocks = [
                                  s.prefix
                                  for s in _oxr.spec.subnetsets.cidrs[1:]
                              ]
                              publicRouteTables = []
                              publicSubnets = []
                              privateRouteTables = []
                              privateSubnets = []

                          }
                      }
                  }
              }
              **{
                  "status": {
                      vpcs: {
                          self: {
                              privateRouteTables +=  [
                                  {
                                      _i = item.Resource.status.routeTables
                                      "${_i.aName}": "${_i.a}"
                                      "${_i.bName}": "${_i.b}"
                                      "${_i.cName}": "${_i.c}"
                                  }
                              ]
                              privateSubnets += [
                                  {
                                      _i = item.Resource.status.subnets
                                      "${_i.aName}": "${_i.a}"
                                      "${_i.bName}": "${_i.b}"
                                      "${_i.cName}": "${_i.c}"
                                  }
                              ]
                          }
                      }
                  }
                  for _, item in _ocs
                  if _ocs and item.Resource.kind == "SubnetSet" and item.Resource.spec.type == "private"
              }
              **{
                  "status": {
                      vpcs: {
                          self: {
                              publicRouteTables +=  [
                                  {
                                      _i = item.Resource.status.routeTables
                                      "${_i.aName}": "${_i.a}"
                                      "${_i.bName}": "${_i.b}"
                                      "${_i.cName}": "${_i.c}"
                                  }
                              ]
                              publicSubnets += [
                                  {
                                      _i = item.Resource.status.subnets
                                      "${_i.aName}": "${_i.a}"
                                      "${_i.bName}": "${_i.b}"
                                      "${_i.cName}": "${_i.c}"
                                  }
                              ]
                          }
                      }
                  }
                  for _, item in _ocs
                  if _ocs and item.Resource.kind == "SubnetSet" and item.Resource.spec.type == "private"
              }

              **{
                  "status":{
                      vpcs: {
                          self: {
                              natGateways = {
                                  name: item.Resource.status.atProvider.id
                              }
                          }
                      }
                  }
              for name, item in _ocs if _ocs and item.Resource.kind == "NATGateway"
              }
          }
        target: ""
    step: function-kcl-patch-xr
  - functionRef:
      name: function-patch-and-transform
    input:
      apiVersion: pt.crossplane.io/v1beta1
      kind: Resources
      metadata:
        creationTimestamp: null
      patchSets:
      - name: metadata
        patches:
        - fromFieldPath: metadata.labels
          policy:
            toFieldPath: MergeObjects
          toFieldPath: metadata.labels
          type: FromCompositeFieldPath
        - fromFieldPath: spec.region
          toFieldPath: metadata.labels.region
          type: FromCompositeFieldPath
        - fromFieldPath: spec.providerConfigRef
          toFieldPath: spec.providerConfigRef
          type: FromCompositeFieldPath
        - fromFieldPath: spec.deletionPolicy
          toFieldPath: spec.deletionPolicy
          type: FromCompositeFieldPath
      - name: commontags
        patches:
        - fromFieldPath: spec.tags.common
          policy:
            toFieldPath: MergeObjects
          toFieldPath: spec.forProvider.tags
          type: FromCompositeFieldPath
        - fromFieldPath: metadata.labels
          policy:
            toFieldPath: MergeObjects
          toFieldPath: spec.forProvider.tags
          type: FromCompositeFieldPath
        - fromFieldPath: spec.region
          toFieldPath: spec.forProvider.tags.region
          type: FromCompositeFieldPath
      resources:
      - base:
          apiVersion: ec2.aws.upbound.io/v1beta1
          kind: VPC
          metadata:
            creationTimestamp: null
          spec:
            forProvider:
              enableDnsHostnames: true
              enableDnsSupport: true
              region: null
            initProvider: {}
          status:
            atProvider: {}
        name: vpc
        patches:
        - fromFieldPath: spec.region
          toFieldPath: spec.forProvider.region
          type: FromCompositeFieldPath
        - fromFieldPath: spec.subnetsets.cidrs[0].prefix
          toFieldPath: spec.forProvider.cidrBlock
          type: FromCompositeFieldPath
        - patchSetName: commontags
          type: PatchSet
        - fromFieldPath: spec.claimRef.name
          toFieldPath: spec.forProvider.tags.Name
          type: FromCompositeFieldPath
        - patchSetName: metadata
          type: PatchSet
        - combine:
            strategy: string
            string:
              fmt: '%s-%s'
            variables:
            - fromFieldPath: spec.claimRef.name
            - fromFieldPath: spec.region
          toFieldPath: metadata.name
          type: CombineFromComposite
        - fromFieldPath: status.atProvider.id
          toFieldPath: status.vpcs.self.id
          type: ToCompositeFieldPath
      - base:
          apiVersion: ec2.aws.upbound.io/v1beta1
          kind: DefaultSecurityGroup
          metadata:
            creationTimestamp: null
          spec:
            forProvider:
              region: null
              vpcIdSelector:
                matchControllerRef: true
            initProvider: {}
          status:
            atProvider: {}
        name: default-sg-control
        patches:
        - fromFieldPath: spec.region
          toFieldPath: spec.forProvider.region
          type: FromCompositeFieldPath
        - patchSetName: commontags
          type: PatchSet
        - patchSetName: metadata
          type: PatchSet
        - combine:
            strategy: string
            string:
              fmt: '%s-%s'
            variables:
            - fromFieldPath: spec.claimRef.name
            - fromFieldPath: spec.region
          toFieldPath: metadata.name
          type: CombineFromComposite
      - base:
          apiVersion: ec2.aws.upbound.io/v1beta1
          kind: InternetGateway
          metadata:
            creationTimestamp: null
          spec:
            forProvider:
              region: null
              vpcIdSelector:
                matchControllerRef: true
            initProvider: {}
          status:
            atProvider: {}
        name: internet-gateway
        patches:
        - fromFieldPath: spec.region
          toFieldPath: spec.forProvider.region
          type: FromCompositeFieldPath
        - patchSetName: commontags
          type: PatchSet
        - patchSetName: metadata
          type: PatchSet
        - combine:
            strategy: string
            string:
              fmt: '%s-%s-igw'
            variables:
            - fromFieldPath: spec.claimRef.name
            - fromFieldPath: spec.region
          toFieldPath: spec.forProvider.tags.Name
          type: CombineFromComposite
        - combine:
            strategy: string
            string:
              fmt: '%s-%s'
            variables:
            - fromFieldPath: spec.claimRef.name
            - fromFieldPath: spec.region
          toFieldPath: metadata.name
          type: CombineFromComposite
        - fromFieldPath: status.atProvider.id
          toFieldPath: status.vpcs.self.internetGateway
          type: ToCompositeFieldPath
    step: patch-and-transform
  - functionRef:
      name: function-auto-ready
    step: function-auto-ready
