apiVersion: apiextensions.crossplane.io/v1
kind: Composition
metadata:
  creationTimestamp: null
  labels:
    component: networking
    provider: aws
    type: vpc
  name: peered-vpc-network
spec:
  compositeTypeRef:
    apiVersion: xnetworks.crossplane.giantswarm.io/v1alpha1
    kind: PeeredVpcNetwork
  mode: Pipeline
  pipeline:
  - functionRef:
      name: function-network-discovery
    input:
      apiVersion: xnetworks.crossplane.giantswarm.io/v1beta1
      kind: Input
      metadata:
        creationTimestamp: null
      spec:
        enabledRef: status.vpcLookup.enabled
        groupByRef: status.vpcLookup.groupBy
        patchTo: status.vpcs
        providerConfigRef: spec.providerConfigRef.name
        providerType: aws
        regionRef: spec.region
        vpcRef: status.vpcLookup.remoteVpcs
    step: network-discovery
  - functionRef:
      name: function-cidr
    input:
      apiVersion: cidr.fn.crossplane.io/v1beta1
      cidrFunc: multiprefixloop
      kind: Parameters
      metadata:
        creationTimestamp: null
      multiPrefixField: status.subnetBits
      outputField: status.calculatedCidrs
    step: function-cidr
  - functionRef:
      name: function-kcl
    input:
      apiVersion: krm.kcl.dev/v1alpha1
      kind: KCLInput
      metadata:
        creationTimestamp: null
      spec:
        source: |-
          import regex
          _oxr = option("params").oxr
          _dxr = option("params").dxr
          _ocs = option("params").ocds

          get = lambda x: {:}, y: str, d: any -> any {
              """
              Get an item from a dictionary using a dot separated path.
              If the item is not found, return a default value.
              """
              p = regex.split(y, "\.")
              c = p[0]
              y = ".".join(p[1:])
              x[c] if len(p) == 1 and c in x else d if c not in x else get(x[c], y, d)
          }

          ready = lambda x: any, y: str -> str {
              """
              Check if a value is ready.
              """
              conditions = get(x, "${y}.Resource.status.conditions", [])
              "True" if all_true([
                  get(c, "status", "False") == "True" for c in conditions
              ]) else "False"
          }

          appName = get(_oxr, "spec.claimRef.name", "")
          claimRef = get(_oxr, "spec.claimRef", {})
          dp = get(_oxr, "spec.deletionPolicy", "Delete")
          labels = get(_oxr, "metadata.labels", {})
          peeringEnabled = get(_oxr, "spec.peering.enabled", False)
          pcr = get(_oxr, "spec.providerConfigRef", {"name": "default"})
          region = get(_oxr, "spec.region", "eu-central-1")
          tags = labels | get(_oxr, "spec.tags.common", {}) | {
              "region": region,
          }

          chunksplit = lambda size: int subnets: [] -> [] {
              # split the subnets array into chunks of size `size`
              [] if not subnets or subnets == Undefined else [
                  subnets[i:i + size:]
                  for i in range(0, len(subnets), size)
              ]
          }

          allowsPublic = lambda vpc: str -> bool {
              a = [
                  get(x, "allowPublic", False)
                  for x in get(_oxr, "spec.peering.remoteVpcs", [])
                  if x.name == vpc
              ]

              a[0] if len(a) == 1 else False
          }

          # Collect the number of requested subnet sets - you can have up to 200 subnets
          # in a VPC - this total must be below that
          requestedSets = [
              c.public.count + c.private.count
              for c in get(_oxr, "spec.subnetsets.cidrs", [])
          ]

          zones = sorted(get(_oxr, "spec.availabilityZones", [ "a", "b", "c" ]))

          assert sum(requestedSets)*len(zones) < 200, """
              The number of subnet sets you are requesting will exceed the maximum number
              of subnets allowed by AWS. The sum of all counts multiplied by the number of
              availability zones must be less than 200.
          """

          # The first entry in the `subnetsets.cidrs` list is the primary CIDR range for
          # the VPC.
          #
          # The remaining entries are additional CIDR ranges that can be attached with AWS
          # allowing up to 4 additional CIDR ranges.
          additionalCidrs = [
              s.prefix
              for s in _oxr.spec.subnetsets.cidrs[1:]
          ]

          calculatedCidrs = get(_oxr, "status.calculatedCidrs", {})
          clusterTags = get(_oxr, "spec.tags.cluster", {})

          # Created checks
          vpcs = get(_oxr, "status.vpcs", {})
          self = get(vpcs, "self", {})

          _ngw = [
              ngw.Resource for _, ngw in _ocs if _ocs and get(ngw, "Resource.kind", "") == "NATGateway"
          ]
          natgatewaysCreated = len([ngw for ngw in _ngw if ngw]) == len(zones)

          # Separate out created public and private subnets
          pubsn = [
              x
              for _, x in get(self, "publicSubnets", [])
              if self and get(self, "publicSubnets", False)
          ]

          prisn = [
              x
              for _, x in get(self, "privateSubnets", [])
              if self and get(self, "privateSubnets", False)
          ]

          # Create the SubnetSets
          #
          # SubnetSets are a collection of Subnets and RouteTables per availability zone
          # Each set logically belongs together as they share consecutive CIDR ranges
          # and have one subnet and one route table per requested availability zone (3)
          _subnetsets = [
              {
                  _subnets = chunksplit(len(zones), calculatedCidrs[s.prefix])
                  _visibility = "public" if i < get(s, "public.count", 0) else "private"
                  _index = i if _visibility == "public" else i - s.public.count

                  # this is needed for tagging the subnet sets independently of each other
                  # it creates a '-' (hyphen) separated copy of the IP address from the first
                  # subnet + the last 2 octets from the last subnet, e.g. 192-168-0-0-2-0
                  _s1 = regex.split(_subnets[i][0], "/")[0]
                  _s1hyphened = regex.replace(_s1, "\.", "-")

                  _s2 = regex.split(_subnets[i][len(zones)-1], "/")[0]
                  _s2octs = regex.split(_s2, "\.")
                  _suffix = _s1hyphened + "-" + _s2octs[2] + "-" + _s2octs[3]
                  _snlbtag = {
                      **clusterTags
                      "kubernetes.io/role/elb": "1"
                  } if _index == s.public.lbSetIndex and _visibility == "public" else {
                      **clusterTags
                      "kubernetes.io/role/internal-elb": "1"
                  } if _index == s.private.lbSetIndex and _visibility == "private" else {}

                  "apiVersion": "xnetworks.crossplane.giantswarm.io/v1alpha1"
                  "kind": "SubnetSet"
                  "metadata": {
                      "annotations": {
                          "krm.kcl.dev/composition-resource-name" = "subnetset-${_visibility}-cidr${c}-${_index}"
                          "krm.kcl.dev/ready" = ready(_ocs, "subnetset-${_visibility}-cidr${c}-${_index}")
                      }
                      "labels": labels | {access: _visibility, index: _index}
                  }
                  "spec": {
                      "appIndex": _suffix
                      "claimRef": claimRef
                      "deletionPolicy": dp
                      "region": region
                      "providerConfigRef": pcr
                      "subnets": {
                          zones[j]: _subnets[i][j]
                          for j in range(len(zones))
                      }
                      "type": _visibility
                      "tags": {
                          "all": tags | get(_oxr, "spec.tags.subnet", {})
                          "subnet": _snlbtag
                      }
                      "vpcId": self.id
                  }
              }
              for c, s in get(_oxr, "spec.subnetsets.cidrs", [])
              for i in range(get(s, "public.count", 0) + get(s, "private.count", 0))
              if all_true([
                  calculatedCidrs, self,
                  self.id,
                  get(_oxr, "spec.subnetsets.cidrs", False)
              ])
          ]

          # Set the subnetset tag and labels
          # This needs to be set for later separation of public and private subnets
          # into their respective groups but cannot be done as part of the creation due
          # to language limitations.

          _pubss = [s for s in _subnetsets if get(s, "spec.type", "") == "public"]
          _fpubss = [
              {
                  **s
                  **{
                      "metadata": {
                          labels: {
                              subnetset: "${i}"
                          }
                      }
                      "spec": {
                          tags: {
                              "all": {"giantswarm.io/subnetset": "${i}"}
                          }
                      }
                  }
              }
              for i, s in _pubss
          ]

          _priss = [s for s in _subnetsets if get(s, "spec.type", "") == "private"]
          _fpriss = [
              {
                  **s
                  **{
                      "metadata": {
                          labels: {
                              subnetset: "${i}"
                          }
                      }
                      "spec": {
                          tags: {
                              "all": {"giantswarm.io/subnetset": "${i}"}
                          }
                      }
                  }
              }
              for i, s in _priss
          ]
          subnetsets = _fpubss + _fpriss

          # Create Additional VPC CIDRs
          #
          # Each VPC may have up to 4 additional CIDRs attached
          acs = [
              {
                  "apiVersion": "ec2.aws.upbound.io/v1beta1"
                  "kind": "VPCIPv4CidrBlockAssociation"
                  "metadata": {
                      "labels": labels
                      "annotations": {
                          "krm.kcl.dev/composition-resource-name" = "cidrassoc-${i}"
                          "krm.kcl.dev/ready" = ready(_ocs, "cidrassoc-${i}")
                      }
                  }
                  spec: {
                      "deletionPolicy": dp
                      "forProvider": {
                          "cidrBlock": cidr
                          "region": region
                          "vpcIdSelector": {
                              "matchControllerRef": True
                          }
                      }
                      "providerConfigRef": pcr
                  }
              }
              for i, cidr in additionalCidrs
          ]

          # Create Elastic IPs for the nat gateways
          #
          # Each NAT Gateway must be associated with an EIP
          eips = [
              {
                  "apiVersion": "ec2.aws.upbound.io/v1beta1"
                  "kind": "EIP"
                  "metadata": {
                      "annotations": {
                          "krm.kcl.dev/composition-resource-name" = "eip-${i}"
                          "krm.kcl.dev/ready" = ready(_ocs, "eip-${i}")
                      }
                      "labels": labels | {
                          "availabilityZone": az
                          "utilization": "nat-gateway"
                      }
                  }
                  "spec": {
                      "deletionPolicy": dp
                      "forProvider": {
                          "domain": "vpc"
                          "region": region
                          "tags": tags | {"Name": "${appName}-${region}${az}-${i}"}
                      }
                      "providerConfigRef": pcr
                  }
              }
              for i, az in zones if pubsn
          ]

          # NAT Gateways
          #
          # One NatGateway per availability zone is created and attached
          # to the first available public subnet set
          keys = [k for k in pubsn[0]] if pubsn and len(pubsn) > 0 and len(pubsn[0]) == len(zones) else []
          natgateways = [
              {
                  "apiVersion": "ec2.aws.upbound.io/v1beta1"
                  "kind": "NATGateway"
                  "metadata": {
                      "annotations": {
                          "krm.kcl.dev/composition-resource-name" = "ngw-${i}"
                          "krm.kcl.dev/ready" = ready(_ocs, "ngw-${i}")
                      }
                      "labels": {
                          "availabilityZone": az
                      } | labels
                  }
                  "spec": {
                      "deletionPolicy": dp
                      "forProvider": {
                          "allocationIdSelector": {
                              "matchControllerRef": True
                              "matchLabels": {availabilityZone: az}
                          }
                          "region": region
                          "subnetId": pubsn[0][keys[i]].id
                          "tags": labels | {
                              "Name": "${appName}-${region}${az}"
                          } | tags
                      }
                      "providerConfigRef": pcr
                  }
              }
              for i, az in zones
              if all_true([
                  pubsn,
                  len(keys) > 0,
                  len(pubsn) > 0,
                  eips
              ])
          ]

          _prirtbls = [
              x
              for _, x in get(self, "privateRouteTables", [])
              if self and get(self, "privateRouteTables", False)
          ]

          _pubrtbls = [
              x
              for _, x in get(self, "publicRouteTables", [])
              if self and get(self, "publicRouteTables", False)
          ]

          # Nat Gateway Routes
          #
          # One route per private route table
          ngwRoutes = [
              {
                  "apiVersion": "ec2.aws.upbound.io/v1beta1"
                  "kind": "Route"
                  "metadata": {
                      "annotations": {
                          "krm.kcl.dev/composition-resource-name" = "ngw-rt-${rtbl[1].id}"
                          "krm.kcl.dev/ready" = ready(_ocs, "ngw-rt-${rtbl[1].id}")
                      }
                      "labels": {
                          "availabilityZone": rtbl[0]
                          "routeType": "ngw"
                      }
                  }
                  "spec": {
                      "deletionPolicy": dp
                      "forProvider": {
                          "destinationCidrBlock": "0.0.0.0/0"
                          "natGatewayIdSelector": {
                              "matchControllerRef": True
                              "matchLabels": {availabilityZone: rtbl[0]}
                          }
                          "region": region
                          "routeTableId": rtbl[1].id
                      }
                      "providerConfigRef": pcr
                  }
              }
              for i, x in _prirtbls
              for _, rtbl in zip(zones, [r for _, r in x])
              if pubsn and natgatewaysCreated
          ]

          # Internet Gateway Routes
          #
          # One IGW route per public route table
          igwRoutes = [
              {
                  "apiVersion": "ec2.aws.upbound.io/v1beta1"
                  "kind": "Route"
                  "metadata": {
                      "annotations": {
                          "krm.kcl.dev/composition-resource-name" = "igw-rt-${rtbl[1].id}"
                          "krm.kcl.dev/ready" = ready(_ocs, "igw-rt-${rtbl[1].id}")
                      }
                      "labels": {
                          "availabilityZone": rtbl[0]
                          "routeType": "igw"
                      }
                  }
                  "spec": {
                      "deletionPolicy": dp
                      "forProvider": {
                          "destinationCidrBlock": "0.0.0.0/0"
                          "gatewayIdSelector": {
                              "matchControllerRef": True
                          }
                          "region": region
                          "routeTableId": rtbl[1].id
                      }
                      "providerConfigRef": pcr
                  }
              }
              for i, x in _pubrtbls
              for _, rtbl in zip(zones, [r for _, r in x])
          ]

          # Create the list of items to return
          _items = [
              i for x in [
                  subnetsets, acs, eips, natgateways,
                  ngwRoutes, igwRoutes
              ]
              for i in x if i
          ]

          items = _items
        target: ""
    step: function-kcl-create-resources
  - functionRef:
      name: function-kcl
    input:
      apiVersion: krm.kcl.dev/v1alpha1
      kind: KCLInput
      metadata:
        creationTimestamp: null
      spec:
        source: |-
          import regex
          _oxr = option("params").oxr
          _dxr = option("params").dxr
          _ocs = option("params").ocds

          get = lambda x: {:}, y: str, d: any -> any {
              """
              Get an item from a dictionary using a dot separated path.
              If the item is not found, return a default value.
              """
              p = regex.split(y, "\.")
              c = p[0]
              y = ".".join(p[1:])
              x[c] if len(p) == 1 and c in x else d if c not in x else get(x[c], y, d)
          }

          ready = lambda x: any, y: str -> str {
              """
              Check if a value is ready.
              """
              conditions = get(x, "${y}.Resource.status.conditions", [])
              "True" if all_true([
                  get(c, "status", "False") == "True" for c in conditions
              ]) else "False"
          }

          appName = get(_oxr, "spec.claimRef.name", "")
          claimRef = get(_oxr, "spec.claimRef", {})
          dp = get(_oxr, "spec.deletionPolicy", "Delete")
          labels = get(_oxr, "metadata.labels", {})
          peeringEnabled = get(_oxr, "spec.peering.enabled", False)
          pcr = get(_oxr, "spec.providerConfigRef", {"name": "default"})
          region = get(_oxr, "spec.region", "eu-central-1")
          tags = labels | get(_oxr, "spec.tags.common", {}) | {
              "region": region,
          }

          peering = [
              {
                  "apiVersion": "xnetworks.crossplane.giantswarm.io/v1alpha1"
                  "kind": "Peering"
                  "metadata": {
                      "annotations": {
                          "krm.kcl.dev/composition-resource-name" = "peering-${remoteVpc.name}"
                          "krm.kcl.dev/ready" = ready(_ocs, "peering-${remoteVpc.name}")
                      }
                      "labels": labels | {
                          "vpcName": remoteVpc.name
                      }
                  }
                  "spec": {
                      "claimRef": claimRef
                      "deletionPolicy": dp
                      "enabled": peeringEnabled
                      "localVpcDetails": {
                          "name": get(_oxr, "spec.claimRef.name", "")
                          "cidrBlocks": [
                              c for c in [
                                  get(_oxr, "status.vpcs.self.cidrBlock", "")
                              ] + get(_oxr, "status.vpcs.self.additionalCidrBlocks", [])
                              if c
                          ]
                          "region": region
                          "routeTableIds": [
                              i.id for r in get(_oxr, "status.vpcs.self.publicRouteTables", [])
                              for _, i in r
                              if get(_oxr, "spec.peering.allowPublic", True)
                          ] + [
                              i.id for r in get(_oxr, "status.vpcs.self.privateRouteTables", [])
                              for _, i in r
                          ]
                          "vpcId": get(_oxr, "status.vpcs.self.id", "")
                      }
                      "peerVpcDetails": {
                          "name": remoteVpc.name
                          "cidrBlocks": [
                              c for c in [
                                  get(_oxr, "status.vpcs.${remoteVpc.name}.cidrBlock", "")
                              ] + get(_oxr, "status.vpcs.${remoteVpc.name}.additionalCidrBlocks", [])
                              if c
                          ]
                          "region": remoteVpc.region
                          "routeTableIds": [
                              i.id for r in get(_oxr, "status.vpcs.${remoteVpc.name}.publicRouteTables", [])
                              for _, i in r
                              if get(remoteVpc, "allowPublic", True)
                          ] + [
                              i.id for r in get(_oxr, "status.vpcs.${remoteVpc.name}.privateRouteTables", [])
                              for _, i in r
                          ]
                          "vpcId": get(_oxr, "status.vpcs.${remoteVpc.name}.id", "")
                      }
                      "tags": {
                          "Name": "${appName}-${region}-${remoteVpc.name}"
                      } | tags
                      providerConfigRef: pcr
                  }
              }
              for _, remoteVpc in get(_oxr, "spec.peering.remoteVpcs", [])
              if all_true([
                  peeringEnabled,
                  get(_oxr, "status.vpcs.self.id", False),
                  get(_oxr, "status.vpcs.${remoteVpc.name}.id", False),
              ])
          ]

          _items = peering

          items = _items
        target: ""
    step: function-kcl-create-peering
  - functionRef:
      name: function-kcl
    input:
      apiVersion: krm.kcl.dev/v1alpha1
      kind: KCLInput
      metadata:
        creationTimestamp: null
      spec:
        source: |-
          import regex
          _oxr = option("params").oxr
          _dxr = option("params").dxr
          _ocs = option("params").ocds

          get = lambda x: {:}, y: str, d: any -> any {
              """
              Get an item from a dictionary using a dot separated path.
              If the item is not found, return a default value.
              """
              p = regex.split(y, "\.")
              c = p[0]
              y = ".".join(p[1:])
              x[c] if len(p) == 1 and c in x else d if c not in x else get(x[c], y, d)
          }

          ready = lambda x: any, y: str -> str {
              """
              Check if a value is ready.
              """
              conditions = get(x, "${y}.Resource.status.conditions", [])
              "True" if all_true([
                  get(c, "status", "False") == "True" for c in conditions
              ]) else "False"
          }

          appName = get(_oxr, "spec.claimRef.name", "")
          claimRef = get(_oxr, "spec.claimRef", {})
          dp = get(_oxr, "spec.deletionPolicy", "Delete")
          labels = get(_oxr, "metadata.labels", {})
          peeringEnabled = get(_oxr, "spec.peering.enabled", False)
          pcr = get(_oxr, "spec.providerConfigRef", {"name": "default"})
          region = get(_oxr, "spec.region", "eu-central-1")
          tags = labels | get(_oxr, "spec.tags.common", {}) | {
              "region": region,
          }

          _ram = get(_oxr, "spec.ram", {enabled: False})
          _tgwRam = get(_oxr, "spec.transitGateway.ram", {enabled: False})

          # If we have both RAM and TGW RAM enabled, we need to disable TGW RAM
          # as it will be built as part of the VPC
          if _tgwRam.enabled and _ram.enabled:
              _tgwRam.enabled = False

          localRouteTableIds = [
              i.id for r in get(_oxr, "status.vpcs.self.publicRouteTables", [])
              for _, i in r
              if get(_oxr, "spec.transitGateway.allowPublic", True)
          ] + [
              i.id for r in get(_oxr, "status.vpcs.privateRouteTables", [])
              for _, i in r
          ]

          preferPublic = get(_oxr, "spec.transitGateway.preferPublicAttachments", False)

          # We can only use one subnet in each availability zone for the TGW attachment
          localSubnetIds = [
              i.id for j, r in get(_oxr, "status.vpcs.self.publicSubnets", [])
              for _, i in r
              if all_true([
                  j == 0
                  get(_oxr, "spec.transitGateway.allowPublic", True)
                  preferPublic
              ])
          ] if all_true([
              preferPublic,
              get(_oxr, "spec.transitGateway.allowPublic", True),
          ]) else [
              i.id for j, r in get(_oxr, "status.vpcs.self.privateSubnets", [])
              for _, i in r
              if j == 0
          ]

          localVpc = {
              "cidrBlocks": [
                  c for _, c in [
                      get(_oxr, "status.vpcs.self.cidrBlock", "")
                  ] + get(_oxr, "status.vpcs.self.additionalCidrBlocks", [])
                  if c
              ],

              if get(_oxr, "spec.prefixLists", False):
                  "prefixLists": [
                      {
                          blackhole: pl.blackhole,
                          pl.id: get(_oxr, "status.prefixLists.${pl.name}", pl.name),
                      }
                      for _, pl in get(_oxr, "spec.prefixLists", [])
                  ]

              "region": get(_oxr, "spec.region", ""),
              "routeTableIds": localRouteTableIds,
              "subnetIds": localSubnetIds,

              if get(_oxr, "status.vpcs.self.id", False):
                  "vpcId": get(_oxr, "status.vpcs.self.id", ""),

          } if all_true([
              get(_oxr, "status.vpcs.self.id", False)
              localRouteTableIds,
              localSubnetIds,
          ]) else {}

          remoteVpcs = [
              {
                  _subnetIds = [
                      i.id for j, r in get(_oxr, "status.vpcs.${vpc.name}.publicSubnets", [])
                      for _, i in r
                      if all_true([
                          j == 0
                          get(vpc, "allowPublic", True)
                          preferPublic
                      ])
                  ] if all_true([
                      preferPublic,
                      get(vpc, "allowPublic", True),
                  ]) else [
                      i.id for j, r in get(_oxr, "status.vpcs.${vpc.name}.privateSubnets", [])
                      for _, i in r
                      if j == 0
                  ]
                  "cidrBlocks": [
                      c for _, c in [
                          get(_oxr, "status.vpcs.${vpc.name}.cidrBlock", "")
                      ] + get(_oxr, "status.vpcs.${vpc.name}.additionalCidrBlocks", [])
                      if c
                  ],
                  "name": vpc.name,
                  "region": get(_oxr, "status.vpcs.${vpc.name}.region", ""),
                  "routeTableIds": [
                      i.id for r in get(_oxr, "status.vpcs.${vpc.name}.publicRouteTables", [])
                      for _, i in r
                      if get(_oxr, "spec.transitGateway.allowPublic", True)
                  ] + [
                      i.id for r in get(_oxr, "status.vpcs.${vpc.name}.privateRouteTables", [])
                      for _, i in r
                  ],
                  "subnetIds": _subnetIds,
                  "vpcId": get(_oxr, "status.vpcs.${vpc.name}.id", ""),
              }
              for _, vpc in get(_oxr, "spec.transitGateway.remoteVpcs", [])
              if get(_oxr, "status.vpcs.${vpc.name}.id", False)
          ]

          tgw = {
              "apiVersion": "xnetworks.crossplane.giantswarm.io/v1alpha1",
              "kind": "TransitGateway",
              "metadata": {
                  "annotations": {
                      "krm.kcl.dev/composition-resource-name": "transitgw",
                      "krm.kcl.dev/ready": ready(_ocs, "transitgw"),
                  }
                  "labels": labels,
              },
              "spec": {
                  "deletionPolicy": get(_oxr, "spec.deletionPolicy", "Delete"),
                  "claimRef": get(_oxr, "spec.claimRef", {}),
                  "enabled": get(_oxr, "spec.transitGateway.enabled", False),
                  if get(_oxr, "spec.amazonSideAsn", False):
                      "amazonSideAsn": get(_oxr, "spec.amazonSideAsn", 64512),
                  if get(_oxr, "spec.applianceModeSupport", False):
                      "applianceModeSupport": get(_oxr, "spec.applianceModeSupport", "disable"),
                  if get(_oxr, "spec.autoAcceptSharedAttachments", False):
                      "autoAcceptSharedAttachments": get(_oxr, "spec.autoAcceptSharedAttachments", "disable"),
                  if get(_oxr, "spec.createPolicyTable", False):
                      "createPolicyTable": get(_oxr, "spec.createPolicyTable", "disable"),
                  if get(_oxr, "spec.defaultRouteTableAssociation", False):
                      "defaultRouteTableAssociation": get(_oxr, "spec.defaultRouteTableAssociation", "disable"),
                  if get(_oxr, "spec.defaultRouteTablePropagation", False):
                      "defaultRouteTablePropagation": get(_oxr, "spec.defaultRouteTablePropagation", "disable"),
                  if get(_oxr, "spec.dnsSupport", False):
                      "dnsSupport": get(_oxr, "spec.dnsSupport", "disable"),
                  if get(_oxr, "spec.ipv6Support", False):
                      "ipv6Support": get(_oxr, "spec.ipv6Support", "disable"),

                  "localVpc": localVpc,

                  if get(_oxr, "spec.multicastSupport", False):
                      "multicastSupport": get(_oxr, "spec.multicastSupport", "disable"),
                  if get(_oxr, "spec.prefixListSupport", False):
                      "prefixListSupport": get(_oxr, "spec.prefixListSupport", "disable"),

                  if get(_ram, "enabled", False):
                      "ram": _ram,

                  "remoteVpcs": remoteVpcs,

                  if get(_oxr, "spec.transitGatewayCidrBlocks", False):
                      "transitGatewayCidrBlocks": get(_oxr, "spec.transitGatewayCidrBlocks", []),
                  if get(_oxr, "spec.transitGatewayRouteTableAssociation", False):
                      "transitGatewayRouteTableAssociation": get(_oxr, "spec.transitGatewayRouteTableAssociation", "disable"),
                  if get(_oxr, "spec.transitGatewayRouteTablePropagation", False):
                      "transitGatewayRouteTablePropagation": get(_oxr, "spec.transitGatewayRouteTablePropagation", "disable"),

                  # TRANSIT GATEWAY PEERS HERE

                  "tags": get(_oxr, "spec.tags.common", []),

                  if get(_oxr, "spec.vpnEcmpSupport", False):
                      "vpnEcmpSupport": get(_oxr, "spec.vpnEcmpSupport", "disable"),

                  "providerConfigRef": get(_oxr, "spec.providerConfigRef", {}),
              }
          }

          _items = [
              tgw
              for _ in [True]
              if all_true([
                  get(_oxr, "spec.transitGateway.enabled", False),
                  localVpc,
                  remoteVpcs,
                  len(remoteVpcs) == len(get(_oxr, "spec.transitGateway.remoteVpcs", [])),
                  localRouteTableIds,
                  localSubnetIds,
              ])
          ]

          items = _items
        target: ""
    step: function-kcl-create-transit-gateway
  - functionRef:
      name: function-kcl
    input:
      apiVersion: krm.kcl.dev/v1alpha1
      kind: KCLInput
      metadata:
        creationTimestamp: null
      spec:
        source: |-
          import regex
          _oxr = option("params").oxr
          _dxr = option("params").dxr
          _ocs = option("params").ocds

          get = lambda x: {:}, y: str, d: any -> any {
              """
              Get an item from a dictionary using a dot separated path.
              If the item is not found, return a default value.
              """
              p = regex.split(y, "\.")
              c = p[0]
              y = ".".join(p[1:])
              x[c] if len(p) == 1 and c in x else d if c not in x else get(x[c], y, d)
          }

          ready = lambda x: any, y: str -> str {
              """
              Check if a value is ready.
              """
              conditions = get(x, "${y}.Resource.status.conditions", [])
              "True" if all_true([
                  get(c, "status", "False") == "True" for c in conditions
              ]) else "False"
          }

          appName = get(_oxr, "spec.claimRef.name", "")
          claimRef = get(_oxr, "spec.claimRef", {})
          dp = get(_oxr, "spec.deletionPolicy", "Delete")
          labels = get(_oxr, "metadata.labels", {})
          peeringEnabled = get(_oxr, "spec.peering.enabled", False)
          pcr = get(_oxr, "spec.providerConfigRef", {"name": "default"})
          region = get(_oxr, "spec.region", "eu-central-1")
          tags = labels | get(_oxr, "spec.tags.common", {}) | {
              "region": region,
          }

          privateSubnetsetKeys = sorted([
                k for k in _ocs
                if all_true([
                  _ocs,
                  get(_ocs, "${k}.Resource.kind", "") == "SubnetSet",
                  get(_ocs, "${k}.Resource.spec.type", "") == "private"
                ])
          ])

          publicSubnetsetKeys = sorted([
                k for k in _ocs
                if all_true([
                  _ocs,
                  get(_ocs, "${k}.Resource.kind", "") == "SubnetSet",
                  get(_ocs, "${k}.Resource.spec.type", "") == "public"
                ])
          ])

          privateRouteTables = [
                {
                    key = {"id": value}
                    for key, value in get(_ocs, "${k}.Resource.status.routeTables", {})
                }
                for _, k in privateSubnetsetKeys
          ]

          privateSubnets = [
                {
                    key = {"id": value}
                    for key, value in get(_ocs, "${k}.Resource.status.subnets", {})
                }
                for _, k in privateSubnetsetKeys
          ]

          publicRouteTables = [
                {
                    key = {"id": value}
                    for key, value in get(_ocs, "${k}.Resource.status.routeTables", {})
                }
                for _, k in publicSubnetsetKeys
          ]

          publicSubnets = [
                {
                    key = {"id": value}
                    for key, value in get(_ocs, "${k}.Resource.status.subnets", {})
                }
                for _, k in publicSubnetsetKeys
          ]

          groupByPeer = get(_oxr, "spec.peering.groupBy", False)
          groupByTgw = get(_oxr, "spec.transitGateway.groupBy", False)
          if groupByPeer and groupByTgw and groupByPeer != groupByTgw:
              assert False, "peering.groupBy and transitGateway.groupBy must be the same if both set"

          groupBy = groupByPeer if groupByPeer else groupByTgw if groupByTgw else "giantswarm.io/subnetset"

          vpcLookup = {
              "groupBy": groupBy
              "enabled": any_true([
                  get(_oxr, "spec.transitGateway.enabled", False),
                  get(_oxr, "spec.peering.enabled", False)
              ])
              "remoteVpcs": [
                  {
                      "name": vpc.name
                      "providerConfigRef": get(vpc, "providerConfigRef.name", pcr.name)
                      "region": vpc.region
                  }
                  for _, vpc in get(_oxr, "spec.transitGateway.remoteVpcs", [])
              ] + [
                  {
                      "name": vpc.name
                      "providerConfigRef": get(vpc, "providerConfigRef.name", pcr.name)
                      "region": vpc.region
                  }
                  for _, vpc in get(_oxr, "spec.peering.remoteVpcs", [])
              ]
          }

          cidrs = [
              s.prefix
              for s in get(_oxr, "spec.subnetsets.cidrs", [])
              if s
          ]

          azl = len(get(_oxr, "spec.availabilityZones", []))

          m = lambda x: str -> int {
              """
              Get the mask as an integer value
              """
              ip_mask = x.split("/")
              int(ip_mask[1]) if len(ip_mask) == 2 else int(ip_mask[0])
          }

          cb = lambda x: str, s: int, c: int -> [] {
              """
              Create 3 subnet bits for each subnet group requested

              :param x: The mask of the subnet
              :param s: The size of the vpc prefix
              :param c: The number of subnets requested
              """
              [m(x) - s for _ in range(azl) for _ in range(c) if c > 0 and x]
          }

          newdxr = {
              **_oxr
              **{
                  "status": {
                      "subnetBits": [
                          {
                              _vpcSize = s.prefix.split("/")[1]
                              _public = s.public.count
                              _private = s.private.count
                              _x = int(_vpcSize)
                              "prefix": s.prefix
                              "offset": m(s.offset) - _x if s.offset else 0
                              "newBits": cb(s.public.mask, _x, s.public.count) + cb(s.private.mask, _x, s.private.count)
                          }
                          for s in get(_oxr, "spec.subnetsets.cidrs", {}) if s
                      ]
                      "vpcLookup": vpcLookup
                      "vpcs": {
                          "self": {
                              if cidrs:
                                  "cidrBlock": cidrs[0]
                              if len(cidrs) > 1:
                                  "additionalCidrBlocks" = cidrs[1:]
                              if publicRouteTables:
                                  "publicRouteTables" = publicRouteTables
                              if publicSubnets:
                                  "publicSubnets" = publicSubnets
                              if privateRouteTables:
                                  "privateRouteTables" = privateRouteTables
                              if privateSubnets:
                                  "privateSubnets" = privateSubnets

                              "natGateways": {
                                  name: get(item, "Resource.status.atProvider.id", "")
                                  for name, item in _ocs
                                  if all_true([
                                      _ocs,
                                      get(item, "Resource.kind", "") == "NATGateway"
                                      get(item, "Resource.status.atProvider.id", False)
                                  ])
                              }
                              "transitGateways": {
                                  "name": {
                                      "id": get(item, "Resource.status.atProvider.id", ""),
                                  }
                                  for name, item in _ocs
                                  if all_true([
                                      _ocs,
                                      get(item, "Resource.kind", "") == "TransitGateway"
                                      get(item, "Resource.apiVersion", "") == "xnetworks.crossplane.giantswarm.io/v1alpha1"
                                      get(item, "Resource.status.tgwId", False)
                                  ])
                              }
                          }
                      }
                  }
              }
          }

          _items = [
              newdxr,
          ]

          items = _items
        target: ""
    step: function-kcl-patch-xr
  - functionRef:
      name: function-patch-and-transform
    input:
      apiVersion: pt.crossplane.io/v1beta1
      kind: Resources
      metadata:
        creationTimestamp: null
      patchSets:
      - name: metadata
        patches:
        - fromFieldPath: metadata.labels
          policy:
            toFieldPath: MergeObjects
          toFieldPath: metadata.labels
          type: FromCompositeFieldPath
        - fromFieldPath: spec.region
          toFieldPath: metadata.labels.region
          type: FromCompositeFieldPath
        - fromFieldPath: spec.providerConfigRef
          toFieldPath: spec.providerConfigRef
          type: FromCompositeFieldPath
        - fromFieldPath: spec.deletionPolicy
          toFieldPath: spec.deletionPolicy
          type: FromCompositeFieldPath
      - name: commontags
        patches:
        - fromFieldPath: spec.tags.common
          policy:
            toFieldPath: MergeObjects
          toFieldPath: spec.forProvider.tags
          type: FromCompositeFieldPath
        - fromFieldPath: metadata.labels
          policy:
            toFieldPath: MergeObjects
          toFieldPath: spec.forProvider.tags
          type: FromCompositeFieldPath
        - fromFieldPath: spec.region
          toFieldPath: spec.forProvider.tags.region
          type: FromCompositeFieldPath
      resources:
      - base:
          apiVersion: ec2.aws.upbound.io/v1beta1
          kind: VPC
          metadata:
            creationTimestamp: null
          spec:
            forProvider:
              enableDnsHostnames: true
              enableDnsSupport: true
              region: null
            initProvider: {}
          status:
            atProvider: {}
        name: vpc
        patches:
        - fromFieldPath: spec.region
          toFieldPath: spec.forProvider.region
          type: FromCompositeFieldPath
        - fromFieldPath: spec.subnetsets.cidrs[0].prefix
          toFieldPath: spec.forProvider.cidrBlock
          type: FromCompositeFieldPath
        - patchSetName: commontags
          type: PatchSet
        - fromFieldPath: spec.claimRef.name
          toFieldPath: spec.forProvider.tags.Name
          type: FromCompositeFieldPath
        - patchSetName: metadata
          type: PatchSet
        - fromFieldPath: status.atProvider.id
          toFieldPath: status.vpcs.self.id
          type: ToCompositeFieldPath
      - base:
          apiVersion: ec2.aws.upbound.io/v1beta1
          kind: DefaultSecurityGroup
          metadata:
            creationTimestamp: null
          spec:
            forProvider:
              region: null
              vpcIdSelector:
                matchControllerRef: true
            initProvider: {}
          status:
            atProvider: {}
        name: default-sg-control
        patches:
        - fromFieldPath: spec.region
          toFieldPath: spec.forProvider.region
          type: FromCompositeFieldPath
        - patchSetName: commontags
          type: PatchSet
        - patchSetName: metadata
          type: PatchSet
      - base:
          apiVersion: ec2.aws.upbound.io/v1beta1
          kind: InternetGateway
          metadata:
            creationTimestamp: null
          spec:
            forProvider:
              region: null
              vpcIdSelector:
                matchControllerRef: true
            initProvider: {}
          status:
            atProvider: {}
        name: internet-gateway
        patches:
        - fromFieldPath: spec.region
          toFieldPath: spec.forProvider.region
          type: FromCompositeFieldPath
        - patchSetName: commontags
          type: PatchSet
        - patchSetName: metadata
          type: PatchSet
        - combine:
            strategy: string
            string:
              fmt: '%s-%s-igw'
            variables:
            - fromFieldPath: spec.claimRef.name
            - fromFieldPath: spec.region
          toFieldPath: spec.forProvider.tags.Name
          type: CombineFromComposite
        - fromFieldPath: status.atProvider.id
          toFieldPath: status.vpcs.self.internetGateway
          type: ToCompositeFieldPath
    step: patch-and-transform
  - functionRef:
      name: function-auto-ready
    step: function-auto-ready
