apiVersion: apiextensions.crossplane.io/v1
kind: Composition
metadata:
  creationTimestamp: null
  labels:
    component: networking
    provider: aws
    type: transitgateway
  name: transitgateway
spec:
  compositeTypeRef:
    apiVersion: xnetworks.crossplane.giantswarm.io/v1alpha1
    kind: TransitGateway
  mode: Pipeline
  pipeline:
  - functionRef:
      name: function-kcl
    input:
      apiVersion: krm.kcl.dev/v1alpha1
      kind: KCLInput
      metadata:
        creationTimestamp: null
      spec:
        source: |-
          import regex
          oxr = option("params").oxr
          dxr = option("params").dxr
          ocds = option("params").ocds
          dcds = option("params").dcds

          exists = lambda x: any -> bool {
              """
              Check if a value exists.
              """
              x in list(ocds)
          }

          get = lambda x: {:}, y: str, d: any -> any {
              """
              Get an item from a dictionary using a dot separated path.
              If the item is not found, return a default value.
              """
              p = regex.split(y, "\.")
              c = p[0]
              y = ".".join(p[1:])
              x[c] if len(p) == 1 and c in x else d if c not in x else get(x[c], y, d)
          }

          gpcr = lambda x: {:} -> {:} {
              """
              Get the ProviderConfigRef from the given object

              If this is not set it will attempt to return the ProviderConfigRef from
              the Observed Composite Resource, and if that isn't set, will return an
              object with an empty name.
              """
              get(x, "providerConfigRef", get(oxr, "spec.providerConfigRef", {name: ""}))
          }

          ocdsstatus = lambda x: str, y: str, d: any -> any {
              """
              Get an item from the status of an ocds resource.
              """
              _x = None
              if get(ocds, "${x}.Resource.status.atProvider", False):
                  _x = get(ocds, "${x}.Resource.status.atProvider.${y}", d)
              else:
                  _x = get(ocds, "${x}.Resource.status.${y}", d)
              _x if _x else d
          }

          ready = lambda x: str -> bool {
              """
              Check if a value is ready.
              """
              conditionsReady = all_true([
                  get(c, "status", "False") == "True" for c in ocdsstatus(x, "conditions", [])
              ])

              ap = get(ocds, "${x}.Resource.status.atProvider", {})
              objectReady = any_true([
                  ocdsstatus(x, "ready", False),
                  len(list(ap)) > 0,
              ])

              all_true([
                  any_true([exists(x), conditionsReady]),
                  objectReady,
              ])
          }

          readystr = lambda x: str -> str {
              """
              Check if a value is ready.
              """
              "True" if ready(x) else "False"
          }

          allReady = lambda -> bool {
              """
              Check if all managed resources are ready.
              """
              all_true([
                  ready(x)
                  for x in list(ocds)
              ])
          }

          appName = get(oxr, "spec.claimRef.name", "")
          dp = get(oxr, "spec.deletionPolicy", "Delete")
          labels = get(oxr, "metadata.labels", {})
          localVpc = get(oxr, "spec.localVpc", {})
          pcr = get(oxr, "spec.providerConfigRef", {"name": "default"})
          region = get(oxr, "spec.localVpc.region", "eu-central-1")
          tags = get(oxr, "spec.tags", {}) | {
              "region": region,
          } | labels

          localAttachmentIds = {
              "${appName}": ocdsstatus("tgwa-${appName}-${region}", "id", "")
              for _ in [True]
              if ocdsstatus("tgwa-${appName}-${region}", "id", False)
          }

          mgmtPolicy = get(oxr, "spec.managementPolicies", [])

          publishConnection = get(oxr, "spec.publishConnectionDetailsTo", {})
          tgwArn = ocdsstatus("transitgateway-${appName}-${region}", "arn", False)
          tgwId = ocdsstatus("transitgateway-${appName}-${region}", "id", False)
          tgwRouteTableId = ocdsstatus("tgwrt-${appName}-${region}", "id", False)

          remoteAttachementIds = {
              "${remoteVpc.name}": ocdsstatus("tgwa-${appName}-${region}-${remoteVpc.name}", "id", "")
              for _, remoteVpc in get(oxr, "spec.remoteVpcs", [])
              if ocdsstatus("tgwa-${appName}-${region}-${remoteVpc.name}", "id", False)
          }

          peerAttachmentIds = {
              "${peer.name}": ocdsstatus("tgwa-${appName}-${region}-${peer.name}", "id", "")
              for _, peer in get(oxr, "spec.peers", [])
              if ocdsstatus("tgwa-${appName}-${region}-${peer.name}", "id", False)
          }

          routingTables = {
              "${appName}": {
                  "vpc": {
                      "open": [
                          # Outbound from the local VPC needs the remote cidr blocks
                          {
                              "cidr": cidr,
                              "description": "${remoteVpc.name} CIDR Block ${i}",
                          }
                          for _, remoteVpc in get(oxr, "spec.remoteVpcs", [])
                          for i, cidr in get(remoteVpc, "cidrBlocks", [])
                      ] + [
                          e
                          for _, pl in get(localVpc, "prefixLists", [])
                          for e in get(pl, "entries", [])
                          if all_true([
                              e,
                              get(pl, "outbound", False),
                              not get(pl, "id", False),
                              not get(pl, "blackhole", False),
                          ])
                      ],
                      "blackhole": [
                          e
                          for _, pl in get(localVpc, "prefixLists", [])
                          for e in get(pl, "entries", [])
                          if all_true([
                              e,
                              get(pl, "outbound", False),
                              not get(pl, "id", False),
                              get(pl, "blackhole", False),
                          ])
                      ]
                  },
                  "tgw": {
                      "open": [
                          e
                          for _, pl in get(localVpc, "prefixLists", [])
                          for e in get(pl, "entries", [])
                          if all_true([
                              e,
                              not get(pl, "outbound", True),
                              not get(pl, "id", False),
                              not get(pl, "blackhole", False),
                          ])
                      ],
                      "blackhole": [
                          e
                          for _, pl in get(localVpc, "prefixLists", [])
                          for e in get(pl, "entries", [])
                          if all_true([
                              e,
                              not get(pl, "outbound", True),
                              not get(pl, "id", False),
                              get(pl, "blackhole", False),
                          ])
                      ]
                  }
              }
          } | {
              "${r.name}": {
                  "vpc": {
                      "open": [
                          # Add the primary VPC cidr blocks
                          {
                              "cidr": cidr,
                              "description": "${appName} CIDR Block ${i}",
                          }
                          for i, cidr in get(localVpc, "cidrBlocks", [])
                      ] + [
                          # Add the remote VPC cidr blocks where the remote VPC is not the
                          # same as the current VPC
                          {
                              "cidr": cidr,
                              "description": "${remoteVpc.name} CIDR Block ${i}",
                          }
                          for _, remoteVpc in get(oxr, "spec.remoteVpcs", [])
                          for i, cidr in get(remoteVpc, "cidrBlocks", [])
                          if all_true([
                              remoteVpc.name != r.name,
                          ])
                      ] + [
                          # Add any prefix list entries that need creating
                          e
                          for _, pl in get(r, "prefixLists", [])
                          for e in get(pl, "entries", [])
                          if all_true([
                              e,
                              get(pl, "outbound", False),
                              not get(pl, "id", False),
                              not get(pl, "blackhole", False),
                          ])
                      ],
                      "blackhole": [
                          e
                          for _, pl in get(r, "prefixLists", [])
                          for e in get(pl, "entries", [])
                          if all_true([
                              e,
                              get(pl, "outbound", False),
                              not get(pl, "id", False),
                              get(pl, "blackhole", False),
                          ])
                      ]
                  },
                  "tgw": {
                      "open": [
                          e
                          for _, pl in get(r, "prefixLists", [])
                          for e in get(pl, "entries", [])
                          if all_true([
                              e,
                              not get(pl, "outbound", True),
                              not get(pl, "id", False),
                              not get(pl, "blackhole", False),
                          ])

                      ],
                      "blackhole": [
                          e
                          for _, pl in get(r, "prefixLists", [])
                          for e in get(pl, "entries", [])
                          if all_true([
                              e,
                              not get(pl, "outbound", True),
                              not get(pl, "id", False),
                              get(pl, "blackhole", False),
                          ])
                      ]
                  }
              }
              for _, r in get(oxr, "spec.remoteVpcs", [])
          } | {
              "peering-${peer.name}": {
                  "remote": {
                      "open": [
                          e
                          for _, pl in get(peer, "prefixLists", [])
                          for e in get(pl, "entries", [])
                          if all_true([
                              e,
                              get(pl, "outbound", False),
                              not get(pl, "id", False),
                              not get(pl, "blackhole", False),
                          ])
                      ],
                      "blackhole": [
                          e
                          for _, pl in get(peer, "prefixLists", [])
                          for e in get(pl, "entries", [])
                          if all_true([
                              e,
                              get(pl, "outbound", False),
                              not get(pl, "id", False),
                              get(pl, "blackhole", False),
                          ])
                      ]
                  },
                  "tgw": {
                      "open": [
                          e
                          for _, pl in get(peer, "prefixLists", [])
                          for e in get(pl, "entries", [])
                          if all_true([
                              e,
                              not get(pl, "outbound", True),
                              not get(pl, "id", False),
                              not get(pl, "blackhole", False),
                          ])
                      ],
                      "blackhole": [
                          e
                          for _, pl in get(peer, "prefixLists", [])
                          for e in get(pl, "entries", [])
                          if all_true([
                              e,
                              not get(pl, "outbound", True),
                              not get(pl, "id", False),
                              get(pl, "blackhole", False),
                          ])
                      ]
                  }
              }
              for _, peer in get(oxr, "spec.peers", [])
          }

          mpl = lambda n : str, r: str, a: str, b: bool, isp: bool, e: [], p: {:} -> {:} {
              """
              Create a ManagedPrefixList object.

              n: The name of the ManagedPrefixList
              r: The region the ManagedPrefixList is in
              a: The address family of the ManagedPrefixList
              b: Whether the ManagedPrefixList is a blackhole
              isp: Whether the ManagedPrefixList is for a peering connection
              e: The entries for the ManagedPrefixList
              p: The ProviderConfigRef for the ManagedPrefixList

              Returns a ManagedPrefixList object.
              """
              _bh = "-bh" if b else ""
              _n = "${appName}-${region}-${n}${_bh}" if n != appName else "${appName}-${region}${_bh}"
              _isp = "-tgw" if isp else ""
              _resourceName = "mpl-${_n}" if not isp else "p-mpl-${_n}"
              {
                  "apiVersion": "xnetworks.crossplane.giantswarm.io/v1alpha1",
                  "kind": "ManagedPrefixList",
                  "metadata": {
                      "annotations": {
                          "krm.kcl.dev/composition-resource-name": _resourceName,
                          "krm.kcl.dev/ready": readystr(_resourceName),
                      },
                      "labels": labels | {
                          "vpcName" = n,
                      },
                  },
                  "spec": {
                      "addressFamily": a,
                      "claimRef": get(oxr, "spec.claimRef", {}),
                      "deletionPolicy": dp,
                      "entries": e,
                      "managementPolicies": mgmtPolicy,
                      "name": "${_n}${_isp}",
                      "region": r,
                      "providerConfigRef": p,
                      "tags": tags | {
                          "Name": "${_n}${_isp}",
                      },
                  }
              } if len(e) > 0 else {}
          }

          plr = lambda n : str, r: str, pid: str, aid: str, rid: str, b: bool, isp: bool, p: {:} -> {:} {
              """
              Create a TransitGatewayPrefixListReference object.

              n: The name of the PrefixList reference
              r: The region the PrefixList reference should be created in
              b: Whether the PrefixList is a blackhole
              pid: The PrefixListId for the PrefixList reference
              aid: The TransitGatewayAttachmentId for the PrefixList reference
              rid: The TransitGatewayRouteTableId for the PrefixList reference
              isp: Whether the PrefixList reference is for a peering connection
              p: The ProviderConfigRef for the PrefixList

              Returns a TransitGatewayPrefixListReference object.
              """
              {
                  _bh = "-bh" if b else ""
                  _n = "${appName}-${region}-${n}${_bh}" if n != appName else "${appName}-${region}${_bh}"
                  _resourceName = "tgwplr-${aid}" if not isp else "p-tgwplr-${aid}"
                  "apiVersion": "ec2.aws.upbound.io/v1beta1",
                  "kind": "TransitGatewayPrefixListReference",
                  "metadata": {
                      "annotations": {
                          "krm.kcl.dev/composition-resource-name": _resourceName,
                          "krm.kcl.dev/ready": readystr(_resourceName),
                      },
                      "labels": labels | {
                          "vpcName" = n,
                      } if not isp else {
                          "peerName" = n,
                      },
                  },
                  "spec": {
                      "deletionPolicy": dp,
                      "forProvider": {
                          "blackhole": b,
                          "prefixListId": pid,
                          "region": r,
                          "transitGatewayAttachmentId": aid,
                          "transitGatewayRouteTableId": rid,
                      },
                      "managementPolicies": mgmtPolicy,
                      "providerConfigRef": p,
                  }
              } if all_true([
                  pid, aid, rid,
              ]) else {}
          }

          remotePrefixListIds = {
              "${rVpc.name}": [
                  c for c in [
                      ocdsstatus("mpl-${appName}-${region}-${rVpc.name}", "id", "")
                      ocdsstatus("mpl-${appName}-${region}-${rVpc.name}-bh", "id", "")
                  ] if c
              ] + [
                  c for c in [
                      get(pl, "id", "")
                      for _, pl in get(rVpc, "prefixLists", [])
                      if all_true([
                          get(pl, "id", False),
                          get(pl, "outbound", True),
                      ])
                  ]
              ]
              for _, rVpc in get(oxr, "spec.remoteVpcs", [])
          }

          sharedPrefixLists: [str] = [
              c for r in [
                  [
                      ocdsstatus("mpl-${appName}-${region}-${rVpc.name}", "arn", ""),
                      ocdsstatus("mpl-${appName}-${region}-${rVpc.name}-bh", "arn", ""),
                  ]
                  for _, rVpc in get(oxr, "spec.remoteVpcs", [])
                  if rVpc.accountId != get(oxr, "spec.localVpc.accountId", "")
              ]
              for c in r if c
          ]

          # Create the attachment to the local VPC
          localAttachments = [
              {
                  _resourceName = "tgwa-${appName}-${region}"
                  "apiVersion": "ec2.aws.upbound.io/v1beta1"
                  "kind": "TransitGatewayVPCAttachment"
                  "metadata": {
                      "annotations": {
                          "krm.kcl.dev/composition-resource-name": _resourceName
                          "krm.kcl.dev/ready" = readystr(_resourceName)
                      }
                      "labels": labels | {
                          "vpcName": appName
                      }
                  }
                  "spec": {
                      "deletionPolicy": dp
                      "forProvider": {
                          "applianceModeSupport": get(oxr, "spec.applianceModeSupport", "disable"),
                          "dnsSupport": get(oxr, "spec.dnsSupport", "enable"),
                          "ipv6Support": get(oxr, "spec.ipv6Support", "disable"),
                          "region": region,
                          "subnetIds": get(localVpc, "subnetIds", []),
                          "tags": tags | {
                              Name: "${appName}-${region}"
                          }
                          "transitGatewayDefaultRouteTableAssociation": get(oxr, "spec.defaultRouteTableAssociation", False),
                          "transitGatewayDefaultRouteTablePropagation": get(oxr, "spec.defaultRouteTablePropagation", False),
                          "transitGatewayId": tgwId,
                          "vpcId": get(localVpc, "vpcId", ""),
                      }
                      "managementPolicies": mgmtPolicy,
                      "providerConfigRef": pcr
                  }
              }
              for _ in [True]
              if all_true([
                  tgwId, localVpc,
              ])
          ]

          # Local VPC prefix lists
          localPrefixLists = [
              mpl(
                  appName,
                  region,
                  get(localVpc, "addressFamily", "IPv4"),
                  False,
                  False,
                  get(routingTables, "${appName}.vpc.open", {}),
                  pcr,
              ),
              mpl(
                  appName,
                  region,
                  get(localVpc, "addressFamily", "IPv4"),
                  True,
                  False,
                  get(routingTables, "${appName}.vpc.blackhole", {}),
                  pcr,
              ),
          ]

          prefixListIds = [
              c for c in [
                  ocdsstatus("mpl-${appName}-${region}", "id", ""),
                  ocdsstatus("mpl-${appName}-${region}-bh", "id", ""),
              ] if c
          ] + [
              c for c in [
                  get(pl, "id", "")
                  for pl in get(localVpc, "prefixLists", [])
                  if all_true([
                      get(pl, "id", False),
                      get(pl, "outbound", True),
                  ])
              ] if c
          ]

          # Create the routes right at the end so we can set up
          # the prefix lists properly first
          localRoutes = [
              {
                  _resourceName = "peering-rt-${id}"
                  "apiVersion": "ec2.aws.upbound.io/v1beta1"
                  "kind": "Route"
                  "metadata": {
                      "annotations": {
                          "krm.kcl.dev/composition-resource-name": _resourceName
                          "krm.kcl.dev/ready" = readystr(_resourceName)
                      }
                      "labels": labels | {
                          "routeType": "peering",
                          "vpcName": appName
                      }
                  }
                  "spec": {
                      "deletionPolicy": dp
                      "forProvider": {
                          "destinationPrefixListId": pl,
                          "routeTableId": id,
                          "region": region,
                          "transitGatewayId": tgwId,
                      },
                      "managementPolicies": mgmtPolicy,
                      "providerConfigRef": pcr
                  }
              }
              for _, id in get(oxr, "spec.localVpc.routeTableIds", [])
              for pl in prefixListIds
              if tgwId
          ]

          localPropagation = [
              {
                  _resourceName = "propagation-rt-${id}"
                  "apiVersion": "ec2.aws.upbound.io/v1beta1",
                  "kind": "TransitGatewayRouteTablePropagation",
                  "metadata": {
                      "annotations": {
                          "krm.kcl.dev/composition-resource-name": _resourceName,
                          "krm.kcl.dev/ready" = readystr(_resourceName),
                      },
                      "labels": labels | {
                          "vpcName": appName,
                      },
                  },
                  "spec": {
                      "deletionPolicy": dp,
                      "forProvider": {
                          "region": region,
                          "transitGatewayAttachmentId": id,
                          "transitGatewayRouteTableId": tgwRouteTableId,
                      },
                      "managementPolicies": mgmtPolicy,
                      "providerConfigRef": pcr,
                  },
              }
              for _, id in localAttachmentIds
              if all_true([
                  tgwRouteTableId,
              ])
          ]

          _items = [
              i for r in [
                  localAttachments, localPrefixLists,
                  localRoutes, localPropagation,
              ]
              for i in r if i
          ]

          items = _items
        target: ""
    step: function-kcl-local
  - functionRef:
      name: function-kcl
    input:
      apiVersion: krm.kcl.dev/v1alpha1
      kind: KCLInput
      metadata:
        creationTimestamp: null
      spec:
        source: |-
          import regex
          oxr = option("params").oxr
          dxr = option("params").dxr
          ocds = option("params").ocds
          dcds = option("params").dcds

          exists = lambda x: any -> bool {
              """
              Check if a value exists.
              """
              x in list(ocds)
          }

          get = lambda x: {:}, y: str, d: any -> any {
              """
              Get an item from a dictionary using a dot separated path.
              If the item is not found, return a default value.
              """
              p = regex.split(y, "\.")
              c = p[0]
              y = ".".join(p[1:])
              x[c] if len(p) == 1 and c in x else d if c not in x else get(x[c], y, d)
          }

          gpcr = lambda x: {:} -> {:} {
              """
              Get the ProviderConfigRef from the given object

              If this is not set it will attempt to return the ProviderConfigRef from
              the Observed Composite Resource, and if that isn't set, will return an
              object with an empty name.
              """
              get(x, "providerConfigRef", get(oxr, "spec.providerConfigRef", {name: ""}))
          }

          ocdsstatus = lambda x: str, y: str, d: any -> any {
              """
              Get an item from the status of an ocds resource.
              """
              _x = None
              if get(ocds, "${x}.Resource.status.atProvider", False):
                  _x = get(ocds, "${x}.Resource.status.atProvider.${y}", d)
              else:
                  _x = get(ocds, "${x}.Resource.status.${y}", d)
              _x if _x else d
          }

          ready = lambda x: str -> bool {
              """
              Check if a value is ready.
              """
              conditionsReady = all_true([
                  get(c, "status", "False") == "True" for c in ocdsstatus(x, "conditions", [])
              ])

              ap = get(ocds, "${x}.Resource.status.atProvider", {})
              objectReady = any_true([
                  ocdsstatus(x, "ready", False),
                  len(list(ap)) > 0,
              ])

              all_true([
                  any_true([exists(x), conditionsReady]),
                  objectReady,
              ])
          }

          readystr = lambda x: str -> str {
              """
              Check if a value is ready.
              """
              "True" if ready(x) else "False"
          }

          allReady = lambda -> bool {
              """
              Check if all managed resources are ready.
              """
              all_true([
                  ready(x)
                  for x in list(ocds)
              ])
          }

          appName = get(oxr, "spec.claimRef.name", "")
          dp = get(oxr, "spec.deletionPolicy", "Delete")
          labels = get(oxr, "metadata.labels", {})
          localVpc = get(oxr, "spec.localVpc", {})
          pcr = get(oxr, "spec.providerConfigRef", {"name": "default"})
          region = get(oxr, "spec.localVpc.region", "eu-central-1")
          tags = get(oxr, "spec.tags", {}) | {
              "region": region,
          } | labels

          localAttachmentIds = {
              "${appName}": ocdsstatus("tgwa-${appName}-${region}", "id", "")
              for _ in [True]
              if ocdsstatus("tgwa-${appName}-${region}", "id", False)
          }

          mgmtPolicy = get(oxr, "spec.managementPolicies", [])

          publishConnection = get(oxr, "spec.publishConnectionDetailsTo", {})
          tgwArn = ocdsstatus("transitgateway-${appName}-${region}", "arn", False)
          tgwId = ocdsstatus("transitgateway-${appName}-${region}", "id", False)
          tgwRouteTableId = ocdsstatus("tgwrt-${appName}-${region}", "id", False)

          remoteAttachementIds = {
              "${remoteVpc.name}": ocdsstatus("tgwa-${appName}-${region}-${remoteVpc.name}", "id", "")
              for _, remoteVpc in get(oxr, "spec.remoteVpcs", [])
              if ocdsstatus("tgwa-${appName}-${region}-${remoteVpc.name}", "id", False)
          }

          peerAttachmentIds = {
              "${peer.name}": ocdsstatus("tgwa-${appName}-${region}-${peer.name}", "id", "")
              for _, peer in get(oxr, "spec.peers", [])
              if ocdsstatus("tgwa-${appName}-${region}-${peer.name}", "id", False)
          }

          routingTables = {
              "${appName}": {
                  "vpc": {
                      "open": [
                          # Outbound from the local VPC needs the remote cidr blocks
                          {
                              "cidr": cidr,
                              "description": "${remoteVpc.name} CIDR Block ${i}",
                          }
                          for _, remoteVpc in get(oxr, "spec.remoteVpcs", [])
                          for i, cidr in get(remoteVpc, "cidrBlocks", [])
                      ] + [
                          e
                          for _, pl in get(localVpc, "prefixLists", [])
                          for e in get(pl, "entries", [])
                          if all_true([
                              e,
                              get(pl, "outbound", False),
                              not get(pl, "id", False),
                              not get(pl, "blackhole", False),
                          ])
                      ],
                      "blackhole": [
                          e
                          for _, pl in get(localVpc, "prefixLists", [])
                          for e in get(pl, "entries", [])
                          if all_true([
                              e,
                              get(pl, "outbound", False),
                              not get(pl, "id", False),
                              get(pl, "blackhole", False),
                          ])
                      ]
                  },
                  "tgw": {
                      "open": [
                          e
                          for _, pl in get(localVpc, "prefixLists", [])
                          for e in get(pl, "entries", [])
                          if all_true([
                              e,
                              not get(pl, "outbound", True),
                              not get(pl, "id", False),
                              not get(pl, "blackhole", False),
                          ])
                      ],
                      "blackhole": [
                          e
                          for _, pl in get(localVpc, "prefixLists", [])
                          for e in get(pl, "entries", [])
                          if all_true([
                              e,
                              not get(pl, "outbound", True),
                              not get(pl, "id", False),
                              get(pl, "blackhole", False),
                          ])
                      ]
                  }
              }
          } | {
              "${r.name}": {
                  "vpc": {
                      "open": [
                          # Add the primary VPC cidr blocks
                          {
                              "cidr": cidr,
                              "description": "${appName} CIDR Block ${i}",
                          }
                          for i, cidr in get(localVpc, "cidrBlocks", [])
                      ] + [
                          # Add the remote VPC cidr blocks where the remote VPC is not the
                          # same as the current VPC
                          {
                              "cidr": cidr,
                              "description": "${remoteVpc.name} CIDR Block ${i}",
                          }
                          for _, remoteVpc in get(oxr, "spec.remoteVpcs", [])
                          for i, cidr in get(remoteVpc, "cidrBlocks", [])
                          if all_true([
                              remoteVpc.name != r.name,
                          ])
                      ] + [
                          # Add any prefix list entries that need creating
                          e
                          for _, pl in get(r, "prefixLists", [])
                          for e in get(pl, "entries", [])
                          if all_true([
                              e,
                              get(pl, "outbound", False),
                              not get(pl, "id", False),
                              not get(pl, "blackhole", False),
                          ])
                      ],
                      "blackhole": [
                          e
                          for _, pl in get(r, "prefixLists", [])
                          for e in get(pl, "entries", [])
                          if all_true([
                              e,
                              get(pl, "outbound", False),
                              not get(pl, "id", False),
                              get(pl, "blackhole", False),
                          ])
                      ]
                  },
                  "tgw": {
                      "open": [
                          e
                          for _, pl in get(r, "prefixLists", [])
                          for e in get(pl, "entries", [])
                          if all_true([
                              e,
                              not get(pl, "outbound", True),
                              not get(pl, "id", False),
                              not get(pl, "blackhole", False),
                          ])

                      ],
                      "blackhole": [
                          e
                          for _, pl in get(r, "prefixLists", [])
                          for e in get(pl, "entries", [])
                          if all_true([
                              e,
                              not get(pl, "outbound", True),
                              not get(pl, "id", False),
                              get(pl, "blackhole", False),
                          ])
                      ]
                  }
              }
              for _, r in get(oxr, "spec.remoteVpcs", [])
          } | {
              "peering-${peer.name}": {
                  "remote": {
                      "open": [
                          e
                          for _, pl in get(peer, "prefixLists", [])
                          for e in get(pl, "entries", [])
                          if all_true([
                              e,
                              get(pl, "outbound", False),
                              not get(pl, "id", False),
                              not get(pl, "blackhole", False),
                          ])
                      ],
                      "blackhole": [
                          e
                          for _, pl in get(peer, "prefixLists", [])
                          for e in get(pl, "entries", [])
                          if all_true([
                              e,
                              get(pl, "outbound", False),
                              not get(pl, "id", False),
                              get(pl, "blackhole", False),
                          ])
                      ]
                  },
                  "tgw": {
                      "open": [
                          e
                          for _, pl in get(peer, "prefixLists", [])
                          for e in get(pl, "entries", [])
                          if all_true([
                              e,
                              not get(pl, "outbound", True),
                              not get(pl, "id", False),
                              not get(pl, "blackhole", False),
                          ])
                      ],
                      "blackhole": [
                          e
                          for _, pl in get(peer, "prefixLists", [])
                          for e in get(pl, "entries", [])
                          if all_true([
                              e,
                              not get(pl, "outbound", True),
                              not get(pl, "id", False),
                              get(pl, "blackhole", False),
                          ])
                      ]
                  }
              }
              for _, peer in get(oxr, "spec.peers", [])
          }

          mpl = lambda n : str, r: str, a: str, b: bool, isp: bool, e: [], p: {:} -> {:} {
              """
              Create a ManagedPrefixList object.

              n: The name of the ManagedPrefixList
              r: The region the ManagedPrefixList is in
              a: The address family of the ManagedPrefixList
              b: Whether the ManagedPrefixList is a blackhole
              isp: Whether the ManagedPrefixList is for a peering connection
              e: The entries for the ManagedPrefixList
              p: The ProviderConfigRef for the ManagedPrefixList

              Returns a ManagedPrefixList object.
              """
              _bh = "-bh" if b else ""
              _n = "${appName}-${region}-${n}${_bh}" if n != appName else "${appName}-${region}${_bh}"
              _isp = "-tgw" if isp else ""
              _resourceName = "mpl-${_n}" if not isp else "p-mpl-${_n}"
              {
                  "apiVersion": "xnetworks.crossplane.giantswarm.io/v1alpha1",
                  "kind": "ManagedPrefixList",
                  "metadata": {
                      "annotations": {
                          "krm.kcl.dev/composition-resource-name": _resourceName,
                          "krm.kcl.dev/ready": readystr(_resourceName),
                      },
                      "labels": labels | {
                          "vpcName" = n,
                      },
                  },
                  "spec": {
                      "addressFamily": a,
                      "claimRef": get(oxr, "spec.claimRef", {}),
                      "deletionPolicy": dp,
                      "entries": e,
                      "managementPolicies": mgmtPolicy,
                      "name": "${_n}${_isp}",
                      "region": r,
                      "providerConfigRef": p,
                      "tags": tags | {
                          "Name": "${_n}${_isp}",
                      },
                  }
              } if len(e) > 0 else {}
          }

          plr = lambda n : str, r: str, pid: str, aid: str, rid: str, b: bool, isp: bool, p: {:} -> {:} {
              """
              Create a TransitGatewayPrefixListReference object.

              n: The name of the PrefixList reference
              r: The region the PrefixList reference should be created in
              b: Whether the PrefixList is a blackhole
              pid: The PrefixListId for the PrefixList reference
              aid: The TransitGatewayAttachmentId for the PrefixList reference
              rid: The TransitGatewayRouteTableId for the PrefixList reference
              isp: Whether the PrefixList reference is for a peering connection
              p: The ProviderConfigRef for the PrefixList

              Returns a TransitGatewayPrefixListReference object.
              """
              {
                  _bh = "-bh" if b else ""
                  _n = "${appName}-${region}-${n}${_bh}" if n != appName else "${appName}-${region}${_bh}"
                  _resourceName = "tgwplr-${aid}" if not isp else "p-tgwplr-${aid}"
                  "apiVersion": "ec2.aws.upbound.io/v1beta1",
                  "kind": "TransitGatewayPrefixListReference",
                  "metadata": {
                      "annotations": {
                          "krm.kcl.dev/composition-resource-name": _resourceName,
                          "krm.kcl.dev/ready": readystr(_resourceName),
                      },
                      "labels": labels | {
                          "vpcName" = n,
                      } if not isp else {
                          "peerName" = n,
                      },
                  },
                  "spec": {
                      "deletionPolicy": dp,
                      "forProvider": {
                          "blackhole": b,
                          "prefixListId": pid,
                          "region": r,
                          "transitGatewayAttachmentId": aid,
                          "transitGatewayRouteTableId": rid,
                      },
                      "managementPolicies": mgmtPolicy,
                      "providerConfigRef": p,
                  }
              } if all_true([
                  pid, aid, rid,
              ]) else {}
          }

          remotePrefixListIds = {
              "${rVpc.name}": [
                  c for c in [
                      ocdsstatus("mpl-${appName}-${region}-${rVpc.name}", "id", "")
                      ocdsstatus("mpl-${appName}-${region}-${rVpc.name}-bh", "id", "")
                  ] if c
              ] + [
                  c for c in [
                      get(pl, "id", "")
                      for _, pl in get(rVpc, "prefixLists", [])
                      if all_true([
                          get(pl, "id", False),
                          get(pl, "outbound", True),
                      ])
                  ]
              ]
              for _, rVpc in get(oxr, "spec.remoteVpcs", [])
          }

          sharedPrefixLists: [str] = [
              c for r in [
                  [
                      ocdsstatus("mpl-${appName}-${region}-${rVpc.name}", "arn", ""),
                      ocdsstatus("mpl-${appName}-${region}-${rVpc.name}-bh", "arn", ""),
                  ]
                  for _, rVpc in get(oxr, "spec.remoteVpcs", [])
                  if rVpc.accountId != get(oxr, "spec.localVpc.accountId", "")
              ]
              for c in r if c
          ]

          # ManagedPrefixLists

          tgwLocalPrefixLists = [
              mpl(
                  appName,
                  region,
                  get(oxr, "spec.addressFamily", "IPv4"),
                  False,
                  True,
                  get(routingTables, "${appName}.tgw.open", {}),
                  pcr,
              ),
              mpl(
                  appName,
                  region,
                  get(oxr, "spec.addressFamily", "IPv4"),
                  True,
                  True,
                  get(routingTables, "${appName}.tgw.blackhole", {}),
                  pcr,
              ),
          ]

          tgwRemotePrefixLists = [
              i for r in [
                  [
                      mpl(
                          remoteVpc.name,
                          get(remoteVpc, "region", region),
                          get(remoteVpc, "addressFamily", "IPv4"),
                          False,
                          True,
                          get(routingTables, "${remoteVpc.name}.tgw.open", {}),
                          gpcr(remoteVpc),
                      ),
                      mpl(
                          remoteVpc.name,
                          get(remoteVpc, "region", region),
                          get(remoteVpc, "addressFamily", "IPv4"),
                          True,
                          True,
                          get(routingTables, "${remoteVpc.name}.tgw.blackhole", {}),
                          gpcr(remoteVpc),
                      ),
                  ]
                  for _, remoteVpc in get(oxr, "spec.remoteVpcs", [])
              ] for i in r
          ]

          tgwPeerPrefixLists = [
              i for r in [
                  [
                      mpl(
                          peer.name,
                          get(peer, "region", region),
                          get(peer, "addressFamily", "IPv4"),
                          False,
                          True,
                          get(routingTables, "${peer.name}.tgw.open", {}),
                          gpcr(peer),
                      ),
                      mpl(
                          peer.name,
                          get(peer, "region", region),
                          get(peer, "addressFamily", "IPv4"),
                          True,
                          True,
                          get(routingTables, "${peer.name}.tgw.blackhole", {}),
                          gpcr(peer),
                      ),
                  ]
                  for _, peer in get(oxr, "spec.peers", [])
              ] for i in r
          ]

          tgwLocalPrefixListIds = [
              c for c in [
                  {
                      "i" = ocdsstatus("p-mpl-${appName}-${region}", "id", False),
                      "b" = False,
                  },
                  {
                      "i" = ocdsstatus("p-mpl-${appName}-${region}-bh", "id", False),
                      "b" = True,
                  },
              ] + [
                  {
                      "i" = get(pl, "id", ""),
                      "b" = get(pl, "blackhole", False),
                  }
                  for _, pl in get(localVpc, "prefixLists", [])
                  if all_true([
                      get(pl, "id", False),
                      not get(pl, "outbound", True),
                  ])
              ] if c.i
          ]

          tgwRemotePrefixListIds = {
              "${remoteVpc.name}": [
                  c for c in [
                      {
                          "i" = ocdsstatus("p-mpl-${appName}-${region}-${remoteVpc.name}", "id", False),
                          "b" = False,
                      },
                      {
                          "i" = ocdsstatus("p-mpl-${appName}-${region}-${remoteVpc.name}-bh", "id", False),
                          "b" = True,
                      },
                  ] if c
              ] + [
                  c for c in [
                      {
                          "i" = get(pl, "id", ""),
                          "b" = get(pl, "blackhole", False),
                      }
                      for _, pl in get(remoteVpc, "prefixLists", [])
                      if all_true([
                          get(pl, "id", False),
                          not get(pl, "outbound", True),
                      ])
                  ]
              ]
              for _, remoteVpc in get(oxr, "spec.remoteVpcs", [])
          }

          tgwPeerPrefixListIds = {
              "${peer.name}": [
                  c for c in [
                      {
                          "i" = ocdsstatus("p-mpl-${appName}-${region}-${peer.name}", "id", False),
                          "b" = False
                      },
                      {
                          "i" = ocdsstatus("p-mpl-${appName}-${region}-${peer.name}-bh", "id", False),
                          "b" = True
                      },
                  ] if c
              ] + [
                  c for c in [
                      {
                          "i" = get(pl, "id", "")
                          "b" = get(pl, "blackhole", False),
                      }
                      for _, pl in get(peer, "prefixLists", [])
                      if all_true([
                          get(pl, "id", False),
                          not get(pl, "outbound", True),
                      ])
                  ]
              ]
              for _, peer in get(oxr, "spec.peers", [])
          }

          tgwManagedPrefixListIds = {
              "local": tgwLocalPrefixListIds,
              "remote": tgwRemotePrefixListIds,
              "peer": tgwPeerPrefixListIds,
          }

          tgwLocalPrefixListReferences = [
              plr(
                  appName,
                  region,
                  id.i,
                  get(localAttachmentIds, appName, ""),
                  tgwRouteTableId,
                  id.b,
                  True,
                  pcr,
              )
              for _, id in tgwLocalPrefixListIds
          ]

          tgwRemotePrefixListReferences = [
              plr(
                  rvpc.name,
                  region,
                  id.i,
                  get(remoteAttachementIds, rvpc.name, ""),
                  tgwRouteTableId,
                  id.b,
                  False,
                  gpcr(rvpc),
              )
              for _, rvpc in get(oxr, "spec.remoteVpcs", [])
              for _, id in get(tgwRemotePrefixListIds, rvpc.name, [])
          ]

          tgwPeerPrefixListReferences = [
              plr(
                  appName,
                  region,
                  id.i,
                  get(peerAttachmentIds, appName, ""),
                  tgwRouteTableId,
                  id.b,
                  False,
                  gpcr(peer),
              )
              for _, peer in get(oxr, "spec.peers", [])
              for _, id in peer
          ]

          _items = [
              i for r in [
                  tgwLocalPrefixLists, tgwRemotePrefixLists, tgwPeerPrefixLists,
                  tgwLocalPrefixListReferences, tgwRemotePrefixListReferences,
                  tgwPeerPrefixListReferences,
              ] for i in r if i
          ]

          items = _items
        target: ""
    step: function-kcl-tgwconfig
  - functionRef:
      name: function-kcl
    input:
      apiVersion: krm.kcl.dev/v1alpha1
      kind: KCLInput
      metadata:
        creationTimestamp: null
      spec:
        source: |-
          import regex
          oxr = option("params").oxr
          dxr = option("params").dxr
          ocds = option("params").ocds
          dcds = option("params").dcds

          exists = lambda x: any -> bool {
              """
              Check if a value exists.
              """
              x in list(ocds)
          }

          get = lambda x: {:}, y: str, d: any -> any {
              """
              Get an item from a dictionary using a dot separated path.
              If the item is not found, return a default value.
              """
              p = regex.split(y, "\.")
              c = p[0]
              y = ".".join(p[1:])
              x[c] if len(p) == 1 and c in x else d if c not in x else get(x[c], y, d)
          }

          gpcr = lambda x: {:} -> {:} {
              """
              Get the ProviderConfigRef from the given object

              If this is not set it will attempt to return the ProviderConfigRef from
              the Observed Composite Resource, and if that isn't set, will return an
              object with an empty name.
              """
              get(x, "providerConfigRef", get(oxr, "spec.providerConfigRef", {name: ""}))
          }

          ocdsstatus = lambda x: str, y: str, d: any -> any {
              """
              Get an item from the status of an ocds resource.
              """
              _x = None
              if get(ocds, "${x}.Resource.status.atProvider", False):
                  _x = get(ocds, "${x}.Resource.status.atProvider.${y}", d)
              else:
                  _x = get(ocds, "${x}.Resource.status.${y}", d)
              _x if _x else d
          }

          ready = lambda x: str -> bool {
              """
              Check if a value is ready.
              """
              conditionsReady = all_true([
                  get(c, "status", "False") == "True" for c in ocdsstatus(x, "conditions", [])
              ])

              ap = get(ocds, "${x}.Resource.status.atProvider", {})
              objectReady = any_true([
                  ocdsstatus(x, "ready", False),
                  len(list(ap)) > 0,
              ])

              all_true([
                  any_true([exists(x), conditionsReady]),
                  objectReady,
              ])
          }

          readystr = lambda x: str -> str {
              """
              Check if a value is ready.
              """
              "True" if ready(x) else "False"
          }

          allReady = lambda -> bool {
              """
              Check if all managed resources are ready.
              """
              all_true([
                  ready(x)
                  for x in list(ocds)
              ])
          }

          appName = get(oxr, "spec.claimRef.name", "")
          dp = get(oxr, "spec.deletionPolicy", "Delete")
          labels = get(oxr, "metadata.labels", {})
          localVpc = get(oxr, "spec.localVpc", {})
          pcr = get(oxr, "spec.providerConfigRef", {"name": "default"})
          region = get(oxr, "spec.localVpc.region", "eu-central-1")
          tags = get(oxr, "spec.tags", {}) | {
              "region": region,
          } | labels

          localAttachmentIds = {
              "${appName}": ocdsstatus("tgwa-${appName}-${region}", "id", "")
              for _ in [True]
              if ocdsstatus("tgwa-${appName}-${region}", "id", False)
          }

          mgmtPolicy = get(oxr, "spec.managementPolicies", [])

          publishConnection = get(oxr, "spec.publishConnectionDetailsTo", {})
          tgwArn = ocdsstatus("transitgateway-${appName}-${region}", "arn", False)
          tgwId = ocdsstatus("transitgateway-${appName}-${region}", "id", False)
          tgwRouteTableId = ocdsstatus("tgwrt-${appName}-${region}", "id", False)

          remoteAttachementIds = {
              "${remoteVpc.name}": ocdsstatus("tgwa-${appName}-${region}-${remoteVpc.name}", "id", "")
              for _, remoteVpc in get(oxr, "spec.remoteVpcs", [])
              if ocdsstatus("tgwa-${appName}-${region}-${remoteVpc.name}", "id", False)
          }

          peerAttachmentIds = {
              "${peer.name}": ocdsstatus("tgwa-${appName}-${region}-${peer.name}", "id", "")
              for _, peer in get(oxr, "spec.peers", [])
              if ocdsstatus("tgwa-${appName}-${region}-${peer.name}", "id", False)
          }

          routingTables = {
              "${appName}": {
                  "vpc": {
                      "open": [
                          # Outbound from the local VPC needs the remote cidr blocks
                          {
                              "cidr": cidr,
                              "description": "${remoteVpc.name} CIDR Block ${i}",
                          }
                          for _, remoteVpc in get(oxr, "spec.remoteVpcs", [])
                          for i, cidr in get(remoteVpc, "cidrBlocks", [])
                      ] + [
                          e
                          for _, pl in get(localVpc, "prefixLists", [])
                          for e in get(pl, "entries", [])
                          if all_true([
                              e,
                              get(pl, "outbound", False),
                              not get(pl, "id", False),
                              not get(pl, "blackhole", False),
                          ])
                      ],
                      "blackhole": [
                          e
                          for _, pl in get(localVpc, "prefixLists", [])
                          for e in get(pl, "entries", [])
                          if all_true([
                              e,
                              get(pl, "outbound", False),
                              not get(pl, "id", False),
                              get(pl, "blackhole", False),
                          ])
                      ]
                  },
                  "tgw": {
                      "open": [
                          e
                          for _, pl in get(localVpc, "prefixLists", [])
                          for e in get(pl, "entries", [])
                          if all_true([
                              e,
                              not get(pl, "outbound", True),
                              not get(pl, "id", False),
                              not get(pl, "blackhole", False),
                          ])
                      ],
                      "blackhole": [
                          e
                          for _, pl in get(localVpc, "prefixLists", [])
                          for e in get(pl, "entries", [])
                          if all_true([
                              e,
                              not get(pl, "outbound", True),
                              not get(pl, "id", False),
                              get(pl, "blackhole", False),
                          ])
                      ]
                  }
              }
          } | {
              "${r.name}": {
                  "vpc": {
                      "open": [
                          # Add the primary VPC cidr blocks
                          {
                              "cidr": cidr,
                              "description": "${appName} CIDR Block ${i}",
                          }
                          for i, cidr in get(localVpc, "cidrBlocks", [])
                      ] + [
                          # Add the remote VPC cidr blocks where the remote VPC is not the
                          # same as the current VPC
                          {
                              "cidr": cidr,
                              "description": "${remoteVpc.name} CIDR Block ${i}",
                          }
                          for _, remoteVpc in get(oxr, "spec.remoteVpcs", [])
                          for i, cidr in get(remoteVpc, "cidrBlocks", [])
                          if all_true([
                              remoteVpc.name != r.name,
                          ])
                      ] + [
                          # Add any prefix list entries that need creating
                          e
                          for _, pl in get(r, "prefixLists", [])
                          for e in get(pl, "entries", [])
                          if all_true([
                              e,
                              get(pl, "outbound", False),
                              not get(pl, "id", False),
                              not get(pl, "blackhole", False),
                          ])
                      ],
                      "blackhole": [
                          e
                          for _, pl in get(r, "prefixLists", [])
                          for e in get(pl, "entries", [])
                          if all_true([
                              e,
                              get(pl, "outbound", False),
                              not get(pl, "id", False),
                              get(pl, "blackhole", False),
                          ])
                      ]
                  },
                  "tgw": {
                      "open": [
                          e
                          for _, pl in get(r, "prefixLists", [])
                          for e in get(pl, "entries", [])
                          if all_true([
                              e,
                              not get(pl, "outbound", True),
                              not get(pl, "id", False),
                              not get(pl, "blackhole", False),
                          ])

                      ],
                      "blackhole": [
                          e
                          for _, pl in get(r, "prefixLists", [])
                          for e in get(pl, "entries", [])
                          if all_true([
                              e,
                              not get(pl, "outbound", True),
                              not get(pl, "id", False),
                              get(pl, "blackhole", False),
                          ])
                      ]
                  }
              }
              for _, r in get(oxr, "spec.remoteVpcs", [])
          } | {
              "peering-${peer.name}": {
                  "remote": {
                      "open": [
                          e
                          for _, pl in get(peer, "prefixLists", [])
                          for e in get(pl, "entries", [])
                          if all_true([
                              e,
                              get(pl, "outbound", False),
                              not get(pl, "id", False),
                              not get(pl, "blackhole", False),
                          ])
                      ],
                      "blackhole": [
                          e
                          for _, pl in get(peer, "prefixLists", [])
                          for e in get(pl, "entries", [])
                          if all_true([
                              e,
                              get(pl, "outbound", False),
                              not get(pl, "id", False),
                              get(pl, "blackhole", False),
                          ])
                      ]
                  },
                  "tgw": {
                      "open": [
                          e
                          for _, pl in get(peer, "prefixLists", [])
                          for e in get(pl, "entries", [])
                          if all_true([
                              e,
                              not get(pl, "outbound", True),
                              not get(pl, "id", False),
                              not get(pl, "blackhole", False),
                          ])
                      ],
                      "blackhole": [
                          e
                          for _, pl in get(peer, "prefixLists", [])
                          for e in get(pl, "entries", [])
                          if all_true([
                              e,
                              not get(pl, "outbound", True),
                              not get(pl, "id", False),
                              get(pl, "blackhole", False),
                          ])
                      ]
                  }
              }
              for _, peer in get(oxr, "spec.peers", [])
          }

          mpl = lambda n : str, r: str, a: str, b: bool, isp: bool, e: [], p: {:} -> {:} {
              """
              Create a ManagedPrefixList object.

              n: The name of the ManagedPrefixList
              r: The region the ManagedPrefixList is in
              a: The address family of the ManagedPrefixList
              b: Whether the ManagedPrefixList is a blackhole
              isp: Whether the ManagedPrefixList is for a peering connection
              e: The entries for the ManagedPrefixList
              p: The ProviderConfigRef for the ManagedPrefixList

              Returns a ManagedPrefixList object.
              """
              _bh = "-bh" if b else ""
              _n = "${appName}-${region}-${n}${_bh}" if n != appName else "${appName}-${region}${_bh}"
              _isp = "-tgw" if isp else ""
              _resourceName = "mpl-${_n}" if not isp else "p-mpl-${_n}"
              {
                  "apiVersion": "xnetworks.crossplane.giantswarm.io/v1alpha1",
                  "kind": "ManagedPrefixList",
                  "metadata": {
                      "annotations": {
                          "krm.kcl.dev/composition-resource-name": _resourceName,
                          "krm.kcl.dev/ready": readystr(_resourceName),
                      },
                      "labels": labels | {
                          "vpcName" = n,
                      },
                  },
                  "spec": {
                      "addressFamily": a,
                      "claimRef": get(oxr, "spec.claimRef", {}),
                      "deletionPolicy": dp,
                      "entries": e,
                      "managementPolicies": mgmtPolicy,
                      "name": "${_n}${_isp}",
                      "region": r,
                      "providerConfigRef": p,
                      "tags": tags | {
                          "Name": "${_n}${_isp}",
                      },
                  }
              } if len(e) > 0 else {}
          }

          plr = lambda n : str, r: str, pid: str, aid: str, rid: str, b: bool, isp: bool, p: {:} -> {:} {
              """
              Create a TransitGatewayPrefixListReference object.

              n: The name of the PrefixList reference
              r: The region the PrefixList reference should be created in
              b: Whether the PrefixList is a blackhole
              pid: The PrefixListId for the PrefixList reference
              aid: The TransitGatewayAttachmentId for the PrefixList reference
              rid: The TransitGatewayRouteTableId for the PrefixList reference
              isp: Whether the PrefixList reference is for a peering connection
              p: The ProviderConfigRef for the PrefixList

              Returns a TransitGatewayPrefixListReference object.
              """
              {
                  _bh = "-bh" if b else ""
                  _n = "${appName}-${region}-${n}${_bh}" if n != appName else "${appName}-${region}${_bh}"
                  _resourceName = "tgwplr-${aid}" if not isp else "p-tgwplr-${aid}"
                  "apiVersion": "ec2.aws.upbound.io/v1beta1",
                  "kind": "TransitGatewayPrefixListReference",
                  "metadata": {
                      "annotations": {
                          "krm.kcl.dev/composition-resource-name": _resourceName,
                          "krm.kcl.dev/ready": readystr(_resourceName),
                      },
                      "labels": labels | {
                          "vpcName" = n,
                      } if not isp else {
                          "peerName" = n,
                      },
                  },
                  "spec": {
                      "deletionPolicy": dp,
                      "forProvider": {
                          "blackhole": b,
                          "prefixListId": pid,
                          "region": r,
                          "transitGatewayAttachmentId": aid,
                          "transitGatewayRouteTableId": rid,
                      },
                      "managementPolicies": mgmtPolicy,
                      "providerConfigRef": p,
                  }
              } if all_true([
                  pid, aid, rid,
              ]) else {}
          }

          remotePrefixListIds = {
              "${rVpc.name}": [
                  c for c in [
                      ocdsstatus("mpl-${appName}-${region}-${rVpc.name}", "id", "")
                      ocdsstatus("mpl-${appName}-${region}-${rVpc.name}-bh", "id", "")
                  ] if c
              ] + [
                  c for c in [
                      get(pl, "id", "")
                      for _, pl in get(rVpc, "prefixLists", [])
                      if all_true([
                          get(pl, "id", False),
                          get(pl, "outbound", True),
                      ])
                  ]
              ]
              for _, rVpc in get(oxr, "spec.remoteVpcs", [])
          }

          sharedPrefixLists: [str] = [
              c for r in [
                  [
                      ocdsstatus("mpl-${appName}-${region}-${rVpc.name}", "arn", ""),
                      ocdsstatus("mpl-${appName}-${region}-${rVpc.name}-bh", "arn", ""),
                  ]
                  for _, rVpc in get(oxr, "spec.remoteVpcs", [])
                  if rVpc.accountId != get(oxr, "spec.localVpc.accountId", "")
              ]
              for c in r if c
          ]

          ramShareArn = ocdsstatus("ram-${appName}-${region}", "arn", False)
          ramShareId = ocdsstatus("ram-${appName}-${region}", "id", False)

          _items = [
              {
                  **dxr,
                  **{
                      "status": {
                          if tgwId:
                              "tgwId" = tgwId,
                          if tgwArn:
                              "tgwArn" = tgwArn,
                          if tgwRouteTableId:
                              "tgwRouteTableId" = tgwRouteTableId,
                          if localAttachmentIds:
                              "localAttachmentIds" = localAttachmentIds,
                          if remoteAttachementIds:
                              "remoteAttachmentIds" = remoteAttachementIds,
                          if ramShareId:
                              "ramShareId" = ramShareId,
                          if ramShareArn:
                              "ramShareArn" = ramShareArn,

                          if sharedPrefixLists:
                              "sharedPrefixLists" = sharedPrefixLists,

                          "ready" = allReady(),
                      }
                  }
              }
          ]

          items = _items
        target: ""
    step: function-kcl-patching
  - functionRef:
      name: function-kcl
    input:
      apiVersion: krm.kcl.dev/v1alpha1
      kind: KCLInput
      metadata:
        creationTimestamp: null
      spec:
        source: |-
          import regex
          oxr = option("params").oxr
          dxr = option("params").dxr
          ocds = option("params").ocds
          dcds = option("params").dcds

          exists = lambda x: any -> bool {
              """
              Check if a value exists.
              """
              x in list(ocds)
          }

          get = lambda x: {:}, y: str, d: any -> any {
              """
              Get an item from a dictionary using a dot separated path.
              If the item is not found, return a default value.
              """
              p = regex.split(y, "\.")
              c = p[0]
              y = ".".join(p[1:])
              x[c] if len(p) == 1 and c in x else d if c not in x else get(x[c], y, d)
          }

          gpcr = lambda x: {:} -> {:} {
              """
              Get the ProviderConfigRef from the given object

              If this is not set it will attempt to return the ProviderConfigRef from
              the Observed Composite Resource, and if that isn't set, will return an
              object with an empty name.
              """
              get(x, "providerConfigRef", get(oxr, "spec.providerConfigRef", {name: ""}))
          }

          ocdsstatus = lambda x: str, y: str, d: any -> any {
              """
              Get an item from the status of an ocds resource.
              """
              _x = None
              if get(ocds, "${x}.Resource.status.atProvider", False):
                  _x = get(ocds, "${x}.Resource.status.atProvider.${y}", d)
              else:
                  _x = get(ocds, "${x}.Resource.status.${y}", d)
              _x if _x else d
          }

          ready = lambda x: str -> bool {
              """
              Check if a value is ready.
              """
              conditionsReady = all_true([
                  get(c, "status", "False") == "True" for c in ocdsstatus(x, "conditions", [])
              ])

              ap = get(ocds, "${x}.Resource.status.atProvider", {})
              objectReady = any_true([
                  ocdsstatus(x, "ready", False),
                  len(list(ap)) > 0,
              ])

              all_true([
                  any_true([exists(x), conditionsReady]),
                  objectReady,
              ])
          }

          readystr = lambda x: str -> str {
              """
              Check if a value is ready.
              """
              "True" if ready(x) else "False"
          }

          allReady = lambda -> bool {
              """
              Check if all managed resources are ready.
              """
              all_true([
                  ready(x)
                  for x in list(ocds)
              ])
          }

          appName = get(oxr, "spec.claimRef.name", "")
          dp = get(oxr, "spec.deletionPolicy", "Delete")
          labels = get(oxr, "metadata.labels", {})
          localVpc = get(oxr, "spec.localVpc", {})
          pcr = get(oxr, "spec.providerConfigRef", {"name": "default"})
          region = get(oxr, "spec.localVpc.region", "eu-central-1")
          tags = get(oxr, "spec.tags", {}) | {
              "region": region,
          } | labels

          localAttachmentIds = {
              "${appName}": ocdsstatus("tgwa-${appName}-${region}", "id", "")
              for _ in [True]
              if ocdsstatus("tgwa-${appName}-${region}", "id", False)
          }

          mgmtPolicy = get(oxr, "spec.managementPolicies", [])

          publishConnection = get(oxr, "spec.publishConnectionDetailsTo", {})
          tgwArn = ocdsstatus("transitgateway-${appName}-${region}", "arn", False)
          tgwId = ocdsstatus("transitgateway-${appName}-${region}", "id", False)
          tgwRouteTableId = ocdsstatus("tgwrt-${appName}-${region}", "id", False)

          remoteAttachementIds = {
              "${remoteVpc.name}": ocdsstatus("tgwa-${appName}-${region}-${remoteVpc.name}", "id", "")
              for _, remoteVpc in get(oxr, "spec.remoteVpcs", [])
              if ocdsstatus("tgwa-${appName}-${region}-${remoteVpc.name}", "id", False)
          }

          peerAttachmentIds = {
              "${peer.name}": ocdsstatus("tgwa-${appName}-${region}-${peer.name}", "id", "")
              for _, peer in get(oxr, "spec.peers", [])
              if ocdsstatus("tgwa-${appName}-${region}-${peer.name}", "id", False)
          }

          routingTables = {
              "${appName}": {
                  "vpc": {
                      "open": [
                          # Outbound from the local VPC needs the remote cidr blocks
                          {
                              "cidr": cidr,
                              "description": "${remoteVpc.name} CIDR Block ${i}",
                          }
                          for _, remoteVpc in get(oxr, "spec.remoteVpcs", [])
                          for i, cidr in get(remoteVpc, "cidrBlocks", [])
                      ] + [
                          e
                          for _, pl in get(localVpc, "prefixLists", [])
                          for e in get(pl, "entries", [])
                          if all_true([
                              e,
                              get(pl, "outbound", False),
                              not get(pl, "id", False),
                              not get(pl, "blackhole", False),
                          ])
                      ],
                      "blackhole": [
                          e
                          for _, pl in get(localVpc, "prefixLists", [])
                          for e in get(pl, "entries", [])
                          if all_true([
                              e,
                              get(pl, "outbound", False),
                              not get(pl, "id", False),
                              get(pl, "blackhole", False),
                          ])
                      ]
                  },
                  "tgw": {
                      "open": [
                          e
                          for _, pl in get(localVpc, "prefixLists", [])
                          for e in get(pl, "entries", [])
                          if all_true([
                              e,
                              not get(pl, "outbound", True),
                              not get(pl, "id", False),
                              not get(pl, "blackhole", False),
                          ])
                      ],
                      "blackhole": [
                          e
                          for _, pl in get(localVpc, "prefixLists", [])
                          for e in get(pl, "entries", [])
                          if all_true([
                              e,
                              not get(pl, "outbound", True),
                              not get(pl, "id", False),
                              get(pl, "blackhole", False),
                          ])
                      ]
                  }
              }
          } | {
              "${r.name}": {
                  "vpc": {
                      "open": [
                          # Add the primary VPC cidr blocks
                          {
                              "cidr": cidr,
                              "description": "${appName} CIDR Block ${i}",
                          }
                          for i, cidr in get(localVpc, "cidrBlocks", [])
                      ] + [
                          # Add the remote VPC cidr blocks where the remote VPC is not the
                          # same as the current VPC
                          {
                              "cidr": cidr,
                              "description": "${remoteVpc.name} CIDR Block ${i}",
                          }
                          for _, remoteVpc in get(oxr, "spec.remoteVpcs", [])
                          for i, cidr in get(remoteVpc, "cidrBlocks", [])
                          if all_true([
                              remoteVpc.name != r.name,
                          ])
                      ] + [
                          # Add any prefix list entries that need creating
                          e
                          for _, pl in get(r, "prefixLists", [])
                          for e in get(pl, "entries", [])
                          if all_true([
                              e,
                              get(pl, "outbound", False),
                              not get(pl, "id", False),
                              not get(pl, "blackhole", False),
                          ])
                      ],
                      "blackhole": [
                          e
                          for _, pl in get(r, "prefixLists", [])
                          for e in get(pl, "entries", [])
                          if all_true([
                              e,
                              get(pl, "outbound", False),
                              not get(pl, "id", False),
                              get(pl, "blackhole", False),
                          ])
                      ]
                  },
                  "tgw": {
                      "open": [
                          e
                          for _, pl in get(r, "prefixLists", [])
                          for e in get(pl, "entries", [])
                          if all_true([
                              e,
                              not get(pl, "outbound", True),
                              not get(pl, "id", False),
                              not get(pl, "blackhole", False),
                          ])

                      ],
                      "blackhole": [
                          e
                          for _, pl in get(r, "prefixLists", [])
                          for e in get(pl, "entries", [])
                          if all_true([
                              e,
                              not get(pl, "outbound", True),
                              not get(pl, "id", False),
                              get(pl, "blackhole", False),
                          ])
                      ]
                  }
              }
              for _, r in get(oxr, "spec.remoteVpcs", [])
          } | {
              "peering-${peer.name}": {
                  "remote": {
                      "open": [
                          e
                          for _, pl in get(peer, "prefixLists", [])
                          for e in get(pl, "entries", [])
                          if all_true([
                              e,
                              get(pl, "outbound", False),
                              not get(pl, "id", False),
                              not get(pl, "blackhole", False),
                          ])
                      ],
                      "blackhole": [
                          e
                          for _, pl in get(peer, "prefixLists", [])
                          for e in get(pl, "entries", [])
                          if all_true([
                              e,
                              get(pl, "outbound", False),
                              not get(pl, "id", False),
                              get(pl, "blackhole", False),
                          ])
                      ]
                  },
                  "tgw": {
                      "open": [
                          e
                          for _, pl in get(peer, "prefixLists", [])
                          for e in get(pl, "entries", [])
                          if all_true([
                              e,
                              not get(pl, "outbound", True),
                              not get(pl, "id", False),
                              not get(pl, "blackhole", False),
                          ])
                      ],
                      "blackhole": [
                          e
                          for _, pl in get(peer, "prefixLists", [])
                          for e in get(pl, "entries", [])
                          if all_true([
                              e,
                              not get(pl, "outbound", True),
                              not get(pl, "id", False),
                              get(pl, "blackhole", False),
                          ])
                      ]
                  }
              }
              for _, peer in get(oxr, "spec.peers", [])
          }

          mpl = lambda n : str, r: str, a: str, b: bool, isp: bool, e: [], p: {:} -> {:} {
              """
              Create a ManagedPrefixList object.

              n: The name of the ManagedPrefixList
              r: The region the ManagedPrefixList is in
              a: The address family of the ManagedPrefixList
              b: Whether the ManagedPrefixList is a blackhole
              isp: Whether the ManagedPrefixList is for a peering connection
              e: The entries for the ManagedPrefixList
              p: The ProviderConfigRef for the ManagedPrefixList

              Returns a ManagedPrefixList object.
              """
              _bh = "-bh" if b else ""
              _n = "${appName}-${region}-${n}${_bh}" if n != appName else "${appName}-${region}${_bh}"
              _isp = "-tgw" if isp else ""
              _resourceName = "mpl-${_n}" if not isp else "p-mpl-${_n}"
              {
                  "apiVersion": "xnetworks.crossplane.giantswarm.io/v1alpha1",
                  "kind": "ManagedPrefixList",
                  "metadata": {
                      "annotations": {
                          "krm.kcl.dev/composition-resource-name": _resourceName,
                          "krm.kcl.dev/ready": readystr(_resourceName),
                      },
                      "labels": labels | {
                          "vpcName" = n,
                      },
                  },
                  "spec": {
                      "addressFamily": a,
                      "claimRef": get(oxr, "spec.claimRef", {}),
                      "deletionPolicy": dp,
                      "entries": e,
                      "managementPolicies": mgmtPolicy,
                      "name": "${_n}${_isp}",
                      "region": r,
                      "providerConfigRef": p,
                      "tags": tags | {
                          "Name": "${_n}${_isp}",
                      },
                  }
              } if len(e) > 0 else {}
          }

          plr = lambda n : str, r: str, pid: str, aid: str, rid: str, b: bool, isp: bool, p: {:} -> {:} {
              """
              Create a TransitGatewayPrefixListReference object.

              n: The name of the PrefixList reference
              r: The region the PrefixList reference should be created in
              b: Whether the PrefixList is a blackhole
              pid: The PrefixListId for the PrefixList reference
              aid: The TransitGatewayAttachmentId for the PrefixList reference
              rid: The TransitGatewayRouteTableId for the PrefixList reference
              isp: Whether the PrefixList reference is for a peering connection
              p: The ProviderConfigRef for the PrefixList

              Returns a TransitGatewayPrefixListReference object.
              """
              {
                  _bh = "-bh" if b else ""
                  _n = "${appName}-${region}-${n}${_bh}" if n != appName else "${appName}-${region}${_bh}"
                  _resourceName = "tgwplr-${aid}" if not isp else "p-tgwplr-${aid}"
                  "apiVersion": "ec2.aws.upbound.io/v1beta1",
                  "kind": "TransitGatewayPrefixListReference",
                  "metadata": {
                      "annotations": {
                          "krm.kcl.dev/composition-resource-name": _resourceName,
                          "krm.kcl.dev/ready": readystr(_resourceName),
                      },
                      "labels": labels | {
                          "vpcName" = n,
                      } if not isp else {
                          "peerName" = n,
                      },
                  },
                  "spec": {
                      "deletionPolicy": dp,
                      "forProvider": {
                          "blackhole": b,
                          "prefixListId": pid,
                          "region": r,
                          "transitGatewayAttachmentId": aid,
                          "transitGatewayRouteTableId": rid,
                      },
                      "managementPolicies": mgmtPolicy,
                      "providerConfigRef": p,
                  }
              } if all_true([
                  pid, aid, rid,
              ]) else {}
          }

          remotePrefixListIds = {
              "${rVpc.name}": [
                  c for c in [
                      ocdsstatus("mpl-${appName}-${region}-${rVpc.name}", "id", "")
                      ocdsstatus("mpl-${appName}-${region}-${rVpc.name}-bh", "id", "")
                  ] if c
              ] + [
                  c for c in [
                      get(pl, "id", "")
                      for _, pl in get(rVpc, "prefixLists", [])
                      if all_true([
                          get(pl, "id", False),
                          get(pl, "outbound", True),
                      ])
                  ]
              ]
              for _, rVpc in get(oxr, "spec.remoteVpcs", [])
          }

          sharedPrefixLists: [str] = [
              c for r in [
                  [
                      ocdsstatus("mpl-${appName}-${region}-${rVpc.name}", "arn", ""),
                      ocdsstatus("mpl-${appName}-${region}-${rVpc.name}-bh", "arn", ""),
                  ]
                  for _, rVpc in get(oxr, "spec.remoteVpcs", [])
                  if rVpc.accountId != get(oxr, "spec.localVpc.accountId", "")
              ]
              for c in r if c
          ]

          # Transit Gateway Peering

          peerAttachments = [
              {
                  _resourceName = "tgw-peer-${appName}-${region}-${peer.name}"
                  "apiVersion": "ec2.aws.upbound.io/v1beta1"
                  "kind": "TransitGatewayPeeringAttachment"
                  "metadata": {
                      "annotations": {
                          "krm.kcl.dev/composition-resource-name" = _resourceName
                          "krm.kcl.dev/ready" = readystr(_resourceName)
                      }
                      "labels": labels | {
                          "vpcName": peer.name
                      }
                  }
                  "spec": {
                      "deletionPolicy": get(oxr, "spec.deletionPolicy", "Delete"),
                      "forProvider": {
                          if get(peer, "dynamicRouting", None) != None:
                              "options": {
                                  "dynamicRouting": "enabled" if peer.dynamicRouting else "disabled"
                              }
                          "peerAccountId": peer.accountId,
                          "peerRegion": peer.region,
                          "peerTransitGatewayId": peer.tgwId,
                          "region": region,
                          "tags": tags | {
                              Name: "${appName}-${region}-${peer.name}"
                          }
                          "transitGatewayId": tgwId,
                      }
                      "managementPolicies": mgmtPolicy,
                      "providerConfigRef": gpcr(peer)
                  }
              }
              for peer in get(oxr, "spec.peers", [])
              if tgwId
          ]

          # If the peering attachment is in a remote region or account,
          # we need to accept the peering attachment via a peering accepter.
          peeringAccepters = [
              {
                  _resourceName = "tgw-peer-accepter-${appName}-${region}-${id}"
                  "apiVersion": "ec2.aws.upbound.io/v1beta1"
                  "kind": "TransitGatewayPeeringAttachmentAccepter"
                  "metadata": {
                      "annotations": {
                          "krm.kcl.dev/composition-resource-name": _resourceName
                          "krm.kcl.dev/ready" = readystr(_resourceName)
                      }
                  }
                  "spec": {
                      "deletionPolicy": dp
                      "forProvider": {
                          "region": region,
                          "transitGatewayAttachmentId": id,
                      }
                      "managementPolicies": mgmtPolicy,
                      "providerConfigRef": pcr
                  }
              }
              for _, id in peerAttachmentIds
              if len(list(peerAttachmentIds)) > 0
          ]

          peerPrefixLists = [
              i for r in [
                  [
                      mpl(
                          peer.name,
                          get(peer, "region", region),
                          get(peer, "addressFamily", "IPv4"),
                          False,
                          True,
                          get(routingTables, "${peer.name}.remote.open", {}),
                          gpcr(peer),
                      ),
                      mpl(
                          peer.name,
                          get(peer, "region", region),
                          get(peer, "addressFamily", "IPv4"),
                          True,
                          True,
                          get(routingTables, "${peer.name}.remote.blackhole", {}),
                          gpcr(peer),
                      ),
                  ]
                  for _, peer in get(oxr, "spec.peers", [])
              ] for i in r
          ]

          peerPrefixListIds = {
              "${peer.name}": [
                  c for c in [
                      {
                          "id":  ocdsstatus("pmpl-${appName}-${region}-${peer.name}", "id", ""),
                          "blackhole": False,
                      },
                      {
                          "id":  ocdsstatus("pmpl-${appName}-${region}-${peer.name}-bh", "id", ""),
                          "blackhole": True,
                      }
                  ] + [
                      {
                          "id": get(pl, "id", False),
                          "blackhole": get(pl, "blackhole", False),
                      }
                      for i, pl in get(peer, "prefixLists", [])
                  ]
              ]
              for _, peer in get(oxr, "spec.peers", [])
              if all_true([
                  tgwId,
                  not get(peer, "id", False),
              ])
          }

          # These create the prefix list references on the remote peer, not on the
          # transit gateway created as part of this composition - see tgw/resources for that
          peerPrefixListReferences = [
              {
                  _id = peer.id
                  _bh = "-bh" if pl.blackhole else ""
                  _resourceName = "ptrgwpol-${appName}-${region}-${_id}${_bh}-${i}"
                  "apiVersion": "ec2.aws.upbound.io/v1beta1"
                  "kind": "TransitGatewayPrefixListReference"
                  "metadata": {
                      "annotations": {
                          "krm.kcl.dev/composition-resource-name" = _resourceName
                          "krm.kcl.dev/ready" = readystr(_resourceName)
                      }
                      "labels": labels | {
                          "peerName": peer.name
                      }
                  }
                  "spec": {
                      "deletionPolicy": dp
                      "forProvider": {
                          "blackhole": pl.blackhole,
                          "prefixListId": pl.id,
                          "region": region,
                          "tags": tags | {
                              Name: _resourceName,
                          }
                          "transitGatewayAttachmentId": _id,
                          "transitGatewayRouteTableId": peer.id,
                      }
                      "managementPolicies": mgmtPolicy,
                      "providerConfigRef": pcr,
                  }
              }
              for _, peer in get(oxr, "spec.peers", [])
              for i, pl in get(peerPrefixListIds, peer.name, {})
              if all_true([
                  tgwId, peer,
                  get(peer, "id", False),
                  get(peerPrefixListIds, peer.name, False),
              ])
          ]

          _items = [
              i for r in [
                  peerAttachments, peeringAccepters,
                  peerPrefixLists,
                  peerPrefixListReferences,
          ] for i in r]

          items = _items
        target: ""
    step: function-kcl-peering
  - functionRef:
      name: function-kcl
    input:
      apiVersion: krm.kcl.dev/v1alpha1
      kind: KCLInput
      metadata:
        creationTimestamp: null
      spec:
        source: |-
          import regex
          oxr = option("params").oxr
          dxr = option("params").dxr
          ocds = option("params").ocds
          dcds = option("params").dcds

          exists = lambda x: any -> bool {
              """
              Check if a value exists.
              """
              x in list(ocds)
          }

          get = lambda x: {:}, y: str, d: any -> any {
              """
              Get an item from a dictionary using a dot separated path.
              If the item is not found, return a default value.
              """
              p = regex.split(y, "\.")
              c = p[0]
              y = ".".join(p[1:])
              x[c] if len(p) == 1 and c in x else d if c not in x else get(x[c], y, d)
          }

          gpcr = lambda x: {:} -> {:} {
              """
              Get the ProviderConfigRef from the given object

              If this is not set it will attempt to return the ProviderConfigRef from
              the Observed Composite Resource, and if that isn't set, will return an
              object with an empty name.
              """
              get(x, "providerConfigRef", get(oxr, "spec.providerConfigRef", {name: ""}))
          }

          ocdsstatus = lambda x: str, y: str, d: any -> any {
              """
              Get an item from the status of an ocds resource.
              """
              _x = None
              if get(ocds, "${x}.Resource.status.atProvider", False):
                  _x = get(ocds, "${x}.Resource.status.atProvider.${y}", d)
              else:
                  _x = get(ocds, "${x}.Resource.status.${y}", d)
              _x if _x else d
          }

          ready = lambda x: str -> bool {
              """
              Check if a value is ready.
              """
              conditionsReady = all_true([
                  get(c, "status", "False") == "True" for c in ocdsstatus(x, "conditions", [])
              ])

              ap = get(ocds, "${x}.Resource.status.atProvider", {})
              objectReady = any_true([
                  ocdsstatus(x, "ready", False),
                  len(list(ap)) > 0,
              ])

              all_true([
                  any_true([exists(x), conditionsReady]),
                  objectReady,
              ])
          }

          readystr = lambda x: str -> str {
              """
              Check if a value is ready.
              """
              "True" if ready(x) else "False"
          }

          allReady = lambda -> bool {
              """
              Check if all managed resources are ready.
              """
              all_true([
                  ready(x)
                  for x in list(ocds)
              ])
          }

          appName = get(oxr, "spec.claimRef.name", "")
          dp = get(oxr, "spec.deletionPolicy", "Delete")
          labels = get(oxr, "metadata.labels", {})
          localVpc = get(oxr, "spec.localVpc", {})
          pcr = get(oxr, "spec.providerConfigRef", {"name": "default"})
          region = get(oxr, "spec.localVpc.region", "eu-central-1")
          tags = get(oxr, "spec.tags", {}) | {
              "region": region,
          } | labels

          localAttachmentIds = {
              "${appName}": ocdsstatus("tgwa-${appName}-${region}", "id", "")
              for _ in [True]
              if ocdsstatus("tgwa-${appName}-${region}", "id", False)
          }

          mgmtPolicy = get(oxr, "spec.managementPolicies", [])

          publishConnection = get(oxr, "spec.publishConnectionDetailsTo", {})
          tgwArn = ocdsstatus("transitgateway-${appName}-${region}", "arn", False)
          tgwId = ocdsstatus("transitgateway-${appName}-${region}", "id", False)
          tgwRouteTableId = ocdsstatus("tgwrt-${appName}-${region}", "id", False)

          remoteAttachementIds = {
              "${remoteVpc.name}": ocdsstatus("tgwa-${appName}-${region}-${remoteVpc.name}", "id", "")
              for _, remoteVpc in get(oxr, "spec.remoteVpcs", [])
              if ocdsstatus("tgwa-${appName}-${region}-${remoteVpc.name}", "id", False)
          }

          peerAttachmentIds = {
              "${peer.name}": ocdsstatus("tgwa-${appName}-${region}-${peer.name}", "id", "")
              for _, peer in get(oxr, "spec.peers", [])
              if ocdsstatus("tgwa-${appName}-${region}-${peer.name}", "id", False)
          }

          routingTables = {
              "${appName}": {
                  "vpc": {
                      "open": [
                          # Outbound from the local VPC needs the remote cidr blocks
                          {
                              "cidr": cidr,
                              "description": "${remoteVpc.name} CIDR Block ${i}",
                          }
                          for _, remoteVpc in get(oxr, "spec.remoteVpcs", [])
                          for i, cidr in get(remoteVpc, "cidrBlocks", [])
                      ] + [
                          e
                          for _, pl in get(localVpc, "prefixLists", [])
                          for e in get(pl, "entries", [])
                          if all_true([
                              e,
                              get(pl, "outbound", False),
                              not get(pl, "id", False),
                              not get(pl, "blackhole", False),
                          ])
                      ],
                      "blackhole": [
                          e
                          for _, pl in get(localVpc, "prefixLists", [])
                          for e in get(pl, "entries", [])
                          if all_true([
                              e,
                              get(pl, "outbound", False),
                              not get(pl, "id", False),
                              get(pl, "blackhole", False),
                          ])
                      ]
                  },
                  "tgw": {
                      "open": [
                          e
                          for _, pl in get(localVpc, "prefixLists", [])
                          for e in get(pl, "entries", [])
                          if all_true([
                              e,
                              not get(pl, "outbound", True),
                              not get(pl, "id", False),
                              not get(pl, "blackhole", False),
                          ])
                      ],
                      "blackhole": [
                          e
                          for _, pl in get(localVpc, "prefixLists", [])
                          for e in get(pl, "entries", [])
                          if all_true([
                              e,
                              not get(pl, "outbound", True),
                              not get(pl, "id", False),
                              get(pl, "blackhole", False),
                          ])
                      ]
                  }
              }
          } | {
              "${r.name}": {
                  "vpc": {
                      "open": [
                          # Add the primary VPC cidr blocks
                          {
                              "cidr": cidr,
                              "description": "${appName} CIDR Block ${i}",
                          }
                          for i, cidr in get(localVpc, "cidrBlocks", [])
                      ] + [
                          # Add the remote VPC cidr blocks where the remote VPC is not the
                          # same as the current VPC
                          {
                              "cidr": cidr,
                              "description": "${remoteVpc.name} CIDR Block ${i}",
                          }
                          for _, remoteVpc in get(oxr, "spec.remoteVpcs", [])
                          for i, cidr in get(remoteVpc, "cidrBlocks", [])
                          if all_true([
                              remoteVpc.name != r.name,
                          ])
                      ] + [
                          # Add any prefix list entries that need creating
                          e
                          for _, pl in get(r, "prefixLists", [])
                          for e in get(pl, "entries", [])
                          if all_true([
                              e,
                              get(pl, "outbound", False),
                              not get(pl, "id", False),
                              not get(pl, "blackhole", False),
                          ])
                      ],
                      "blackhole": [
                          e
                          for _, pl in get(r, "prefixLists", [])
                          for e in get(pl, "entries", [])
                          if all_true([
                              e,
                              get(pl, "outbound", False),
                              not get(pl, "id", False),
                              get(pl, "blackhole", False),
                          ])
                      ]
                  },
                  "tgw": {
                      "open": [
                          e
                          for _, pl in get(r, "prefixLists", [])
                          for e in get(pl, "entries", [])
                          if all_true([
                              e,
                              not get(pl, "outbound", True),
                              not get(pl, "id", False),
                              not get(pl, "blackhole", False),
                          ])

                      ],
                      "blackhole": [
                          e
                          for _, pl in get(r, "prefixLists", [])
                          for e in get(pl, "entries", [])
                          if all_true([
                              e,
                              not get(pl, "outbound", True),
                              not get(pl, "id", False),
                              get(pl, "blackhole", False),
                          ])
                      ]
                  }
              }
              for _, r in get(oxr, "spec.remoteVpcs", [])
          } | {
              "peering-${peer.name}": {
                  "remote": {
                      "open": [
                          e
                          for _, pl in get(peer, "prefixLists", [])
                          for e in get(pl, "entries", [])
                          if all_true([
                              e,
                              get(pl, "outbound", False),
                              not get(pl, "id", False),
                              not get(pl, "blackhole", False),
                          ])
                      ],
                      "blackhole": [
                          e
                          for _, pl in get(peer, "prefixLists", [])
                          for e in get(pl, "entries", [])
                          if all_true([
                              e,
                              get(pl, "outbound", False),
                              not get(pl, "id", False),
                              get(pl, "blackhole", False),
                          ])
                      ]
                  },
                  "tgw": {
                      "open": [
                          e
                          for _, pl in get(peer, "prefixLists", [])
                          for e in get(pl, "entries", [])
                          if all_true([
                              e,
                              not get(pl, "outbound", True),
                              not get(pl, "id", False),
                              not get(pl, "blackhole", False),
                          ])
                      ],
                      "blackhole": [
                          e
                          for _, pl in get(peer, "prefixLists", [])
                          for e in get(pl, "entries", [])
                          if all_true([
                              e,
                              not get(pl, "outbound", True),
                              not get(pl, "id", False),
                              get(pl, "blackhole", False),
                          ])
                      ]
                  }
              }
              for _, peer in get(oxr, "spec.peers", [])
          }

          mpl = lambda n : str, r: str, a: str, b: bool, isp: bool, e: [], p: {:} -> {:} {
              """
              Create a ManagedPrefixList object.

              n: The name of the ManagedPrefixList
              r: The region the ManagedPrefixList is in
              a: The address family of the ManagedPrefixList
              b: Whether the ManagedPrefixList is a blackhole
              isp: Whether the ManagedPrefixList is for a peering connection
              e: The entries for the ManagedPrefixList
              p: The ProviderConfigRef for the ManagedPrefixList

              Returns a ManagedPrefixList object.
              """
              _bh = "-bh" if b else ""
              _n = "${appName}-${region}-${n}${_bh}" if n != appName else "${appName}-${region}${_bh}"
              _isp = "-tgw" if isp else ""
              _resourceName = "mpl-${_n}" if not isp else "p-mpl-${_n}"
              {
                  "apiVersion": "xnetworks.crossplane.giantswarm.io/v1alpha1",
                  "kind": "ManagedPrefixList",
                  "metadata": {
                      "annotations": {
                          "krm.kcl.dev/composition-resource-name": _resourceName,
                          "krm.kcl.dev/ready": readystr(_resourceName),
                      },
                      "labels": labels | {
                          "vpcName" = n,
                      },
                  },
                  "spec": {
                      "addressFamily": a,
                      "claimRef": get(oxr, "spec.claimRef", {}),
                      "deletionPolicy": dp,
                      "entries": e,
                      "managementPolicies": mgmtPolicy,
                      "name": "${_n}${_isp}",
                      "region": r,
                      "providerConfigRef": p,
                      "tags": tags | {
                          "Name": "${_n}${_isp}",
                      },
                  }
              } if len(e) > 0 else {}
          }

          plr = lambda n : str, r: str, pid: str, aid: str, rid: str, b: bool, isp: bool, p: {:} -> {:} {
              """
              Create a TransitGatewayPrefixListReference object.

              n: The name of the PrefixList reference
              r: The region the PrefixList reference should be created in
              b: Whether the PrefixList is a blackhole
              pid: The PrefixListId for the PrefixList reference
              aid: The TransitGatewayAttachmentId for the PrefixList reference
              rid: The TransitGatewayRouteTableId for the PrefixList reference
              isp: Whether the PrefixList reference is for a peering connection
              p: The ProviderConfigRef for the PrefixList

              Returns a TransitGatewayPrefixListReference object.
              """
              {
                  _bh = "-bh" if b else ""
                  _n = "${appName}-${region}-${n}${_bh}" if n != appName else "${appName}-${region}${_bh}"
                  _resourceName = "tgwplr-${aid}" if not isp else "p-tgwplr-${aid}"
                  "apiVersion": "ec2.aws.upbound.io/v1beta1",
                  "kind": "TransitGatewayPrefixListReference",
                  "metadata": {
                      "annotations": {
                          "krm.kcl.dev/composition-resource-name": _resourceName,
                          "krm.kcl.dev/ready": readystr(_resourceName),
                      },
                      "labels": labels | {
                          "vpcName" = n,
                      } if not isp else {
                          "peerName" = n,
                      },
                  },
                  "spec": {
                      "deletionPolicy": dp,
                      "forProvider": {
                          "blackhole": b,
                          "prefixListId": pid,
                          "region": r,
                          "transitGatewayAttachmentId": aid,
                          "transitGatewayRouteTableId": rid,
                      },
                      "managementPolicies": mgmtPolicy,
                      "providerConfigRef": p,
                  }
              } if all_true([
                  pid, aid, rid,
              ]) else {}
          }

          remotePrefixListIds = {
              "${rVpc.name}": [
                  c for c in [
                      ocdsstatus("mpl-${appName}-${region}-${rVpc.name}", "id", "")
                      ocdsstatus("mpl-${appName}-${region}-${rVpc.name}-bh", "id", "")
                  ] if c
              ] + [
                  c for c in [
                      get(pl, "id", "")
                      for _, pl in get(rVpc, "prefixLists", [])
                      if all_true([
                          get(pl, "id", False),
                          get(pl, "outbound", True),
                      ])
                  ]
              ]
              for _, rVpc in get(oxr, "spec.remoteVpcs", [])
          }

          sharedPrefixLists: [str] = [
              c for r in [
                  [
                      ocdsstatus("mpl-${appName}-${region}-${rVpc.name}", "arn", ""),
                      ocdsstatus("mpl-${appName}-${region}-${rVpc.name}-bh", "arn", ""),
                  ]
                  for _, rVpc in get(oxr, "spec.remoteVpcs", [])
                  if rVpc.accountId != get(oxr, "spec.localVpc.accountId", "")
              ]
              for c in r if c
          ]

          # Optional RAM

          # If we're building as part of the VPC, we should retrieve the prefix lists from
          # the transit gateway resource.
          #
          # If this is enabled in the transit gateway, they need to come fdrom the OXR
          sharedMpl = ocdsstatus("transitgw", "sharedPrefixLists", get(oxr, "status.sharedPrefixLists", []))

          # shared subnets is a future extension - I've not figured out
          # how best to specify this yet.
          sharedSubnets = get(oxr, "status.sharedSubnets", [])

          principals = [
              {
                  "principal": get(oxr, "status.vpcs.${rvpc.name}.owner", ""),
                  "providerConfigRef": get(rvpc, "providerConfigRef", {"name": "default"}),
              }
              for _, rvpc in get(oxr, "spec.transitGateway.remoteVpcs", [])
              if all_true([
                  get(oxr, "status.vpcs.${rvpc.name}.owner", False) != get(oxr, "status.vpcs.self.owner", False),
                  get(rvpc, "providerConfigRef", False),
              ])
          ] + [
              p
              for p in get(oxr, "spec.ram.principals", [])
              if p
          ]

          # This block should be specific to the RAM when loaded
          # as part of the VPC - it should not affect the RAM when
          # loaded as part of the TransitGateway.
          _forceRamEnabled = False
          if all_true([
              get(oxr, "spec.transitGateway.enabled", False),
              any_true([
                  get(oxr, "status.vpcs.${name}.owner", False) != get(oxr, "status.vpcs.self.owner", False)
                  for name, _ in get(oxr, "status.vpcs", [])
                  for _, vpc in get(oxr, "spec.transitGateway.remoteVpcs", [])
                  if get(vpc, "name", "") == name
              ]),
          ]):
              _forceRamEnabled = True

          resources = [
              c for r in [
                  [tgwArn],
                  sharedMpl,
                  sharedSubnets,
              ]
              for c in r if c
          ] + get(oxr, "spec.ram.resources", [])

          _items = [
              {
                  "apiVersion": "xaws.crossplane.giantswarm.io/v1alpha1"
                  "kind": "ResourceAccessManager"
                  "metadata": {
                      _resourceName = "ram-${appName}-${region}"
                      "annotations": {
                          "krm.kcl.dev/composition-resource-name": _resourceName
                          "krm.kcl.dev/ready" = readystr(_resourceName)
                      }
                      "labels": labels | {
                          "vpcName": appName
                      }
                  }
                  "spec": {
                      "allowExternalPrincipals": get(oxr, "spec.ram.allowExternalPrincipals", False),
                      "deletionPolicy": dp
                      "claimRef": get(oxr, "spec.claimRef", {}),
                      "managementPolicies": mgmtPolicy,
                      "name": appName,
                      "permissions": get(oxr, "spec.ram.permissions", []),
                      "principals": principals,
                      "resources": resources,
                      "providerConfigRef": pcr
                      "region": region,
                      "tags": tags,
                  }
              }
              for _ in [True]
              if any_true([
                  get(oxr, "spec.ram.enabled", False),
                  _forceRamEnabled,
              ])
          ]

          items = _items
        target: ""
    step: function-kcl-ram
  - functionRef:
      name: function-kcl
    input:
      apiVersion: krm.kcl.dev/v1alpha1
      kind: KCLInput
      metadata:
        creationTimestamp: null
      spec:
        source: |-
          import regex
          oxr = option("params").oxr
          dxr = option("params").dxr
          ocds = option("params").ocds
          dcds = option("params").dcds

          exists = lambda x: any -> bool {
              """
              Check if a value exists.
              """
              x in list(ocds)
          }

          get = lambda x: {:}, y: str, d: any -> any {
              """
              Get an item from a dictionary using a dot separated path.
              If the item is not found, return a default value.
              """
              p = regex.split(y, "\.")
              c = p[0]
              y = ".".join(p[1:])
              x[c] if len(p) == 1 and c in x else d if c not in x else get(x[c], y, d)
          }

          gpcr = lambda x: {:} -> {:} {
              """
              Get the ProviderConfigRef from the given object

              If this is not set it will attempt to return the ProviderConfigRef from
              the Observed Composite Resource, and if that isn't set, will return an
              object with an empty name.
              """
              get(x, "providerConfigRef", get(oxr, "spec.providerConfigRef", {name: ""}))
          }

          ocdsstatus = lambda x: str, y: str, d: any -> any {
              """
              Get an item from the status of an ocds resource.
              """
              _x = None
              if get(ocds, "${x}.Resource.status.atProvider", False):
                  _x = get(ocds, "${x}.Resource.status.atProvider.${y}", d)
              else:
                  _x = get(ocds, "${x}.Resource.status.${y}", d)
              _x if _x else d
          }

          ready = lambda x: str -> bool {
              """
              Check if a value is ready.
              """
              conditionsReady = all_true([
                  get(c, "status", "False") == "True" for c in ocdsstatus(x, "conditions", [])
              ])

              ap = get(ocds, "${x}.Resource.status.atProvider", {})
              objectReady = any_true([
                  ocdsstatus(x, "ready", False),
                  len(list(ap)) > 0,
              ])

              all_true([
                  any_true([exists(x), conditionsReady]),
                  objectReady,
              ])
          }

          readystr = lambda x: str -> str {
              """
              Check if a value is ready.
              """
              "True" if ready(x) else "False"
          }

          allReady = lambda -> bool {
              """
              Check if all managed resources are ready.
              """
              all_true([
                  ready(x)
                  for x in list(ocds)
              ])
          }

          appName = get(oxr, "spec.claimRef.name", "")
          dp = get(oxr, "spec.deletionPolicy", "Delete")
          labels = get(oxr, "metadata.labels", {})
          localVpc = get(oxr, "spec.localVpc", {})
          pcr = get(oxr, "spec.providerConfigRef", {"name": "default"})
          region = get(oxr, "spec.localVpc.region", "eu-central-1")
          tags = get(oxr, "spec.tags", {}) | {
              "region": region,
          } | labels

          localAttachmentIds = {
              "${appName}": ocdsstatus("tgwa-${appName}-${region}", "id", "")
              for _ in [True]
              if ocdsstatus("tgwa-${appName}-${region}", "id", False)
          }

          mgmtPolicy = get(oxr, "spec.managementPolicies", [])

          publishConnection = get(oxr, "spec.publishConnectionDetailsTo", {})
          tgwArn = ocdsstatus("transitgateway-${appName}-${region}", "arn", False)
          tgwId = ocdsstatus("transitgateway-${appName}-${region}", "id", False)
          tgwRouteTableId = ocdsstatus("tgwrt-${appName}-${region}", "id", False)

          remoteAttachementIds = {
              "${remoteVpc.name}": ocdsstatus("tgwa-${appName}-${region}-${remoteVpc.name}", "id", "")
              for _, remoteVpc in get(oxr, "spec.remoteVpcs", [])
              if ocdsstatus("tgwa-${appName}-${region}-${remoteVpc.name}", "id", False)
          }

          peerAttachmentIds = {
              "${peer.name}": ocdsstatus("tgwa-${appName}-${region}-${peer.name}", "id", "")
              for _, peer in get(oxr, "spec.peers", [])
              if ocdsstatus("tgwa-${appName}-${region}-${peer.name}", "id", False)
          }

          routingTables = {
              "${appName}": {
                  "vpc": {
                      "open": [
                          # Outbound from the local VPC needs the remote cidr blocks
                          {
                              "cidr": cidr,
                              "description": "${remoteVpc.name} CIDR Block ${i}",
                          }
                          for _, remoteVpc in get(oxr, "spec.remoteVpcs", [])
                          for i, cidr in get(remoteVpc, "cidrBlocks", [])
                      ] + [
                          e
                          for _, pl in get(localVpc, "prefixLists", [])
                          for e in get(pl, "entries", [])
                          if all_true([
                              e,
                              get(pl, "outbound", False),
                              not get(pl, "id", False),
                              not get(pl, "blackhole", False),
                          ])
                      ],
                      "blackhole": [
                          e
                          for _, pl in get(localVpc, "prefixLists", [])
                          for e in get(pl, "entries", [])
                          if all_true([
                              e,
                              get(pl, "outbound", False),
                              not get(pl, "id", False),
                              get(pl, "blackhole", False),
                          ])
                      ]
                  },
                  "tgw": {
                      "open": [
                          e
                          for _, pl in get(localVpc, "prefixLists", [])
                          for e in get(pl, "entries", [])
                          if all_true([
                              e,
                              not get(pl, "outbound", True),
                              not get(pl, "id", False),
                              not get(pl, "blackhole", False),
                          ])
                      ],
                      "blackhole": [
                          e
                          for _, pl in get(localVpc, "prefixLists", [])
                          for e in get(pl, "entries", [])
                          if all_true([
                              e,
                              not get(pl, "outbound", True),
                              not get(pl, "id", False),
                              get(pl, "blackhole", False),
                          ])
                      ]
                  }
              }
          } | {
              "${r.name}": {
                  "vpc": {
                      "open": [
                          # Add the primary VPC cidr blocks
                          {
                              "cidr": cidr,
                              "description": "${appName} CIDR Block ${i}",
                          }
                          for i, cidr in get(localVpc, "cidrBlocks", [])
                      ] + [
                          # Add the remote VPC cidr blocks where the remote VPC is not the
                          # same as the current VPC
                          {
                              "cidr": cidr,
                              "description": "${remoteVpc.name} CIDR Block ${i}",
                          }
                          for _, remoteVpc in get(oxr, "spec.remoteVpcs", [])
                          for i, cidr in get(remoteVpc, "cidrBlocks", [])
                          if all_true([
                              remoteVpc.name != r.name,
                          ])
                      ] + [
                          # Add any prefix list entries that need creating
                          e
                          for _, pl in get(r, "prefixLists", [])
                          for e in get(pl, "entries", [])
                          if all_true([
                              e,
                              get(pl, "outbound", False),
                              not get(pl, "id", False),
                              not get(pl, "blackhole", False),
                          ])
                      ],
                      "blackhole": [
                          e
                          for _, pl in get(r, "prefixLists", [])
                          for e in get(pl, "entries", [])
                          if all_true([
                              e,
                              get(pl, "outbound", False),
                              not get(pl, "id", False),
                              get(pl, "blackhole", False),
                          ])
                      ]
                  },
                  "tgw": {
                      "open": [
                          e
                          for _, pl in get(r, "prefixLists", [])
                          for e in get(pl, "entries", [])
                          if all_true([
                              e,
                              not get(pl, "outbound", True),
                              not get(pl, "id", False),
                              not get(pl, "blackhole", False),
                          ])

                      ],
                      "blackhole": [
                          e
                          for _, pl in get(r, "prefixLists", [])
                          for e in get(pl, "entries", [])
                          if all_true([
                              e,
                              not get(pl, "outbound", True),
                              not get(pl, "id", False),
                              get(pl, "blackhole", False),
                          ])
                      ]
                  }
              }
              for _, r in get(oxr, "spec.remoteVpcs", [])
          } | {
              "peering-${peer.name}": {
                  "remote": {
                      "open": [
                          e
                          for _, pl in get(peer, "prefixLists", [])
                          for e in get(pl, "entries", [])
                          if all_true([
                              e,
                              get(pl, "outbound", False),
                              not get(pl, "id", False),
                              not get(pl, "blackhole", False),
                          ])
                      ],
                      "blackhole": [
                          e
                          for _, pl in get(peer, "prefixLists", [])
                          for e in get(pl, "entries", [])
                          if all_true([
                              e,
                              get(pl, "outbound", False),
                              not get(pl, "id", False),
                              get(pl, "blackhole", False),
                          ])
                      ]
                  },
                  "tgw": {
                      "open": [
                          e
                          for _, pl in get(peer, "prefixLists", [])
                          for e in get(pl, "entries", [])
                          if all_true([
                              e,
                              not get(pl, "outbound", True),
                              not get(pl, "id", False),
                              not get(pl, "blackhole", False),
                          ])
                      ],
                      "blackhole": [
                          e
                          for _, pl in get(peer, "prefixLists", [])
                          for e in get(pl, "entries", [])
                          if all_true([
                              e,
                              not get(pl, "outbound", True),
                              not get(pl, "id", False),
                              get(pl, "blackhole", False),
                          ])
                      ]
                  }
              }
              for _, peer in get(oxr, "spec.peers", [])
          }

          mpl = lambda n : str, r: str, a: str, b: bool, isp: bool, e: [], p: {:} -> {:} {
              """
              Create a ManagedPrefixList object.

              n: The name of the ManagedPrefixList
              r: The region the ManagedPrefixList is in
              a: The address family of the ManagedPrefixList
              b: Whether the ManagedPrefixList is a blackhole
              isp: Whether the ManagedPrefixList is for a peering connection
              e: The entries for the ManagedPrefixList
              p: The ProviderConfigRef for the ManagedPrefixList

              Returns a ManagedPrefixList object.
              """
              _bh = "-bh" if b else ""
              _n = "${appName}-${region}-${n}${_bh}" if n != appName else "${appName}-${region}${_bh}"
              _isp = "-tgw" if isp else ""
              _resourceName = "mpl-${_n}" if not isp else "p-mpl-${_n}"
              {
                  "apiVersion": "xnetworks.crossplane.giantswarm.io/v1alpha1",
                  "kind": "ManagedPrefixList",
                  "metadata": {
                      "annotations": {
                          "krm.kcl.dev/composition-resource-name": _resourceName,
                          "krm.kcl.dev/ready": readystr(_resourceName),
                      },
                      "labels": labels | {
                          "vpcName" = n,
                      },
                  },
                  "spec": {
                      "addressFamily": a,
                      "claimRef": get(oxr, "spec.claimRef", {}),
                      "deletionPolicy": dp,
                      "entries": e,
                      "managementPolicies": mgmtPolicy,
                      "name": "${_n}${_isp}",
                      "region": r,
                      "providerConfigRef": p,
                      "tags": tags | {
                          "Name": "${_n}${_isp}",
                      },
                  }
              } if len(e) > 0 else {}
          }

          plr = lambda n : str, r: str, pid: str, aid: str, rid: str, b: bool, isp: bool, p: {:} -> {:} {
              """
              Create a TransitGatewayPrefixListReference object.

              n: The name of the PrefixList reference
              r: The region the PrefixList reference should be created in
              b: Whether the PrefixList is a blackhole
              pid: The PrefixListId for the PrefixList reference
              aid: The TransitGatewayAttachmentId for the PrefixList reference
              rid: The TransitGatewayRouteTableId for the PrefixList reference
              isp: Whether the PrefixList reference is for a peering connection
              p: The ProviderConfigRef for the PrefixList

              Returns a TransitGatewayPrefixListReference object.
              """
              {
                  _bh = "-bh" if b else ""
                  _n = "${appName}-${region}-${n}${_bh}" if n != appName else "${appName}-${region}${_bh}"
                  _resourceName = "tgwplr-${aid}" if not isp else "p-tgwplr-${aid}"
                  "apiVersion": "ec2.aws.upbound.io/v1beta1",
                  "kind": "TransitGatewayPrefixListReference",
                  "metadata": {
                      "annotations": {
                          "krm.kcl.dev/composition-resource-name": _resourceName,
                          "krm.kcl.dev/ready": readystr(_resourceName),
                      },
                      "labels": labels | {
                          "vpcName" = n,
                      } if not isp else {
                          "peerName" = n,
                      },
                  },
                  "spec": {
                      "deletionPolicy": dp,
                      "forProvider": {
                          "blackhole": b,
                          "prefixListId": pid,
                          "region": r,
                          "transitGatewayAttachmentId": aid,
                          "transitGatewayRouteTableId": rid,
                      },
                      "managementPolicies": mgmtPolicy,
                      "providerConfigRef": p,
                  }
              } if all_true([
                  pid, aid, rid,
              ]) else {}
          }

          remotePrefixListIds = {
              "${rVpc.name}": [
                  c for c in [
                      ocdsstatus("mpl-${appName}-${region}-${rVpc.name}", "id", "")
                      ocdsstatus("mpl-${appName}-${region}-${rVpc.name}-bh", "id", "")
                  ] if c
              ] + [
                  c for c in [
                      get(pl, "id", "")
                      for _, pl in get(rVpc, "prefixLists", [])
                      if all_true([
                          get(pl, "id", False),
                          get(pl, "outbound", True),
                      ])
                  ]
              ]
              for _, rVpc in get(oxr, "spec.remoteVpcs", [])
          }

          sharedPrefixLists: [str] = [
              c for r in [
                  [
                      ocdsstatus("mpl-${appName}-${region}-${rVpc.name}", "arn", ""),
                      ocdsstatus("mpl-${appName}-${region}-${rVpc.name}-bh", "arn", ""),
                  ]
                  for _, rVpc in get(oxr, "spec.remoteVpcs", [])
                  if rVpc.accountId != get(oxr, "spec.localVpc.accountId", "")
              ]
              for c in r if c
          ]

          # Create the main transit gateway
          # The Id of this transit gateway will be published to oxr.status.tgwId
          transitGateway = {
              _resourceName = "transitgateway-${appName}-${region}"
              "apiVersion": "ec2.aws.upbound.io/v1beta1"
              "kind": "TransitGateway"
              "metadata": {
                  "annotations": {
                      "krm.kcl.dev/composition-resource-name" = _resourceName
                      "krm.kcl.dev/ready" = readystr(_resourceName)
                  }
                  "labels": labels | {
                      "vpcName": appName
                  }
              }
              "spec": {
                  "deletionPolicy": dp
                  "forProvider": {
                      "amazonSideAsn": get(oxr, "spec.amazonSideAsn", 64512),
                      "autoAcceptSharedAttachments": get(oxr, "spec.autoAcceptSharedAttachments", "enable"),
                      "defaultRouteTableAssociation": "enable" if get(oxr, "spec.defaultRouteTableAssociation", False) else "disable",
                      "defaultRouteTablePropagation": "enable" if get(oxr, "spec.defaultRouteTablePropagation", False) else "disable",
                      "description": "${appName} Transit Gateway in ${region}",
                      "dnsSupport": get(oxr, "spec.dnsSupport", "enable"),
                      "multicastSupport": get(oxr, "spec.multicastSupport", "disable"),
                      "region": region,
                      "tags": tags | {
                          "Name": "${appName}-${region}"
                      },
                      "transitGatewayCidrBlocks": [
                          get(oxr, "spec.transitGatewayCidrBlock", "")
                          for _ in [True]
                          if get(oxr, "spec.transitGatewayCidrBlock", False)
                      ]
                      "vpnEcmpSupport": get(oxr, "spec.vpnEcmpSupport", "enable"),
                  }
                  "managementPolicies": mgmtPolicy,
                  "providerConfigRef": pcr
              }
          }


          # Create the main transit gateway route table
          # The Id of this route table will be published to oxr.status.tgwRouteTableId
          tgwRouteTable = [
              {
                  _resourceName = "tgwrt-${appName}-${region}"
                  "apiVersion": "ec2.aws.upbound.io/v1beta1"
                  "kind": "TransitGatewayRouteTable"
                  "metadata": {
                      "annotations": {
                          "krm.kcl.dev/composition-resource-name": _resourceName
                          "krm.kcl.dev/ready" = readystr(_resourceName)
                      }
                      "labels": labels | {
                          "vpcName": appName
                      }
                  }
                  "spec": {
                      "deletionPolicy": dp
                      "forProvider": {
                          "region": region,
                          "tags": tags | {
                              "Name": "${appName}-${region}",
                          }
                          "transitGatewayId": tgwId,
                      }
                      "managementPolicies": mgmtPolicy,
                      "providerConfigRef": pcr
                  }
              }
              for _ in [True] if tgwId
          ]

          tgwPolicyTable = [
              {
                  _resourceName = "tgwpt-${appName}-${region}"
                  "apiVersion": "ec2.aws.upbound.io/v1beta1"
                  "kind": "TransitGatewayPolicyTable"
                  "metadata": {
                      "annotations": {
                          "krm.kcl.dev/composition-resource-name": _resourceName
                          "krm.kcl.dev/ready" = readystr(_resourceName)
                      }
                      "labels": labels | {
                          "vpcName": appName
                      }
                  }
                  "spec": {
                      "deletionPolicy": get(oxr, "spec.deletionPolicy", "Delete"),
                      "forProvider": {
                          "region": region,
                          "tags": tags | {
                              Name: "${appName}-${region}",
                          }
                          "transitGatewayId": tgwId,
                      }
                      "managementPolicies": mgmtPolicy,
                      "providerConfigRef": pcr
                  }
              }
              for _ in [True]
              if all_true([
                  tgwId,
                  get(oxr, "spec.createPolicyTable", True),
              ])
          ]

          tgwAssociations = [
              {
                  _resourceName = "tgwa-${appName}-${region}-${id}"
                  "apiVersion": "ec2.aws.upbound.io/v1beta1"
                  "kind": "TransitGatewayRouteTableAssociation"
                  "metadata": {
                      "annotations": {
                          "krm.kcl.dev/composition-resource-name": _resourceName
                          "krm.kcl.dev/ready" = readystr(_resourceName)
                      }
                      "labels": labels | {
                          "vpcName": appName
                      }
                  }
                  "spec": {
                      "deletionPolicy": get(oxr, "spec.deletionPolicy", "Delete"),
                      "forProvider": {
                          "region": region,
                          "replaceExistingAssociation": False,
                          "transitGatewayAttachmentId": id,
                          "transitGatewayRouteTableId": tgwRouteTableId,
                      }
                      "managementPolicies": mgmtPolicy,
                      "providerConfigRef": pcr
                  }
              }
              for _, id in localAttachmentIds | remoteAttachementIds
              if all_true([
                  localAttachmentIds, tgwRouteTableId,
                  remoteAttachementIds,
              ])
          ]

          _items =  [
              i for r in [
                  [transitGateway],
                  tgwRouteTable,
                  tgwAssociations,
                  tgwPolicyTable,
              ] for i in r if i
          ]

          items = _items
        target: ""
    step: function-kcl-create-resources
  - functionRef:
      name: function-kcl
    input:
      apiVersion: krm.kcl.dev/v1alpha1
      kind: KCLInput
      metadata:
        creationTimestamp: null
      spec:
        source: |-
          import regex
          oxr = option("params").oxr
          dxr = option("params").dxr
          ocds = option("params").ocds
          dcds = option("params").dcds

          exists = lambda x: any -> bool {
              """
              Check if a value exists.
              """
              x in list(ocds)
          }

          get = lambda x: {:}, y: str, d: any -> any {
              """
              Get an item from a dictionary using a dot separated path.
              If the item is not found, return a default value.
              """
              p = regex.split(y, "\.")
              c = p[0]
              y = ".".join(p[1:])
              x[c] if len(p) == 1 and c in x else d if c not in x else get(x[c], y, d)
          }

          gpcr = lambda x: {:} -> {:} {
              """
              Get the ProviderConfigRef from the given object

              If this is not set it will attempt to return the ProviderConfigRef from
              the Observed Composite Resource, and if that isn't set, will return an
              object with an empty name.
              """
              get(x, "providerConfigRef", get(oxr, "spec.providerConfigRef", {name: ""}))
          }

          ocdsstatus = lambda x: str, y: str, d: any -> any {
              """
              Get an item from the status of an ocds resource.
              """
              _x = None
              if get(ocds, "${x}.Resource.status.atProvider", False):
                  _x = get(ocds, "${x}.Resource.status.atProvider.${y}", d)
              else:
                  _x = get(ocds, "${x}.Resource.status.${y}", d)
              _x if _x else d
          }

          ready = lambda x: str -> bool {
              """
              Check if a value is ready.
              """
              conditionsReady = all_true([
                  get(c, "status", "False") == "True" for c in ocdsstatus(x, "conditions", [])
              ])

              ap = get(ocds, "${x}.Resource.status.atProvider", {})
              objectReady = any_true([
                  ocdsstatus(x, "ready", False),
                  len(list(ap)) > 0,
              ])

              all_true([
                  any_true([exists(x), conditionsReady]),
                  objectReady,
              ])
          }

          readystr = lambda x: str -> str {
              """
              Check if a value is ready.
              """
              "True" if ready(x) else "False"
          }

          allReady = lambda -> bool {
              """
              Check if all managed resources are ready.
              """
              all_true([
                  ready(x)
                  for x in list(ocds)
              ])
          }

          appName = get(oxr, "spec.claimRef.name", "")
          dp = get(oxr, "spec.deletionPolicy", "Delete")
          labels = get(oxr, "metadata.labels", {})
          localVpc = get(oxr, "spec.localVpc", {})
          pcr = get(oxr, "spec.providerConfigRef", {"name": "default"})
          region = get(oxr, "spec.localVpc.region", "eu-central-1")
          tags = get(oxr, "spec.tags", {}) | {
              "region": region,
          } | labels

          localAttachmentIds = {
              "${appName}": ocdsstatus("tgwa-${appName}-${region}", "id", "")
              for _ in [True]
              if ocdsstatus("tgwa-${appName}-${region}", "id", False)
          }

          mgmtPolicy = get(oxr, "spec.managementPolicies", [])

          publishConnection = get(oxr, "spec.publishConnectionDetailsTo", {})
          tgwArn = ocdsstatus("transitgateway-${appName}-${region}", "arn", False)
          tgwId = ocdsstatus("transitgateway-${appName}-${region}", "id", False)
          tgwRouteTableId = ocdsstatus("tgwrt-${appName}-${region}", "id", False)

          remoteAttachementIds = {
              "${remoteVpc.name}": ocdsstatus("tgwa-${appName}-${region}-${remoteVpc.name}", "id", "")
              for _, remoteVpc in get(oxr, "spec.remoteVpcs", [])
              if ocdsstatus("tgwa-${appName}-${region}-${remoteVpc.name}", "id", False)
          }

          peerAttachmentIds = {
              "${peer.name}": ocdsstatus("tgwa-${appName}-${region}-${peer.name}", "id", "")
              for _, peer in get(oxr, "spec.peers", [])
              if ocdsstatus("tgwa-${appName}-${region}-${peer.name}", "id", False)
          }

          routingTables = {
              "${appName}": {
                  "vpc": {
                      "open": [
                          # Outbound from the local VPC needs the remote cidr blocks
                          {
                              "cidr": cidr,
                              "description": "${remoteVpc.name} CIDR Block ${i}",
                          }
                          for _, remoteVpc in get(oxr, "spec.remoteVpcs", [])
                          for i, cidr in get(remoteVpc, "cidrBlocks", [])
                      ] + [
                          e
                          for _, pl in get(localVpc, "prefixLists", [])
                          for e in get(pl, "entries", [])
                          if all_true([
                              e,
                              get(pl, "outbound", False),
                              not get(pl, "id", False),
                              not get(pl, "blackhole", False),
                          ])
                      ],
                      "blackhole": [
                          e
                          for _, pl in get(localVpc, "prefixLists", [])
                          for e in get(pl, "entries", [])
                          if all_true([
                              e,
                              get(pl, "outbound", False),
                              not get(pl, "id", False),
                              get(pl, "blackhole", False),
                          ])
                      ]
                  },
                  "tgw": {
                      "open": [
                          e
                          for _, pl in get(localVpc, "prefixLists", [])
                          for e in get(pl, "entries", [])
                          if all_true([
                              e,
                              not get(pl, "outbound", True),
                              not get(pl, "id", False),
                              not get(pl, "blackhole", False),
                          ])
                      ],
                      "blackhole": [
                          e
                          for _, pl in get(localVpc, "prefixLists", [])
                          for e in get(pl, "entries", [])
                          if all_true([
                              e,
                              not get(pl, "outbound", True),
                              not get(pl, "id", False),
                              get(pl, "blackhole", False),
                          ])
                      ]
                  }
              }
          } | {
              "${r.name}": {
                  "vpc": {
                      "open": [
                          # Add the primary VPC cidr blocks
                          {
                              "cidr": cidr,
                              "description": "${appName} CIDR Block ${i}",
                          }
                          for i, cidr in get(localVpc, "cidrBlocks", [])
                      ] + [
                          # Add the remote VPC cidr blocks where the remote VPC is not the
                          # same as the current VPC
                          {
                              "cidr": cidr,
                              "description": "${remoteVpc.name} CIDR Block ${i}",
                          }
                          for _, remoteVpc in get(oxr, "spec.remoteVpcs", [])
                          for i, cidr in get(remoteVpc, "cidrBlocks", [])
                          if all_true([
                              remoteVpc.name != r.name,
                          ])
                      ] + [
                          # Add any prefix list entries that need creating
                          e
                          for _, pl in get(r, "prefixLists", [])
                          for e in get(pl, "entries", [])
                          if all_true([
                              e,
                              get(pl, "outbound", False),
                              not get(pl, "id", False),
                              not get(pl, "blackhole", False),
                          ])
                      ],
                      "blackhole": [
                          e
                          for _, pl in get(r, "prefixLists", [])
                          for e in get(pl, "entries", [])
                          if all_true([
                              e,
                              get(pl, "outbound", False),
                              not get(pl, "id", False),
                              get(pl, "blackhole", False),
                          ])
                      ]
                  },
                  "tgw": {
                      "open": [
                          e
                          for _, pl in get(r, "prefixLists", [])
                          for e in get(pl, "entries", [])
                          if all_true([
                              e,
                              not get(pl, "outbound", True),
                              not get(pl, "id", False),
                              not get(pl, "blackhole", False),
                          ])

                      ],
                      "blackhole": [
                          e
                          for _, pl in get(r, "prefixLists", [])
                          for e in get(pl, "entries", [])
                          if all_true([
                              e,
                              not get(pl, "outbound", True),
                              not get(pl, "id", False),
                              get(pl, "blackhole", False),
                          ])
                      ]
                  }
              }
              for _, r in get(oxr, "spec.remoteVpcs", [])
          } | {
              "peering-${peer.name}": {
                  "remote": {
                      "open": [
                          e
                          for _, pl in get(peer, "prefixLists", [])
                          for e in get(pl, "entries", [])
                          if all_true([
                              e,
                              get(pl, "outbound", False),
                              not get(pl, "id", False),
                              not get(pl, "blackhole", False),
                          ])
                      ],
                      "blackhole": [
                          e
                          for _, pl in get(peer, "prefixLists", [])
                          for e in get(pl, "entries", [])
                          if all_true([
                              e,
                              get(pl, "outbound", False),
                              not get(pl, "id", False),
                              get(pl, "blackhole", False),
                          ])
                      ]
                  },
                  "tgw": {
                      "open": [
                          e
                          for _, pl in get(peer, "prefixLists", [])
                          for e in get(pl, "entries", [])
                          if all_true([
                              e,
                              not get(pl, "outbound", True),
                              not get(pl, "id", False),
                              not get(pl, "blackhole", False),
                          ])
                      ],
                      "blackhole": [
                          e
                          for _, pl in get(peer, "prefixLists", [])
                          for e in get(pl, "entries", [])
                          if all_true([
                              e,
                              not get(pl, "outbound", True),
                              not get(pl, "id", False),
                              get(pl, "blackhole", False),
                          ])
                      ]
                  }
              }
              for _, peer in get(oxr, "spec.peers", [])
          }

          mpl = lambda n : str, r: str, a: str, b: bool, isp: bool, e: [], p: {:} -> {:} {
              """
              Create a ManagedPrefixList object.

              n: The name of the ManagedPrefixList
              r: The region the ManagedPrefixList is in
              a: The address family of the ManagedPrefixList
              b: Whether the ManagedPrefixList is a blackhole
              isp: Whether the ManagedPrefixList is for a peering connection
              e: The entries for the ManagedPrefixList
              p: The ProviderConfigRef for the ManagedPrefixList

              Returns a ManagedPrefixList object.
              """
              _bh = "-bh" if b else ""
              _n = "${appName}-${region}-${n}${_bh}" if n != appName else "${appName}-${region}${_bh}"
              _isp = "-tgw" if isp else ""
              _resourceName = "mpl-${_n}" if not isp else "p-mpl-${_n}"
              {
                  "apiVersion": "xnetworks.crossplane.giantswarm.io/v1alpha1",
                  "kind": "ManagedPrefixList",
                  "metadata": {
                      "annotations": {
                          "krm.kcl.dev/composition-resource-name": _resourceName,
                          "krm.kcl.dev/ready": readystr(_resourceName),
                      },
                      "labels": labels | {
                          "vpcName" = n,
                      },
                  },
                  "spec": {
                      "addressFamily": a,
                      "claimRef": get(oxr, "spec.claimRef", {}),
                      "deletionPolicy": dp,
                      "entries": e,
                      "managementPolicies": mgmtPolicy,
                      "name": "${_n}${_isp}",
                      "region": r,
                      "providerConfigRef": p,
                      "tags": tags | {
                          "Name": "${_n}${_isp}",
                      },
                  }
              } if len(e) > 0 else {}
          }

          plr = lambda n : str, r: str, pid: str, aid: str, rid: str, b: bool, isp: bool, p: {:} -> {:} {
              """
              Create a TransitGatewayPrefixListReference object.

              n: The name of the PrefixList reference
              r: The region the PrefixList reference should be created in
              b: Whether the PrefixList is a blackhole
              pid: The PrefixListId for the PrefixList reference
              aid: The TransitGatewayAttachmentId for the PrefixList reference
              rid: The TransitGatewayRouteTableId for the PrefixList reference
              isp: Whether the PrefixList reference is for a peering connection
              p: The ProviderConfigRef for the PrefixList

              Returns a TransitGatewayPrefixListReference object.
              """
              {
                  _bh = "-bh" if b else ""
                  _n = "${appName}-${region}-${n}${_bh}" if n != appName else "${appName}-${region}${_bh}"
                  _resourceName = "tgwplr-${aid}" if not isp else "p-tgwplr-${aid}"
                  "apiVersion": "ec2.aws.upbound.io/v1beta1",
                  "kind": "TransitGatewayPrefixListReference",
                  "metadata": {
                      "annotations": {
                          "krm.kcl.dev/composition-resource-name": _resourceName,
                          "krm.kcl.dev/ready": readystr(_resourceName),
                      },
                      "labels": labels | {
                          "vpcName" = n,
                      } if not isp else {
                          "peerName" = n,
                      },
                  },
                  "spec": {
                      "deletionPolicy": dp,
                      "forProvider": {
                          "blackhole": b,
                          "prefixListId": pid,
                          "region": r,
                          "transitGatewayAttachmentId": aid,
                          "transitGatewayRouteTableId": rid,
                      },
                      "managementPolicies": mgmtPolicy,
                      "providerConfigRef": p,
                  }
              } if all_true([
                  pid, aid, rid,
              ]) else {}
          }

          remotePrefixListIds = {
              "${rVpc.name}": [
                  c for c in [
                      ocdsstatus("mpl-${appName}-${region}-${rVpc.name}", "id", "")
                      ocdsstatus("mpl-${appName}-${region}-${rVpc.name}-bh", "id", "")
                  ] if c
              ] + [
                  c for c in [
                      get(pl, "id", "")
                      for _, pl in get(rVpc, "prefixLists", [])
                      if all_true([
                          get(pl, "id", False),
                          get(pl, "outbound", True),
                      ])
                  ]
              ]
              for _, rVpc in get(oxr, "spec.remoteVpcs", [])
          }

          sharedPrefixLists: [str] = [
              c for r in [
                  [
                      ocdsstatus("mpl-${appName}-${region}-${rVpc.name}", "arn", ""),
                      ocdsstatus("mpl-${appName}-${region}-${rVpc.name}-bh", "arn", ""),
                  ]
                  for _, rVpc in get(oxr, "spec.remoteVpcs", [])
                  if rVpc.accountId != get(oxr, "spec.localVpc.accountId", "")
              ]
              for c in r if c
          ]

          remoteAttachments = [
              {
                  _resourceName = "tgwa-${appName}-${region}-${remoteVpc.name}"
                  "apiVersion": "ec2.aws.upbound.io/v1beta1"
                  "kind": "TransitGatewayVPCAttachment"
                  "metadata": {
                      "annotations": {
                          "krm.kcl.dev/composition-resource-name": _resourceName
                          "krm.kcl.dev/ready" = readystr(_resourceName)
                      }
                      "labels": labels | {
                          "vpcName" = remoteVpc.name
                      }
                  }
                  "spec": {
                      "deletionPolicy": dp
                      "forProvider": {
                          "applianceModeSupport": get(oxr, "spec.applianceModeSupport", "disable"),
                          "dnsSupport": get(oxr, "spec.dnsSupport", "enable"),
                          "ipv6Support": get(oxr, "spec.ipv6Support", "disable"),
                          "region": get(remoteVpc, "region", region),
                          "subnetIds": get(remoteVpc, "subnetIds", []),
                          "tags": tags | {
                              "Name": "${appName}-${region}-${remoteVpc.name}"
                          }
                          "transitGatewayDefaultRouteTableAssociation": get(oxr, "spec.defaultRouteTableAssociation", False),
                          "transitGatewayDefaultRouteTablePropagation": get(oxr, "spec.defaultRouteTablePropagation", False),
                          "transitGatewayId": tgwId,
                          "vpcId": get(remoteVpc, "vpcId", ""),
                      }
                      "managementPolicies": mgmtPolicy,
                      "providerConfigRef": gpcr(remoteVpc)
                  }
              }
              for _, remoteVpc in get(oxr, "spec.remoteVpcs", [])
              if all_true([
                  tgwId,
                  get(oxr, "spec.remoteVpcs", []),
              ])
          ]

          attachmentAccepters = [
              {
                  _resourceName = "tgwaa-${appName}-${region}-${remoteVpc.name}"
                  "apiVersion": "ec2.aws.upbound.io/v1beta1"
                  "kind": "TransitGatewayVPCAttachmentAccepter"
                  "metadata": {
                      "annotations": {
                          "krm.kcl.dev/composition-resource-name": _resourceName
                          "krm.kcl.dev/ready" = readystr(_resourceName)
                      }
                      "labels": labels | {
                          "vpcName" = remoteVpc.name
                      }
                  }
                  "spec": {
                      "deletionPolicy": get(oxr, "spec.deletionPolicy", "Delete"),
                      "forProvider": {
                          "region": get(remoteVpc, "region", region),
                          "transitGatewayAttachmentId": get(remoteAttachementIds, remoteVpc.name, ""),
                      }
                      "managementPolicies": mgmtPolicy,
                      "providerConfigRef": gpcr(remoteVpc)
                  }
              }
              for _, remoteVpc in get(oxr, "spec.remoteVpcs", [])
              if all_true([
                  get(oxr, "spec.remoteVpcs", []),
                  any_true([
                      get(remoteVpc, "region", region) != region,
                      gpcr(remoteVpc).name != get(oxr, "spec.providerConfigRef.name", ""),
                  ]),
                  get(remoteAttachementIds, remoteVpc.name, False),
                  get(oxr, "spec.autoAcceptSharedAttachments", "enable") != "enable",
              ])
          ]

          remotePrefixLists = [
              i for r in [
                  [
                      mpl(
                          remoteVpc.name,
                          get(remoteVpc, "region", region),
                          get(remoteVpc, "addressFamily", "IPv4"),
                          False,
                          False,
                          get(routingTables, "${remoteVpc.name}.vpc.open", {}),
                          pcr,
                      ),
                      mpl(
                          remoteVpc.name,
                          get(remoteVpc, "region", region),
                          get(remoteVpc, "addressFamily", "IPv4"),
                          True,
                          False,
                          get(routingTables, "${remoteVpc.name}.vpc.blackhole", {}),
                          pcr,
                      ),
                  ]
                  for _, remoteVpc in get(oxr, "spec.remoteVpcs", [])
              ] for i in r
          ]

          remoteRoutes = [
              {
                  _resourceName = "peering-rt-${id}"
                  "apiVersion": "ec2.aws.upbound.io/v1beta1"
                  "kind": "Route"
                  "metadata": {
                      "annotations": {
                          "krm.kcl.dev/composition-resource-name": _resourceName
                          "krm.kcl.dev/ready" = readystr(_resourceName)
                      }
                      "labels": labels | {
                          "routeType": "peering",
                          "vpcName" = remoteVpc.name
                      }
                  }
                  "spec": {
                      "deletionPolicy": dp
                      "forProvider": {
                          "destinationPrefixListId": pl,
                          "routeTableId": id,
                          "region": get(remoteVpc, "region", region),
                          "transitGatewayId": tgwId,
                      },
                      "managementPolicies": mgmtPolicy,
                      "providerConfigRef": gpcr(remoteVpc),
                  }
              }
              for _, remoteVpc in get(oxr, "spec.remoteVpcs", [])
              for _, id in get(remoteVpc, "routeTableIds", [])
              for pl in get(remotePrefixListIds, remoteVpc.name, [])
              if all_true([
                  tgwId, remotePrefixListIds,
              ])
          ]

          remotePropagation = [
              {
                  _resourceName = "tgwrtp-${appName}-${region}-${id}"
                  "apiVersion": "ec2.aws.upbound.io/v1beta1",
                  "kind": "TransitGatewayRouteTablePropagation",
                  "metadata": {
                      "annotations": {
                          "krm.kcl.dev/composition-resource-name" = _resourceName,
                          "krm.kcl.dev/ready" = readystr(_resourceName),
                      },
                      "labels": labels | {
                          "vpcName" = appName,
                      }
                  },
                  "spec": {
                      "deletionPolicy": dp,
                      "forProvider": {
                          "region": region,
                          "transitGatewayAttachmentId": id,
                          "transitGatewayRouteTableId": tgwRouteTableId,
                      }
                      "managementPolicies": mgmtPolicy,
                      "providerConfigRef": pcr,
                  },
              }
              for _, id in remoteAttachementIds
              if all_true([
                  remoteAttachementIds,
                  tgwRouteTableId,
              ])
          ]

          _items = [
              i for r in [
                  remoteAttachments, attachmentAccepters,
                  remotePrefixLists, remoteRoutes,
                  remotePropagation,
              ]
              for i in r if i
          ]

          items = _items
        target: ""
    step: function-kcl-remote
  - functionRef:
      name: function-auto-ready
    step: function-auto-ready
