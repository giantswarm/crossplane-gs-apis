apiVersion: apiextensions.crossplane.io/v1
kind: Composition
metadata:
  creationTimestamp: null
  labels:
    component: networking
    provider: aws
    type: vpc
  name: peered-vpc-network
spec:
  compositeTypeRef:
    apiVersion: xnetworks.crossplane.giantswarm.io/v1alpha1
    kind: PeeredVpcNetwork
  mode: Pipeline
  pipeline:
  - functionRef:
      name: function-network-discovery
    input:
      apiVersion: xnetworks.crossplane.giantswarm.io/v1beta1
      kind: Input
      metadata:
        creationTimestamp: null
      spec:
        enabledRef: status.vpcLookup.enabled
        groupByRef: status.vpcLookup.groupBy
        patchTo: status.vpcs
        providerConfigRef: spec.providerConfigRef.name
        providerType: aws
        regionRef: spec.region
        vpcRef: status.vpcLookup.remoteVpcs
    step: network-discovery
  - functionRef:
      name: function-cidr
    input:
      apiVersion: cidr.fn.crossplane.io/v1beta1
      cidrFunc: multiprefixloop
      kind: Parameters
      metadata:
        creationTimestamp: null
      multiPrefixField: status.subnetBits
      outputField: status.calculatedCidrs
    step: function-cidr
  - functionRef:
      name: function-kcl
    input:
      apiVersion: krm.kcl.dev/v1alpha1
      kind: KCLInput
      metadata:
        creationTimestamp: null
      spec:
        source: |-
          import regex
          oxr = option("params").oxr
          dxr = option("params").dxr
          ocds = option("params").ocds
          dcds = option("params").dcds

          get = lambda x: {:}, y: str, d: any -> any {
              """
              Get an item from a dictionary using a dot separated path.
              If the item is not found, return a default value.
              """
              p = regex.split(y, "\.")
              c = p[0]
              y = ".".join(p[1:])
              x[c] if len(p) == 1 and c in x else d if c not in x else get(x[c], y, d)
          }

          exists = lambda x: any -> bool {
              """
              Check if a value exists.
              """
              x in list(ocds)
          }

          ocdsstatus = lambda x: str, y: str, d: any -> any {
              """
              Get an item from the status of an ocds resource.
              """
              _x = None
              if get(ocds, "${x}.Resource.status.atProvider", False):
                  _x = get(ocds, "${x}.Resource.status.atProvider.${y}", d)
              else:
                  _x = get(ocds, "${x}.Resource.status.${y}", d)
              _x if _x else d
          }

          ready = lambda x: str -> bool {
              """
              Check if a value is ready.
              """
              conditionsReady = all_true([
                  get(c, "status", "False") == "True" for c in ocdsstatus(x, "conditions", [])
              ])

              ap = get(ocds, "${x}.Resource.status.atProvider", {})
              objectReady = any_true([
                  ocdsstatus(x, "ready", False),
                  len(list(ap)) > 0,
              ])

              all_true([
                  any_true([exists(x), conditionsReady]),
                  objectReady,
              ])
          }

          readystr = lambda x: str -> str {
              """
              Check if a value is ready.
              """
              "True" if ready(x) else "False"
          }

          allReady = lambda -> bool {
              """
              Check if all managed resources are ready.
              """
              all_true([
                  ready(x)
                  for x in list(ocds)
              ])
          }

          getwparentfb = lambda x: {:}, p: {:}, y: str, z: str, d: any -> any {
              """
              Get with fallback to parent status
              Tries to get a path from a dictionary, if it fails,
              tries to get it from the parent dictionary.

              If that fails, falls back to the default value provided.
              """
              get(x, y, get(p, "${z}", d))
          }

          appName = get(oxr, "spec.claimRef.name", "")
          claimRef = get(oxr, "spec.claimRef", {})
          dp = get(oxr, "spec.deletionPolicy", "Delete")
          labels = get(oxr, "metadata.labels", {})
          peeringEnabled = get(oxr, "spec.peering.enabled", False)
          pcr = get(oxr, "spec.providerConfigRef", {"name": "default"})
          region = get(oxr, "spec.region", "eu-central-1")
          tags = labels | get(oxr, "spec.tags.common", {}) | {
              "region": region,
          }

          mgmtPolicy = get(oxr, "spec.managementPolicies", [])
          publishConnection = get(oxr, "spec.publishConnectionDetailsTo", {})

          chunksplit = lambda size: int subnets: [] -> [] {
              # split the subnets array into chunks of size `size`
              [] if not subnets or subnets == Undefined else [
                  subnets[i:i + size:]
                  for i in range(0, len(subnets), size)
              ]
          }

          allowsPublic = lambda vpc: str -> bool {
              a = [
                  get(x, "allowPublic", False)
                  for x in get(oxr, "spec.peering.remoteVpcs", [])
                  if x.name == vpc
              ]

              a[0] if len(a) == 1 else False
          }

          # Collect the number of requested subnet sets - you can have up to 200 subnets
          # in a VPC - this total must be below that
          requestedSets = [
              c.public.count + c.private.count
              for c in get(oxr, "spec.subnetsets.cidrs", [])
          ]

          zones = sorted(get(oxr, "spec.availabilityZones", [ "a", "b", "c" ]))

          assert sum(requestedSets)*len(zones) < 200, """
              The number of subnet sets you are requesting will exceed the maximum number
              of subnets allowed by AWS. The sum of all counts multiplied by the number of
              availability zones must be less than 200.
          """

          # The first entry in the `subnetsets.cidrs` list is the primary CIDR range for
          # the VPC.
          #
          # The remaining entries are additional CIDR ranges that can be attached with AWS
          # allowing up to 4 additional CIDR ranges.
          additionalCidrs = [
              s.prefix
              for s in oxr.spec.subnetsets.cidrs[1:]
          ]

          calculatedCidrs = get(oxr, "status.calculatedCidrs", {})
          clusterTags = get(oxr, "spec.tags.cluster", {})

          # Created checks
          vpcs = get(oxr, "status.vpcs", {})
          self = get(vpcs, "self", {})

          _ngw = [
              ngw.Resource for _, ngw in ocds if ocds and get(ngw, "Resource.kind", "") == "NATGateway"
          ]
          natgatewaysCreated = len([ngw for ngw in _ngw if ngw]) == len(zones)

          # Separate out created public and private subnets
          pubsn = [
              x
              for _, x in get(self, "publicSubnets", [])
              if self and get(self, "publicSubnets", False)
          ]

          prisn = [
              x
              for _, x in get(self, "privateSubnets", [])
              if self and get(self, "privateSubnets", False)
          ]

          # Create the SubnetSets
          #
          # SubnetSets are a collection of Subnets and RouteTables per availability zone
          # Each set logically belongs together as they share consecutive CIDR ranges
          # and have one subnet and one route table per requested availability zone (3)
          _subnetsets = [
              {
                  _subnets = chunksplit(len(zones), calculatedCidrs[s.prefix])
                  _visibility = "public" if i < get(s, "public.count", 0) else "private"
                  _index = i if _visibility == "public" else i - s.public.count

                  # this is needed for tagging the subnet sets independently of each other
                  # it creates a '-' (hyphen) separated copy of the IP address from the first
                  # subnet + the last 2 octets from the last subnet, e.g. 192-168-0-0-2-0
                  _s1 = regex.split(_subnets[i][0], "/")[0]
                  _s1hyphened = regex.replace(_s1, "\.", "-")

                  _s2 = regex.split(_subnets[i][len(zones)-1], "/")[0]
                  _s2octs = regex.split(_s2, "\.")
                  _suffix = _s1hyphened + "-" + _s2octs[2] + "-" + _s2octs[3]
                  _snlbtag = {
                      **clusterTags
                      "kubernetes.io/role/elb": "1"
                  } if _index == s.public.lbSetIndex and _visibility == "public" else {
                      **clusterTags
                      "kubernetes.io/role/internal-elb": "1"
                  } if _index == s.private.lbSetIndex and _visibility == "private" else {}

                  _resourceName = "subnetset-${_visibility}-cidr${c}-${_index}"
                  "apiVersion": "xnetworks.crossplane.giantswarm.io/v1alpha1"
                  "kind": "SubnetSet"
                  "metadata": {
                      "annotations": {
                          "krm.kcl.dev/composition-resource-name" = _resourceName
                          "krm.kcl.dev/ready" = readystr(_resourceName)
                      }
                      "labels": labels | {access: _visibility, index: _index}
                  }
                  "spec": {
                      "appIndex": _suffix
                      "claimRef": claimRef
                      "deletionPolicy": dp
                      "managementPolicies": mgmtPolicy,
                      "region": region
                      "providerConfigRef": pcr
                      "subnets": {
                          zones[j]: _subnets[i][j]
                          for j in range(len(zones))
                      }
                      "type": _visibility
                      "tags": {
                          "all": tags | get(oxr, "spec.tags.subnet", {})
                          "subnet": _snlbtag
                      }
                      "vpcId": self.id
                  }
              }
              for c, s in get(oxr, "spec.subnetsets.cidrs", [])
              for i in range(get(s, "public.count", 0) + get(s, "private.count", 0))
              if all_true([
                  calculatedCidrs, self,
                  self.id,
                  get(oxr, "spec.subnetsets.cidrs", False)
              ])
          ]

          # Set the subnetset tag and labels
          # This needs to be set for later separation of public and private subnets
          # into their respective groups but cannot be done as part of the creation due
          # to language limitations.

          _pubss = [s for s in _subnetsets if get(s, "spec.type", "") == "public"]
          _fpubss = [
              {
                  **s
                  **{
                      "metadata": {
                          labels: {
                              subnetset: "${i}"
                          }
                      }
                      "spec": {
                          tags: {
                              "all": {"giantswarm.io/subnetset": "${i}"}
                          }
                      }
                  }
              }
              for i, s in _pubss
          ]

          _priss = [s for s in _subnetsets if get(s, "spec.type", "") == "private"]
          _fpriss = [
              {
                  **s
                  **{
                      "metadata": {
                          labels: {
                              subnetset: "${i}"
                          }
                      }
                      "spec": {
                          tags: {
                              "all": {"giantswarm.io/subnetset": "${i}"}
                          }
                      }
                  }
              }
              for i, s in _priss
          ]
          subnetsets = _fpubss + _fpriss

          # Create Additional VPC CIDRs
          #
          # Each VPC may have up to 4 additional CIDRs attached
          acs = [
              {
                  _resourceName = "cidrassoc-${i}"
                  "apiVersion": "ec2.aws.upbound.io/v1beta1"
                  "kind": "VPCIPv4CidrBlockAssociation"
                  "metadata": {
                      "labels": labels
                      "annotations": {
                          "krm.kcl.dev/composition-resource-name" = _resourceName
                          "krm.kcl.dev/ready" = readystr(_resourceName)
                      }
                  }
                  spec: {
                      "deletionPolicy": dp
                      "forProvider": {
                          "cidrBlock": cidr
                          "region": region
                          "vpcIdSelector": {
                              "matchControllerRef": True
                          }
                      }
                      "managementPolicies": mgmtPolicy,
                      "providerConfigRef": pcr
                  }
              }
              for i, cidr in additionalCidrs
          ]

          # Create Elastic IPs for the nat gateways
          #
          # Each NAT Gateway must be associated with an EIP
          eips = [
              {
                  _resourceName = "eip-${i}"
                  "apiVersion": "ec2.aws.upbound.io/v1beta1"
                  "kind": "EIP"
                  "metadata": {
                      "annotations": {
                          "krm.kcl.dev/composition-resource-name" = _resourceName
                          "krm.kcl.dev/ready" = readystr(_resourceName)
                      }
                      "labels": labels | {
                          "availabilityZone": az
                          "utilization": "nat-gateway"
                      }
                  }
                  "spec": {
                      "deletionPolicy": dp
                      "forProvider": {
                          "domain": "vpc"
                          "region": region
                          "tags": tags | {
                              "Name": "${appName}-${region}${az}-${i}",
                              "utilization": "nat",
                              "availabilityZone": az,
                          }
                      }
                      "managementPolicies": mgmtPolicy,
                      "providerConfigRef": pcr
                  }
              }
              for i, az in zones if pubsn
          ]

          igw = [
              {
                  _resourceName = "internet-gateway"
                  "apiVersion": "ec2.aws.upbound.io/v1beta1"
                  "kind": "InternetGateway"
                  "metadata": {
                      "annotations": {
                          "krm.kcl.dev/composition-resource-name" = _resourceName
                          "krm.kcl.dev/ready" = readystr(_resourceName)
                      }
                      "labels": labels
                  }
                  "spec": {
                      "deletionPolicy": dp
                      "forProvider": {
                          "region": region
                          "tags": tags | {
                              "Name": "${appName}-${region}"
                          }
                          "vpcId": self.id,
                      }
                      "managementPolicies": mgmtPolicy,
                      "providerConfigRef": pcr
                  }
              } for _ in [True] if self and pubsn
          ]

          # NAT Gateways
          #
          # One NatGateway per availability zone is created and attached
          # to the first available public subnet set
          keys = [k for k in pubsn[0]] if pubsn and len(pubsn) > 0 and len(pubsn[0]) == len(zones) else []
          natgateways = [
              {
                  _resourceName = "ngw-${i}"
                  "apiVersion": "ec2.aws.upbound.io/v1beta1"
                  "kind": "NATGateway"
                  "metadata": {
                      "annotations": {
                          "krm.kcl.dev/composition-resource-name" = _resourceName
                          "krm.kcl.dev/ready" = readystr(_resourceName)
                      }
                      "labels": {
                          "availabilityZone": az
                      } | labels
                  }
                  "spec": {
                      "deletionPolicy": dp
                      "forProvider": {
                          "allocationIdSelector": {
                              "matchControllerRef": True
                              "matchLabels": {availabilityZone: az}
                          }
                          "region": region
                          "subnetId": pubsn[0][keys[i]].id
                          "tags": labels | {
                              "Name": "${appName}-${region}${az}",
                              "availabilityZone": az,
                          } | tags
                      }
                      "managementPolicies": mgmtPolicy,
                      "providerConfigRef": pcr
                  }
              }
              for i, az in zones
              if all_true([
                  pubsn,
                  len(keys) > 0,
                  len(pubsn) > 0,
                  eips
              ])
          ]

          _prirtbls = [
              x
              for _, x in get(self, "privateRouteTables", [])
              if self and get(self, "privateRouteTables", False)
          ]

          _pubrtbls = [
              x
              for _, x in get(self, "publicRouteTables", [])
              if self and get(self, "publicRouteTables", False)
          ]

          # Nat Gateway Routes
          #
          # One route per private route table
          ngwRoutes = [
              {
                  _resourceName = "ngw-rt-${rtbl[1].id}"
                  "apiVersion": "ec2.aws.upbound.io/v1beta1"
                  "kind": "Route"
                  "metadata": {
                      "annotations": {
                          "krm.kcl.dev/composition-resource-name" = _resourceName
                          "krm.kcl.dev/ready" = readystr(_resourceName)
                      }
                      "labels": {
                          "availabilityZone": rtbl[0]
                          "routeType": "ngw"
                      }
                  }
                  "spec": {
                      "deletionPolicy": dp
                      "forProvider": {
                          "destinationCidrBlock": "0.0.0.0/0"
                          "natGatewayIdSelector": {
                              "matchControllerRef": True
                              "matchLabels": {availabilityZone: rtbl[0]}
                          }
                          "region": region
                          "routeTableId": rtbl[1].id
                      }
                      "managementPolicies": mgmtPolicy,
                      "providerConfigRef": pcr
                  }
              }
              for i, x in _prirtbls
              for _, rtbl in zip(zones, [r for _, r in x])
              if pubsn and natgatewaysCreated
          ]

          # Internet Gateway Routes
          #
          # One IGW route per public route table
          igwRoutes = [
              {
                  _resourceName = "igw-rt-${rtbl[1].id}"
                  "apiVersion": "ec2.aws.upbound.io/v1beta1"
                  "kind": "Route"
                  "metadata": {
                      "annotations": {
                          "krm.kcl.dev/composition-resource-name" = _resourceName
                          "krm.kcl.dev/ready" = readystr(_resourceName)
                      }
                      "labels": {
                          "availabilityZone": rtbl[0]
                          "routeType": "igw"
                      }
                  }
                  "spec": {
                      "deletionPolicy": dp
                      "forProvider": {
                          "destinationCidrBlock": "0.0.0.0/0"
                          "gatewayIdSelector": {
                              "matchControllerRef": True
                          }
                          "region": region
                          "routeTableId": rtbl[1].id
                      }
                      "managementPolicies": mgmtPolicy,
                      "providerConfigRef": pcr
                  }
              }
              for i, x in _pubrtbls
              for _, rtbl in zip(zones, [r for _, r in x])
              if igw and pubsn
          ]

          # Create the list of items to return
          _items = [
              i for x in [
                  subnetsets, acs, eips, igw,
                  igwRoutes, natgateways, ngwRoutes
              ]
              for i in x if i
          ]

          items = _items
        target: ""
    step: function-kcl-create-resources
  - functionRef:
      name: function-kcl
    input:
      apiVersion: krm.kcl.dev/v1alpha1
      kind: KCLInput
      metadata:
        creationTimestamp: null
      spec:
        source: |-
          import regex
          oxr = option("params").oxr
          dxr = option("params").dxr
          ocds = option("params").ocds
          dcds = option("params").dcds

          get = lambda x: {:}, y: str, d: any -> any {
              """
              Get an item from a dictionary using a dot separated path.
              If the item is not found, return a default value.
              """
              p = regex.split(y, "\.")
              c = p[0]
              y = ".".join(p[1:])
              x[c] if len(p) == 1 and c in x else d if c not in x else get(x[c], y, d)
          }

          exists = lambda x: any -> bool {
              """
              Check if a value exists.
              """
              x in list(ocds)
          }

          ocdsstatus = lambda x: str, y: str, d: any -> any {
              """
              Get an item from the status of an ocds resource.
              """
              _x = None
              if get(ocds, "${x}.Resource.status.atProvider", False):
                  _x = get(ocds, "${x}.Resource.status.atProvider.${y}", d)
              else:
                  _x = get(ocds, "${x}.Resource.status.${y}", d)
              _x if _x else d
          }

          ready = lambda x: str -> bool {
              """
              Check if a value is ready.
              """
              conditionsReady = all_true([
                  get(c, "status", "False") == "True" for c in ocdsstatus(x, "conditions", [])
              ])

              ap = get(ocds, "${x}.Resource.status.atProvider", {})
              objectReady = any_true([
                  ocdsstatus(x, "ready", False),
                  len(list(ap)) > 0,
              ])

              all_true([
                  any_true([exists(x), conditionsReady]),
                  objectReady,
              ])
          }

          readystr = lambda x: str -> str {
              """
              Check if a value is ready.
              """
              "True" if ready(x) else "False"
          }

          allReady = lambda -> bool {
              """
              Check if all managed resources are ready.
              """
              all_true([
                  ready(x)
                  for x in list(ocds)
              ])
          }

          getwparentfb = lambda x: {:}, p: {:}, y: str, z: str, d: any -> any {
              """
              Get with fallback to parent status
              Tries to get a path from a dictionary, if it fails,
              tries to get it from the parent dictionary.

              If that fails, falls back to the default value provided.
              """
              get(x, y, get(p, "${z}", d))
          }

          appName = get(oxr, "spec.claimRef.name", "")
          claimRef = get(oxr, "spec.claimRef", {})
          dp = get(oxr, "spec.deletionPolicy", "Delete")
          labels = get(oxr, "metadata.labels", {})
          peeringEnabled = get(oxr, "spec.peering.enabled", False)
          pcr = get(oxr, "spec.providerConfigRef", {"name": "default"})
          region = get(oxr, "spec.region", "eu-central-1")
          tags = labels | get(oxr, "spec.tags.common", {}) | {
              "region": region,
          }

          mgmtPolicy = get(oxr, "spec.managementPolicies", [])
          publishConnection = get(oxr, "spec.publishConnectionDetailsTo", {})

          peering = [
              {
                  "apiVersion": "xnetworks.crossplane.giantswarm.io/v1alpha1"
                  "kind": "Peering"
                  "metadata": {
                      _resourceName = "peering-${remoteVpc.name}"
                      "annotations": {
                          "krm.kcl.dev/composition-resource-name" = _resourceName
                          "krm.kcl.dev/ready" = readystr(_resourceName)
                      }
                      "labels": labels | {
                          "vpcName": remoteVpc.name
                      }
                  }
                  "spec": {
                      "claimRef": claimRef
                      "deletionPolicy": dp
                      "enabled": peeringEnabled
                      "localVpcDetails": {
                          "name": get(oxr, "spec.claimRef.name", "")
                          "cidrBlocks": [
                              c for c in [
                                  get(oxr, "status.vpcs.self.cidrBlock", "")
                              ] + get(oxr, "status.vpcs.self.additionalCidrBlocks", [])
                              if c
                          ]
                          "region": region
                          "routeTableIds": [
                              i.id for r in get(oxr, "status.vpcs.self.publicRouteTables", [])
                              for _, i in r
                              if get(oxr, "spec.peering.allowPublic", True)
                          ] + [
                              i.id for r in get(oxr, "status.vpcs.self.privateRouteTables", [])
                              for _, i in r
                          ]
                          "vpcId": get(oxr, "status.vpcs.self.id", "")
                      }
                      "managementPolicies": mgmtPolicy,
                      "peerVpcDetails": {
                          "name": remoteVpc.name
                          "cidrBlocks": [
                              c for c in [
                                  get(oxr, "status.vpcs.${remoteVpc.name}.cidrBlock", "")
                              ] + get(oxr, "status.vpcs.${remoteVpc.name}.additionalCidrBlocks", [])
                              if c
                          ]
                          "region": remoteVpc.region
                          "routeTableIds": [
                              i.id for r in get(oxr, "status.vpcs.${remoteVpc.name}.publicRouteTables", [])
                              for _, i in r
                              if get(remoteVpc, "allowPublic", True)
                          ] + [
                              i.id for r in get(oxr, "status.vpcs.${remoteVpc.name}.privateRouteTables", [])
                              for _, i in r
                          ]
                          "vpcId": get(oxr, "status.vpcs.${remoteVpc.name}.id", "")
                      }
                      "tags": {
                          "Name": "${appName}-${region}-${remoteVpc.name}"
                      } | tags
                      providerConfigRef: pcr
                  }
              }
              for _, remoteVpc in get(oxr, "spec.peering.remoteVpcs", [])
              if all_true([
                  peeringEnabled,
                  get(oxr, "status.vpcs.self.id", False),
                  get(oxr, "status.vpcs.${remoteVpc.name}.id", False),
              ])
          ]

          _items = peering

          items = _items
        target: ""
    step: function-kcl-create-peering
  - functionRef:
      name: function-kcl
    input:
      apiVersion: krm.kcl.dev/v1alpha1
      kind: KCLInput
      metadata:
        creationTimestamp: null
      spec:
        source: |-
          import regex
          oxr = option("params").oxr
          dxr = option("params").dxr
          ocds = option("params").ocds
          dcds = option("params").dcds

          get = lambda x: {:}, y: str, d: any -> any {
              """
              Get an item from a dictionary using a dot separated path.
              If the item is not found, return a default value.
              """
              p = regex.split(y, "\.")
              c = p[0]
              y = ".".join(p[1:])
              x[c] if len(p) == 1 and c in x else d if c not in x else get(x[c], y, d)
          }

          exists = lambda x: any -> bool {
              """
              Check if a value exists.
              """
              x in list(ocds)
          }

          ocdsstatus = lambda x: str, y: str, d: any -> any {
              """
              Get an item from the status of an ocds resource.
              """
              _x = None
              if get(ocds, "${x}.Resource.status.atProvider", False):
                  _x = get(ocds, "${x}.Resource.status.atProvider.${y}", d)
              else:
                  _x = get(ocds, "${x}.Resource.status.${y}", d)
              _x if _x else d
          }

          ready = lambda x: str -> bool {
              """
              Check if a value is ready.
              """
              conditionsReady = all_true([
                  get(c, "status", "False") == "True" for c in ocdsstatus(x, "conditions", [])
              ])

              ap = get(ocds, "${x}.Resource.status.atProvider", {})
              objectReady = any_true([
                  ocdsstatus(x, "ready", False),
                  len(list(ap)) > 0,
              ])

              all_true([
                  any_true([exists(x), conditionsReady]),
                  objectReady,
              ])
          }

          readystr = lambda x: str -> str {
              """
              Check if a value is ready.
              """
              "True" if ready(x) else "False"
          }

          allReady = lambda -> bool {
              """
              Check if all managed resources are ready.
              """
              all_true([
                  ready(x)
                  for x in list(ocds)
              ])
          }

          getwparentfb = lambda x: {:}, p: {:}, y: str, z: str, d: any -> any {
              """
              Get with fallback to parent status
              Tries to get a path from a dictionary, if it fails,
              tries to get it from the parent dictionary.

              If that fails, falls back to the default value provided.
              """
              get(x, y, get(p, "${z}", d))
          }

          appName = get(oxr, "spec.claimRef.name", "")
          claimRef = get(oxr, "spec.claimRef", {})
          dp = get(oxr, "spec.deletionPolicy", "Delete")
          labels = get(oxr, "metadata.labels", {})
          peeringEnabled = get(oxr, "spec.peering.enabled", False)
          pcr = get(oxr, "spec.providerConfigRef", {"name": "default"})
          region = get(oxr, "spec.region", "eu-central-1")
          tags = labels | get(oxr, "spec.tags.common", {}) | {
              "region": region,
          }

          mgmtPolicy = get(oxr, "spec.managementPolicies", [])
          publishConnection = get(oxr, "spec.publishConnectionDetailsTo", {})

          _ram = get(oxr, "spec.ram", {enabled: False})
          _tgwRam = get(oxr, "spec.transitGateway.ram", {enabled: False})

          # If we have both RAM and TGW RAM enabled, we need to disable TGW RAM
          # as it will be built as part of the VPC
          if _tgwRam.enabled and _ram.enabled:
              _tgwRam.enabled = False

          localRouteTableIds = [
              i.id
              for _, r in get(oxr, "status.vpcs.self.publicRouteTables", [])
              for _, i in r
              if all_true([
                  get(oxr, "spec.transitGateway.allowPublic", True),
                  get(oxr, "status.vpcs.self.publicRouteTables", False),
              ])
          ] + [
              i.id
              for _, r in get(oxr, "status.vpcs.self.privateRouteTables", [])
              for _, i in r
          ]

          preferPublic = all_true([
              get(oxr, "spec.transitGateway.preferPublicAttachments", False),
              get(oxr, "spec.transitGateway.allowPublic", False),
              get(oxr, "status.vpcs.self.publicSubnets", False),
          ])

          # We can only use one subnet in each availability zone for the TGW attachment
          localSubnetIds = [
              i.id
              for j, r in get(oxr, "status.vpcs.self.publicSubnets", [])
              for _, i in r
              if all_true([
                  j == 0,
                  preferPublic,
              ])
          ] if preferPublic else [
              i.id for j, r in get(oxr, "status.vpcs.self.privateSubnets", [])
              for _, i in r
              if j == 0
          ]

          localVpc = {
              "cidrBlocks": [
                  c for _, c in [
                      get(oxr, "status.vpcs.self.cidrBlock", "")
                  ] + get(oxr, "status.vpcs.self.additionalCidrBlocks", [])
                  if c
              ],

              if get(oxr, "spec.prefixLists", False):
                  "prefixLists": [
                      {
                          blackhole: pl.blackhole,
                          pl.id: get(oxr, "status.prefixLists.${pl.name}", pl.name),
                      }
                      for _, pl in get(oxr, "spec.prefixLists", [])
                  ]

              "region": get(oxr, "spec.region", ""),
              "routeTableIds": localRouteTableIds,
              "subnetIds": localSubnetIds,

              if get(oxr, "status.vpcs.self.id", False):
                  "vpcId": get(oxr, "status.vpcs.self.id", ""),

          } if all_true([
              get(oxr, "status.vpcs.self.id", False),
              localRouteTableIds,
              localSubnetIds,
          ]) else {}

          remoteVpcs = [
              {
                  _subnetIds = [
                      i.id for j, r in get(oxr, "status.vpcs.${vpc.name}.publicSubnets", [])
                      for _, i in r
                      if all_true([
                          j == 0
                          get(vpc, "allowPublic", True)
                          preferPublic
                      ])
                  ] if all_true([
                      preferPublic,
                      get(vpc, "allowPublic", True),
                  ]) else [
                      i.id for j, r in get(oxr, "status.vpcs.${vpc.name}.privateSubnets", [])
                      for _, i in r
                      if j == 0
                  ]
                  "cidrBlocks": [
                      c for _, c in [
                          get(oxr, "status.vpcs.${vpc.name}.cidrBlock", "")
                      ] + get(oxr, "status.vpcs.${vpc.name}.additionalCidrBlocks", [])
                      if c
                  ],
                  "name": vpc.name,
                  "region": get(oxr, "status.vpcs.${vpc.name}.region", ""),
                  "routeTableIds": [
                      i.id for r in get(oxr, "status.vpcs.${vpc.name}.publicRouteTables", [])
                      for _, i in r
                      if get(oxr, "spec.transitGateway.allowPublic", True)
                  ] + [
                      i.id for r in get(oxr, "status.vpcs.${vpc.name}.privateRouteTables", [])
                      for _, i in r
                  ],
                  "subnetIds": _subnetIds,
                  "vpcId": get(oxr, "status.vpcs.${vpc.name}.id", ""),
              }
              for _, vpc in get(oxr, "spec.transitGateway.remoteVpcs", [])
              if get(oxr, "status.vpcs.${vpc.name}.id", False)
          ]

          # Transit Gateway Peers
          #
          # For peer to peer TGWs, at the remote TGW must be attached to one of the remote
          # VPCs.
          #
          # A possible future extention is to move `status.vpcs` down one level, maybe to
          # `status.region.vpcs` to allow for multiple regions to be managed by the
          # `network lookup` composition function. This would allow for discovery of
          # additional components that fit outside of the current framework however it
          # would be a huge breaking change on the API.
          #
          # Another option would be to
          transitGatewayPeers = [
              {
                  _aid = getwparentfb(peer, oxr, "accountId", "status.vpcs.self.owner", ""),
                  "accountId": _aid,
                  "id": peer.id,
                  "providerConfigRef": get(peer, "providerConfigRef", pcr),
                  "region": get(peer, "region", region),
              }
              for _, peer in get(oxr, "spec.transitGateway.peers", [])
              if get(peer, "id", False)
          ] + [
              {
                  "accountId": peer.accountId,
                  "id": tgw.id,
                  "providerConfigRef": get(peer, "providerConfigRef", pcr),
                  "region": peer.region,
              }
              for _, peer in get(oxr, "spec.transitGateway.peers", [])
              for _, vpc in get(oxr, "status.vpcs", [])
              for name, tgw in get(vpc, "transitGateways", [])
              if all_true([
                  get(peer, "name", False),
                  name == get(peer, "name", False),
                  not get(peer, "id", False),
                  get(peer, "accountId", False) == get(vpc, "owner", ""),
                  get(peer, "region", False) == get(vpc, "region", ""),
              ])
          ]

          tgw = {
              _resourceName = "transitgw",
              "apiVersion": "xnetworks.crossplane.giantswarm.io/v1alpha1",
              "kind": "TransitGateway",
              "metadata": {
                  "annotations": {
                      "krm.kcl.dev/composition-resource-name": _resourceName,
                      "krm.kcl.dev/ready": readystr(_resourceName),
                  }
                  "labels": labels,
              },
              "spec": {
                  "deletionPolicy": get(oxr, "spec.deletionPolicy", "Delete"),
                  "claimRef": get(oxr, "spec.claimRef", {}),
                  if get(oxr, "spec.amazonSideAsn", False):
                      "amazonSideAsn": get(oxr, "spec.amazonSideAsn", 64512),
                  if get(oxr, "spec.applianceModeSupport", False):
                      "applianceModeSupport": get(oxr, "spec.applianceModeSupport", "disable"),
                  if get(oxr, "spec.autoAcceptSharedAttachments", False):
                      "autoAcceptSharedAttachments": get(oxr, "spec.autoAcceptSharedAttachments", "disable"),
                  if get(oxr, "spec.createPolicyTable", False):
                      "createPolicyTable": get(oxr, "spec.createPolicyTable", "disable"),
                  if get(oxr, "spec.defaultRouteTableAssociation", False):
                      "defaultRouteTableAssociation": get(oxr, "spec.defaultRouteTableAssociation", "disable"),
                  if get(oxr, "spec.defaultRouteTablePropagation", False):
                      "defaultRouteTablePropagation": get(oxr, "spec.defaultRouteTablePropagation", "disable"),
                  if get(oxr, "spec.dnsSupport", False):
                      "dnsSupport": get(oxr, "spec.dnsSupport", "disable"),
                  if get(oxr, "spec.ipv6Support", False):
                      "ipv6Support": get(oxr, "spec.ipv6Support", "disable"),

                  "localVpc": localVpc,
                  "managementPolicies": mgmtPolicy,

                  if get(oxr, "spec.multicastSupport", False):
                      "multicastSupport": get(oxr, "spec.multicastSupport", "disable"),
                  if get(oxr, "spec.prefixListSupport", False):
                      "prefixListSupport": get(oxr, "spec.prefixListSupport", "disable"),

                  if get(_ram, "enabled", False):
                      "ram": _ram,

                  "remoteVpcs": remoteVpcs,

                  if get(oxr, "spec.transitGatewayCidrBlocks", False):
                      "transitGatewayCidrBlocks": get(oxr, "spec.transitGatewayCidrBlocks", []),
                  if get(oxr, "spec.transitGatewayRouteTableAssociation", False):
                      "transitGatewayRouteTableAssociation": get(oxr, "spec.transitGatewayRouteTableAssociation", "disable"),
                  if get(oxr, "spec.transitGatewayRouteTablePropagation", False):
                      "transitGatewayRouteTablePropagation": get(oxr, "spec.transitGatewayRouteTablePropagation", "disable"),

                  "peers": transitGatewayPeers,

                  "tags": get(oxr, "spec.tags.common", []),

                  if get(oxr, "spec.vpnEcmpSupport", False):
                      "vpnEcmpSupport": get(oxr, "spec.vpnEcmpSupport", "disable"),

                  "providerConfigRef": get(oxr, "spec.providerConfigRef", {}),
              }
          }

          print("TGW VPC", localVpc)
          print("TGW RVPC", remoteVpcs)
          print("TGW LSNIDs", localSubnetIds)
          print("TGW LRTIDs", localRouteTableIds)
          print("TGW ENABLED", get(oxr, "spec.transitGateway.enabled", False))
          print("TGW LENs MATCH", len(remoteVpcs) == len(get(oxr, "spec.transitGateway.remoteVpcs", [])))

          _items = [
              tgw
              for _ in [True]
              if all_true([
                  localVpc,
                  remoteVpcs,
                  localSubnetIds,
                  localRouteTableIds,
                  get(oxr, "spec.transitGateway.enabled", False),
                  len(remoteVpcs) == len(get(oxr, "spec.transitGateway.remoteVpcs", [])),
              ])
          ]

          items = _items
        target: ""
    step: function-kcl-create-transit-gateway
  - functionRef:
      name: function-kcl
    input:
      apiVersion: krm.kcl.dev/v1alpha1
      kind: KCLInput
      metadata:
        creationTimestamp: null
      spec:
        source: |-
          import regex
          oxr = option("params").oxr
          dxr = option("params").dxr
          ocds = option("params").ocds
          dcds = option("params").dcds

          get = lambda x: {:}, y: str, d: any -> any {
              """
              Get an item from a dictionary using a dot separated path.
              If the item is not found, return a default value.
              """
              p = regex.split(y, "\.")
              c = p[0]
              y = ".".join(p[1:])
              x[c] if len(p) == 1 and c in x else d if c not in x else get(x[c], y, d)
          }

          exists = lambda x: any -> bool {
              """
              Check if a value exists.
              """
              x in list(ocds)
          }

          ocdsstatus = lambda x: str, y: str, d: any -> any {
              """
              Get an item from the status of an ocds resource.
              """
              _x = None
              if get(ocds, "${x}.Resource.status.atProvider", False):
                  _x = get(ocds, "${x}.Resource.status.atProvider.${y}", d)
              else:
                  _x = get(ocds, "${x}.Resource.status.${y}", d)
              _x if _x else d
          }

          ready = lambda x: str -> bool {
              """
              Check if a value is ready.
              """
              conditionsReady = all_true([
                  get(c, "status", "False") == "True" for c in ocdsstatus(x, "conditions", [])
              ])

              ap = get(ocds, "${x}.Resource.status.atProvider", {})
              objectReady = any_true([
                  ocdsstatus(x, "ready", False),
                  len(list(ap)) > 0,
              ])

              all_true([
                  any_true([exists(x), conditionsReady]),
                  objectReady,
              ])
          }

          readystr = lambda x: str -> str {
              """
              Check if a value is ready.
              """
              "True" if ready(x) else "False"
          }

          allReady = lambda -> bool {
              """
              Check if all managed resources are ready.
              """
              all_true([
                  ready(x)
                  for x in list(ocds)
              ])
          }

          getwparentfb = lambda x: {:}, p: {:}, y: str, z: str, d: any -> any {
              """
              Get with fallback to parent status
              Tries to get a path from a dictionary, if it fails,
              tries to get it from the parent dictionary.

              If that fails, falls back to the default value provided.
              """
              get(x, y, get(p, "${z}", d))
          }

          appName = get(oxr, "spec.claimRef.name", "")
          claimRef = get(oxr, "spec.claimRef", {})
          dp = get(oxr, "spec.deletionPolicy", "Delete")
          labels = get(oxr, "metadata.labels", {})
          peeringEnabled = get(oxr, "spec.peering.enabled", False)
          pcr = get(oxr, "spec.providerConfigRef", {"name": "default"})
          region = get(oxr, "spec.region", "eu-central-1")
          tags = labels | get(oxr, "spec.tags.common", {}) | {
              "region": region,
          }

          mgmtPolicy = get(oxr, "spec.managementPolicies", [])
          publishConnection = get(oxr, "spec.publishConnectionDetailsTo", {})

          privateSubnetsetKeys = sorted([
                k for k in ocds
                if all_true([
                  ocds,
                  get(ocds, "${k}.Resource.kind", "") == "SubnetSet",
                  get(ocds, "${k}.Resource.spec.type", "") == "private"
                ])
          ])

          publicSubnetsetKeys = sorted([
                k for k in ocds
                if all_true([
                  ocds,
                  get(ocds, "${k}.Resource.kind", "") == "SubnetSet",
                  get(ocds, "${k}.Resource.spec.type", "") == "public"
                ])
          ])

          privateRouteTables = [
                {
                    key = {"id": value}
                    for key, value in get(ocds, "${k}.Resource.status.routeTables", {})
                }
                for _, k in privateSubnetsetKeys
          ]

          privateSubnets = [
                {
                    key = {"id": value}
                    for key, value in get(ocds, "${k}.Resource.status.subnets", {})
                }
                for _, k in privateSubnetsetKeys
          ]

          publicRouteTables = [
                {
                    key = {"id": value}
                    for key, value in get(ocds, "${k}.Resource.status.routeTables", {})
                }
                for _, k in publicSubnetsetKeys
          ]

          publicSubnets = [
                {
                    key = {"id": value}
                    for key, value in get(ocds, "${k}.Resource.status.subnets", {})
                }
                for _, k in publicSubnetsetKeys
          ]

          groupByPeer = get(oxr, "spec.peering.groupBy", False)
          groupByTgw = get(oxr, "spec.transitGateway.groupBy", False)
          if groupByPeer and groupByTgw and groupByPeer != groupByTgw:
              assert False, "peering.groupBy and transitGateway.groupBy must be the same if both set"

          groupBy = groupByPeer if groupByPeer else groupByTgw if groupByTgw else "giantswarm.io/subnetset"

          vpcLookup = {
              "groupBy": groupBy
              "enabled": any_true([
                  get(oxr, "spec.transitGateway.enabled", False),
                  get(oxr, "spec.peering.enabled", False)
              ])
              "remoteVpcs": [
                  {
                      "name": vpc.name
                      "providerConfigRef": get(vpc, "providerConfigRef.name", pcr.name)
                      "region": get(vpc, "region", region)
                  }
                  for _, vpc in get(oxr, "spec.transitGateway.remoteVpcs", [])
                  if get(oxr, "spec.transitGateway.enabled", False)
              ] + [
                  {
                      "name": vpc.name
                      "providerConfigRef": get(vpc, "providerConfigRef.name", pcr.name)
                      "region": get(vpc, "region", region)
                  }
                  for _, vpc in get(oxr, "spec.peering.remoteVpcs", [])
                  if get(oxr, "spec.peering.enabled", False)
              ]
          }

          cidrs = [
              s.prefix
              for s in get(oxr, "spec.subnetsets.cidrs", [])
              if s
          ]

          azl = len(get(oxr, "spec.availabilityZones", []))

          igwId = ocdsstatus("internet-gateway", "id", False)

          m = lambda x: str -> int {
              """
              Get the mask as an integer value
              """
              ip_mask = x.split("/")
              int(ip_mask[1]) if len(ip_mask) == 2 else int(ip_mask[0])
          }

          cb = lambda x: str, s: int, c: int -> [] {
              """
              Create 3 subnet bits for each subnet group requested

              :param x: The mask of the subnet
              :param s: The size of the vpc prefix
              :param c: The number of subnets requested
              """
              [m(x) - s for _ in range(azl) for _ in range(c) if c > 0 and x]
          }

          newdxr = {
              **dxr
              **{
                  "status" = {
                      "subnetBits" = [
                          {
                              _vpcSize = s.prefix.split("/")[1]
                              _public = s.public.count
                              _private = s.private.count
                              _x = int(_vpcSize)
                              "prefix": s.prefix
                              "offset": m(s.offset) - _x if s.offset else 0
                              "newBits": cb(s.public.mask, _x, s.public.count) + cb(s.private.mask, _x, s.private.count)
                          }
                          for s in get(oxr, "spec.subnetsets.cidrs", {}) if s
                      ],
                      "vpcLookup" = vpcLookup,
                      "vpcs" = {
                          "self": {
                              if len(cidrs) > 1:
                                  "additionalCidrBlocks" = cidrs[1:]
                              if cidrs:
                                  "cidrBlock": cidrs[0]
                              if igwId:
                                  "internetGateway" = igwId
                              if publicRouteTables:
                                  "publicRouteTables" = publicRouteTables
                              if publicSubnets:
                                  "publicSubnets" = publicSubnets
                              if privateRouteTables:
                                  "privateRouteTables" = privateRouteTables
                              if privateSubnets:
                                  "privateSubnets" = privateSubnets

                              if get(pcr, "name", False):
                                  "providerConfig" = pcr.name

                              if region:
                                  "region" = region

                              "natGateways" = {
                                  name = get(item, "Resource.status.atProvider.id", "")
                                  for name, item in ocds
                                  if all_true([
                                      ocds,
                                      get(item, "Resource.kind", "") == "NATGateway"
                                      get(item, "Resource.status.atProvider.id", False)
                                  ])
                              }
                              "transitGateways" = {
                                  name = {
                                      "id": get(item, "Resource.status.atProvider.id", ""),
                                  }
                                  for name, item in ocds
                                  if all_true([
                                      ocds,
                                      get(item, "Resource.kind", "") == "TransitGateway"
                                      get(item, "Resource.apiVersion", "") == "xnetworks.crossplane.giantswarm.io/v1alpha1"
                                      get(item, "Resource.status.tgwId", False)
                                  ])
                              }

                              "vpcPeeringConnections" = {
                                  name = {
                                      "id": get(item, "Resource.status.peeringConnectionId", ""),
                                      "arn": get(item, "Resource.status.peeringConnectionArn", ""),
                                  }
                                  for name, item in ocds
                                  if all_true([
                                      ocds,
                                      get(item, "Resource.kind", "") == "Peering"
                                      get(item, "Resource.apiVersion", "") == "xnetworks.crossplane.giantswarm.io/v1alpha1"
                                      get(item, "Resourece.status.peeringConnectionId", False)
                                      get(item, "Resource.status.peeringConnectionArn", False)
                                  ])
                              }
                          }
                      },

                      "ready" = allReady(),
                  }
              }
          }

          _items = [
              newdxr,
          ]

          items = _items
        target: ""
    step: function-kcl-patch-xr
  - functionRef:
      name: function-patch-and-transform
    input:
      apiVersion: pt.crossplane.io/v1beta1
      kind: Resources
      metadata:
        creationTimestamp: null
      patchSets:
      - name: metadata
        patches:
        - fromFieldPath: metadata.labels
          policy:
            toFieldPath: MergeObjects
          toFieldPath: metadata.labels
          type: FromCompositeFieldPath
        - fromFieldPath: spec.region
          toFieldPath: metadata.labels.region
          type: FromCompositeFieldPath
        - fromFieldPath: spec.providerConfigRef
          toFieldPath: spec.providerConfigRef
          type: FromCompositeFieldPath
        - fromFieldPath: spec.deletionPolicy
          toFieldPath: spec.deletionPolicy
          type: FromCompositeFieldPath
      - name: commontags
        patches:
        - fromFieldPath: spec.tags.common
          policy:
            toFieldPath: MergeObjects
          toFieldPath: spec.forProvider.tags
          type: FromCompositeFieldPath
        - fromFieldPath: metadata.labels
          policy:
            toFieldPath: MergeObjects
          toFieldPath: spec.forProvider.tags
          type: FromCompositeFieldPath
        - fromFieldPath: spec.region
          toFieldPath: spec.forProvider.tags.region
          type: FromCompositeFieldPath
      resources:
      - base:
          apiVersion: ec2.aws.upbound.io/v1beta1
          kind: VPC
          metadata:
            creationTimestamp: null
          spec:
            forProvider:
              enableDnsHostnames: true
              enableDnsSupport: true
              region: null
            initProvider: {}
          status:
            atProvider: {}
        name: vpc
        patches:
        - fromFieldPath: spec.region
          toFieldPath: spec.forProvider.region
          type: FromCompositeFieldPath
        - fromFieldPath: spec.subnetsets.cidrs[0].prefix
          toFieldPath: spec.forProvider.cidrBlock
          type: FromCompositeFieldPath
        - patchSetName: commontags
          type: PatchSet
        - fromFieldPath: spec.managementPolicies
          toFieldPath: spec.managementPolicies
          type: FromCompositeFieldPath
        - fromFieldPath: spec.claimRef.name
          toFieldPath: spec.forProvider.tags.Name
          type: FromCompositeFieldPath
        - patchSetName: metadata
          type: PatchSet
        - fromFieldPath: status.atProvider.id
          toFieldPath: status.vpcs.self.id
          type: ToCompositeFieldPath
      - base:
          apiVersion: ec2.aws.upbound.io/v1beta1
          kind: DefaultSecurityGroup
          metadata:
            creationTimestamp: null
          spec:
            forProvider:
              region: null
              vpcIdSelector:
                matchControllerRef: true
            initProvider: {}
          status:
            atProvider: {}
        name: default-sg-control
        patches:
        - fromFieldPath: spec.region
          toFieldPath: spec.forProvider.region
          type: FromCompositeFieldPath
        - patchSetName: commontags
          type: PatchSet
        - patchSetName: metadata
          type: PatchSet
        - fromFieldPath: spec.managementPolicies
          toFieldPath: spec.managementPolicies
          type: FromCompositeFieldPath
    step: patch-and-transform
  - functionRef:
      name: function-auto-ready
    step: function-auto-ready
