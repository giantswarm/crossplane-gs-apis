apiVersion: apiextensions.crossplane.io/v1
kind: Composition
metadata:
  creationTimestamp: null
  labels:
    provider: github
    type: repository
  name: github-repo
spec:
  compositeTypeRef:
    apiVersion: xgithubrepo.crossplane.giantswarm.io/v1alpha1
    kind: GithubRepo
  mode: Pipeline
  pipeline:
  - functionRef:
      name: function-extra-resources
    input:
      apiVersion: extra-resources.fn.crossplane.io/v1beta1
      kind: Input
      metadata:
        creationTimestamp: null
      spec:
        extraResources:
        - apiVersion: v1
          into: githubAppCredentials
          kind: Secret
          selector:
            matchLabels:
            - key: github-app-secret
              type: FromCompositeFieldPath
              valueFromFieldPath: spec.githubAppSecretLabelValue
            maxMatch: 1
            minMatch: 1
          type: Selector
    step: pull-github-secret
  - functionRef:
      name: function-github-app-get-token
    input:
      apiVersion: github-app-get-token.fn.crossplane.giantswarm.io/v1beta1
      kind: Input
      metadata:
        creationTimestamp: null
      secretKey: githubAppCredentials
    step: get-github-token
  - functionRef:
      name: function-shell-idp
    input:
      apiVersion: template.fn.crossplane.io/v1alpha1
      kind: Parameters
      metadata:
        creationTimestamp: null
      shell: bash
      shellCommand: "#!/bin/bash\nset -e\n\n# Added function for logging with timestamps\nlog()
        {\n\techo \"$(date '+%Y-%m-%d %H:%M:%S') - $*\"\n}\n\nlog \"Starting script\"\n#
        Check that all required environment variables are set\nfor var in GITHUB_TOKEN
        REPO_OWNER REPO_NAME REGISTRY_DOMAIN BACKSTAGE_ENTITY_OWNER BACKSTAGE_ENTITY_LIFECYCLE
        REPO_DESCRIPTION REPO_VISIBILITY REPO_TEMPLATE_SOURCE; do\n\tif [ -z \"${!var:-}\"
        ]; then\n\t\techo \"Error: $var is not set.\"\n\t\texit 1\n\tfi\ndone\n\nlog
        \"Starting clone and render pipeline\"\n\ncd /tmp\n# Create and clone repository
        using gh CLI\nlog \"Checking if repository ${REPO_OWNER}/${REPO_NAME} exists\"\nREPO_INFO=$(gh
        repo view \"${REPO_OWNER}/${REPO_NAME}\" --json owner,name,visibility 2>/dev/null
        || echo \"{}\")\nif jq -e . >/dev/null 2>&1 <<<\"$REPO_INFO\" && [ \"$(jq
        -r '.name' <<<\"$REPO_INFO\")\" != \"null\" ]; then\n\tlog \"Repository ${REPO_OWNER}/${REPO_NAME}
        already exists, checking configuration\"\n\n\tREPO_OWNER_ACTUAL=$(echo \"$REPO_INFO\"
        | jq -r '.owner.login')\n\tREPO_NAME_ACTUAL=$(echo \"$REPO_INFO\" | jq -r
        '.name')\n\tREPO_VISIBILITY_ACTUAL=$(echo \"$REPO_INFO\" | jq -r '.visibility')\n\n\tif
        [ \"$REPO_OWNER_ACTUAL\" != \"$REPO_OWNER\" ]; then\n\t\tlog \"Error: Repository
        owner does not match. Expected: ${REPO_OWNER}, Actual: ${REPO_OWNER_ACTUAL}\"\n\t\texit
        1\n\tfi\n\n\tif [ \"$REPO_NAME_ACTUAL\" != \"$REPO_NAME\" ]; then\n\t\tlog
        \"Error: Repository name does not match. Expected: ${REPO_NAME}, Actual: ${REPO_NAME_ACTUAL}\"\n\t\texit
        1\n\tfi\n\n\tREPO_VISIBILITY_EXPECTED=$(echo \"$REPO_VISIBILITY\" | tr '[:lower:]'
        '[:upper:]')\n\tif [ \"$REPO_VISIBILITY_ACTUAL\" != \"$REPO_VISIBILITY_EXPECTED\"
        ]; then\n\t\tlog \"Error: Repository visibility does not match. Expected:
        ${REPO_VISIBILITY}, Actual: ${REPO_VISIBILITY_ACTUAL}\"\n\t\texit 1\n\tfi\n\n\tlog
        \"Repository ${REPO_OWNER}/${REPO_NAME} already exists and configuration matches,
        skipping creation\"\nelse\n\tlog \"Creating repository ${REPO_OWNER}/${REPO_NAME}
        using gh CLI\"\n\tgh repo create \"${REPO_OWNER}/${REPO_NAME}\" -d \"${REPO_DESCRIPTION}\"
        \"--${REPO_VISIBILITY}\" -p \"${REPO_TEMPLATE_SOURCE}\" || true\n\t#FIXME:
        github is a bit slow sometimes and the created repo can be empty if cloned
        immediately\n\tsleep 2\nfi\n# Change directory: assume local folder is the
        same as repo name\nrm -rf \"${REPO_NAME}\" || true\ngh repo clone \"${REPO_OWNER}/${REPO_NAME}\"
        2>&1\ncd \"${REPO_NAME}\"\n\n# Check if repository was initialized\nGIT_LOG_INIT_MESSAGE=\"Initial
        commit: fill in template values\"\ngit_out=$(git log --grep \"^${GIT_LOG_INIT_MESSAGE}\\$\")\nif
        [[ -n \"$git_out\" ]]; then\n\tlog \"Repository was already initialized\"\n\texit
        0\nelse\n\tlog \"Repository wasn't initialized, proceeding with templating.\"\nfi\n\n#
        Template processing (same as previous logic)\nlog \"Preparing template files.\"\nNEW_PATH=$(mktemp
        -d)\ncp -a \"./project-template/\" \"$NEW_PATH/\"\n\ncat >\"$NEW_PATH/boilerplate-values.yml\"
        <<EOF\nBackstageEntityOwner: ${BACKSTAGE_ENTITY_OWNER}\nBackstageEntityLifecycle:
        ${BACKSTAGE_ENTITY_LIFECYCLE}\nProjectName: ${REPO_NAME}\nRepoOwner: ${REPO_OWNER}\nImageName:
        ${REPO_NAME}\nRegistryDomain: ${REGISTRY_DOMAIN}\nRegistryName: ${REPO_OWNER}\nEOF\n\n#
        Remove all tracked files before rendering\ngit rm -r '*' || true\n\nlog \"Running
        boilerplate command to render template\"\nboilerplate --non-interactive --template-url
        \"$NEW_PATH\"/project-template --output-folder . --var-file \"$NEW_PATH\"/boilerplate-values.yml\n\n#
        Stage and commit changes\ngit add -A\nset +e\nlog \"Running pre-commit hooks\"\npre-commit
        run -a\nset -e\ngit add -A\n\n# git config user.email \"giant-idp@bots.github.com\"\n#
        git config user.name \"Giant IDP Bot\"\n# log \"Commit all the changes\"\n#
        git commit -am \"$GIT_LOG_INIT_MESSAGE\"\n#\n# log \"Pushing changes to main
        branch\"\n# git push origin main\n# git tag -m \"Initial release\" \"0.1.0\"\n#
        git push origin \"0.1.0\"\n#\n# git push origin main\n\nlog \"Pipeline finished
        successfully\""
      shellEnvVars:
      - key: GITHUB_TOKEN
        valueRef: context[apiextensions.crossplane.io/github-app-get-token].github-token
      - key: REPO_OWNER
        valueRef: spec.repository.owner
      - key: REPO_NAME
        valueRef: spec.repository.name
      - key: REPO_DESCRIPTION
        valueRef: spec.repository.description
      - key: REPO_VISIBILITY
        valueRef: spec.repository.visibility
      - key: REPO_TEMPLATE_SOURCE
        valueRef: spec.repository.templateSource
      - key: BACKSTAGE_ENTITY_OWNER
        valueRef: spec.backstageCatalogEntity.owner
      - key: BACKSTAGE_ENTITY_LIFECYCLE
        valueRef: spec.backstageCatalogEntity.lifecycle
      - key: REGISTRY_DOMAIN
        value: ghcr.io
      shellEnvVarsRef: {}
      stderrField: status.repoInitShellScript.stderr
      stdoutField: status.repoInitShellScript.stdout
    step: execute-gh-script
  - functionRef:
      name: function-kcl
    input:
      apiVersion: krm.kcl.dev/v1alpha1
      kind: KCLInput
      metadata:
        creationTimestamp: null
      spec:
        source: |-
          import regex

          oxr = option("params").oxr
          dxr = option("params").dxr
          ocds = option("params").ocds
          dcds = option("params").dcds

          get = lambda x: {:}, y: str, d: any -> any {
              """
              Get an item from a dictionary using a dot separated path.
              If the item is not found, return a default value.
              """
              p = regex.split(y, "\.")
              c = p[0]
              y = ".".join(p[1::])
              x[c] if len(p) == 1 and c in x else d if c not in x else get(x[c], y, d)
          }

          exists = lambda x: any -> bool {
              """
              Check if a value exists.
              """
              x in list(ocds)
          }

          ocdsstatus = lambda x: str, y: str, d: any -> any {
              """
              Get an item from the status of an ocds resource.
              """
              _x = None
              if get(ocds, "${x}.Resource.status.atProvider", False):
                  _x = get(ocds, "${x}.Resource.status.atProvider.${y}", d)
              else:
                  _x = get(ocds, "${x}.Resource.status.${y}", d)
              _x if _x else d
          }
          # Unlike other compositions in this series,
          # provisioning does not always have `atProvider` status.
          #
          # This means we can only rely on the conditions of resources
          # and not add a confirmation step to the validation.
          ready = lambda x: str -> bool {
              """
              Check if a value is ready.
              """
              conditionsReady = all_true([get(c, "status", "False") == "True" for c in ocdsstatus(x, "conditions", [])])
              any_true([exists(x), conditionsReady])
          }

          allReady = lambda -> bool {
              """
              Check if all managed resources are ready.
              """
              all_true([ready(x) for x in list(ocds)])
          }

          readystr = lambda x: str -> str {
              """
              Check if a value is ready.
              """
              "True" if ready(x) else "False"
          }

          name = get(oxr, "metadata.name", "THIS_SHALL_NOT_HAPPEN")
          namespace = get(oxr, "metadata.namespace", "THIS_SHALL_NOT_HAPPEN")

          _items = []

          configMap = {
              "apiVersion": "v1"
              "kind": "ConfigMap"
              "metadata": {
                  "name": oxr["spec"]["claimRef"]["name"] + "-info"
                  "namespace": oxr["spec"]["claimRef"]["namespace"]
              }
              "data": {
                  "repoName": oxr["spec"]["repository"]["name"]
                  "repoOwner": oxr["spec"]["repository"]["owner"]
                  "repoVisibility": oxr["spec"]["repository"]["visibility"]
                  "repoProvider": "github"
                  "fluxHelmRepositoryName": oxr["metadata"]["name"]
                  "registryInfoConfigMapName": oxr["spec"]["registryInfoConfigMapRef"]["name"]
              }
          }

          wrappedConfigMap = {
              "apiVersion": "kubernetes.crossplane.io/v1alpha2"
              "kind": "Object"
              "metadata": {
                  "annotations": {
                      "krm.kcl.dev/composition-resource-name" = "${name}-config-map"
                      "krm.kcl.dev/ready": readystr("${name}-helm-repository")
                  }
              }
              "spec": {
                  "deletionPolicy": "Delete"
                  "forProvider": {
                      "manifest": configMap
                  }
                  "managementPolicies": ["*"]
                  "providerConfigRef": get(oxr, "spec.kubernetesProviderConfig", {"name": "default"})
              }
          }

          _items += [wrappedConfigMap]

          items = _items
        target: ""
    step: function-provision-configmap
  - functionRef:
      name: function-auto-ready
    step: function-auto-ready
