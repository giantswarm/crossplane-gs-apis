apiVersion: apiextensions.crossplane.io/v1
kind: Composition
metadata:
  creationTimestamp: null
  labels:
    provider: github
    type: repository
  name: github-repo
spec:
  compositeTypeRef:
    apiVersion: xgithubrepo.crossplane.giantswarm.io/v1alpha1
    kind: GithubRepo
  mode: Pipeline
  pipeline:
  - functionRef:
      name: function-extra-resources
    input:
      apiVersion: extra-resources.fn.crossplane.io/v1beta1
      kind: Input
      metadata:
        creationTimestamp: null
      spec:
        extraResources:
        - apiVersion: v1
          into: githubAppCredentials
          kind: Secret
          selector:
            matchLabels:
            - key: github-app-secret
              type: FromCompositeFieldPath
              valueFromFieldPath: spec.githubAppSecretLabelValue
            maxMatch: 1
            minMatch: 1
          type: Selector
    step: pull-github-secret
  - functionRef:
      name: function-github-app-get-token
    input:
      apiVersion: github-app-get-token.fn.crossplane.giantswarm.io/v1beta1
      kind: Input
      metadata:
        creationTimestamp: null
      secretKey: githubAppCredentials
    step: get-github-token
  - functionRef:
      name: function-shell-idp
    input:
      apiVersion: template.fn.crossplane.io/v1alpha1
      kind: Parameters
      metadata:
        creationTimestamp: null
      shellCommand: "#!/bin/bash\nset -e\n\n# Added function for logging with timestamps\nlog()
        {\n\techo \"$(date '+%Y-%m-%d %H:%M:%S') - $*\"\n}\n\nlog \"Starting script\"\n#
        Check that all required environment variables are set\nfor var in GITHUB_TOKEN
        REPO_OWNER REPO_NAME REGISTRY_DOMAIN BACKSTAGE_ENTITY_OWNER BACKSTAGE_ENTITY_LIFECYCLE
        REPO_DESCRIPTION REPO_VISIBILITY REPO_TEMPLATE_SOURCE; do\n\tif [ -z \"${!var:-}\"
        ]; then\n\t\techo \"Error: $var is not set.\"\n\t\texit 1\n\tfi\ndone\n\nlog
        \"Starting clone and render pipeline\"\n\n# Create and clone repository using
        gh CLI\nlog \"Checking if repository ${REPO_OWNER}/${REPO_NAME} exists\"\nREPO_INFO=$(gh
        repo view \"${REPO_OWNER}/${REPO_NAME}\" --json owner,name,visibility 2>/dev/null
        || echo \"{}\")\nif jq -e . >/dev/null 2>&1 <<<\"$REPO_INFO\" && [ \"$(jq
        -r '.name' <<<\"$REPO_INFO\")\" != \"null\" ]; then\n\tlog \"Repository ${REPO_OWNER}/${REPO_NAME}
        already exists, checking configuration\"\n\n\tREPO_OWNER_ACTUAL=$(echo \"$REPO_INFO\"
        | jq -r '.owner.login')\n\tREPO_NAME_ACTUAL=$(echo \"$REPO_INFO\" | jq -r
        '.name')\n\tREPO_VISIBILITY_ACTUAL=$(echo \"$REPO_INFO\" | jq -r '.visibility')\n\n\tif
        [ \"$REPO_OWNER_ACTUAL\" != \"$REPO_OWNER\" ]; then\n\t\tlog \"Error: Repository
        owner does not match. Expected: ${REPO_OWNER}, Actual: ${REPO_OWNER_ACTUAL}\"\n\t\texit
        1\n\tfi\n\n\tif [ \"$REPO_NAME_ACTUAL\" != \"$REPO_NAME\" ]; then\n\t\tlog
        \"Error: Repository name does not match. Expected: ${REPO_NAME}, Actual: ${REPO_NAME_ACTUAL}\"\n\t\texit
        1\n\tfi\n\n\tREPO_VISIBILITY_EXPECTED=$(echo \"$REPO_VISIBILITY\" | tr '[:lower:]'
        '[:upper:]')\n\tif [ \"$REPO_VISIBILITY_ACTUAL\" != \"$REPO_VISIBILITY_EXPECTED\"
        ]; then\n\t\tlog \"Error: Repository visibility does not match. Expected:
        ${REPO_VISIBILITY}, Actual: ${REPO_VISIBILITY_ACTUAL}\"\n\t\texit 1\n\tfi\n\n\tlog
        \"Repository ${REPO_OWNER}/${REPO_NAME} already exists and configuration matches,
        skipping creation\"\n\tgh repo clone \"${REPO_OWNER}/${REPO_NAME}\"\nelse\n\tlog
        \"Creating repository ${REPO_OWNER}/${REPO_NAME} using gh CLI\"\n\tgh repo
        create \"${REPO_OWNER}/${REPO_NAME}\" -d \"${REPO_DESCRIPTION}\" \"--${REPO_VISIBILITY}\"
        -p \"${REPO_TEMPLATE_SOURCE}\" || true\nfi\n# Change directory: assume local
        folder is the same as repo name\ncd \"${REPO_NAME}\"\n\n# Check if repository
        was initialized\nGIT_LOG_INIT_MESSAGE=\"Initial commit: fill in template values\"\ngit_out=$(git
        log --grep \"^${GIT_LOG_INIT_MESSAGE}\\$\")\nif [[ -n \"$git_out\" ]]; then\n\tlog
        \"Repository was already initialized\"\n\texit 0\nelse\n\tlog \"Repository
        wasn't initialized, proceeding with templating.\"\nfi\n\n# Template processing
        (same as previous logic)\nlog \"Preparing template files.\"\nNEW_PATH=$(mktemp
        -d)\ncp -a \"./project-template/\" \"$NEW_PATH/\"\n\ncat >\"$NEW_PATH/boilerplate-values.yml\"
        <<EOF\nBackstageEntityOwner: ${BACKSTAGE_ENTITY_OWNER}\nBackstageEntityLifecycle:
        ${BACKSTAGE_ENTITY_LIFECYCLE}\nProjectName: ${REPO_NAME}\nRepoOwner: ${REPO_OWNER}\nImageName:
        ${REPO_NAME}\nRegistryDomain: ${REGISTRY_DOMAIN}\nRegistryName: ${REPO_OWNER}\nEOF\n\n#
        Remove all tracked files before rendering\ngit rm -r '*' || true\n\nlog \"Running
        boilerplate command to render template\"\nboilerplate --non-interactive --template-url
        \"$NEW_PATH\"/project-template --output-folder . --var-file \"$NEW_PATH\"/boilerplate-values.yml\n\ngit
        config user.email \"crossplane@bots.github.com\"\ngit config user.name \"Crossplane
        Bot\"\n\n# Stage and commit changes\ngit add -A\nset +e\npre-commit run -a\nset
        -e\ngit add -A\n\ngit config user.email \"giant-idp@bots.github.com\"\ngit
        config user.name \"Giant IDP Bot\"\ngit commit -am \"$GIT_LOG_INIT_MESSAGE\"\n\nlog
        \"Pushing changes to main branch\"\ngit push origin main\ngit tag -m \"Initial
        release\" \"0.1.0\"\ngit push origin \"0.1.0\"\n\ngit push origin main\n\nlog
        \"Pipeline finished successfully\""
      shellEnvVars:
      - key: GITHUB_TOKEN
        valueRef: context[apiextensions.crossplane.io/github-app-get-token].github-token
      - key: REPO_OWNER
        valueRef: spec.repository.owner
      - key: REPO_NAME
        valueRef: spec.repository.name
      - key: REPO_DESCRIPTION
        valueRef: spec.repository.description
      - key: REPO_VISIBILITY
        valueRef: spec.repository.visibility
      - key: REPO_TEMPLATE_SOURCE
        valueRef: spec.repository.templateSource
      - key: BACKSTAGE_ENTITY_OWNER
        valueRef: spec.backstageCatalogEntity.owner
      - key: BACKSTAGE_ENTITY_LIFECYCLE
        valueRef: spec.backstageCatalogEntity.lifecycle
      - key: REGISTRY_DOMAIN
        value: ghcr.io
      shellEnvVarsRef: {}
    step: execute-gh-script
  - functionRef:
      name: function-kcl
    input:
      apiVersion: krm.kcl.dev/v1alpha1
      kind: KCLInput
      metadata:
        creationTimestamp: null
      spec:
        source: |-
          import regex

          oxr = option("params").oxr
          dxr = option("params").dxr
          ocds = option("params").ocds
          dcds = option("params").dcds

          get = lambda obj: {:}, path: str, default: any -> any {
              """
              Get an item from a dictionary using a dot separated path.
              If the item is not found, return a default value.
              """
              p = regex.split(path, "\.")
              c = p[0]
              y = ".".join(p[1::])
              obj[c] if len(p) == 1 and c in obj else default if c not in obj else get(obj[c], path, default)
          }

          _items = []

          configMap = {
              "apiVersion": "v1"
              "kind": "ConfigMap"
              "metadata": {
                  "name": oxr["metadata"]["name"] + "-info"
                  "namespace": oxr["metadata"]["namespace"]
              }
              "data": {
                  "repoName": oxr["spec"]["repository"]["name"]
                  "repoOwner": oxr["spec"]["repository"]["owner"]
                  "repoVisibility": oxr["spec"]["repository"]["visibility"]
                  "repoProvider": "github"
                  "fluxHelmRepositoryName": oxr["metadata"]["name"]
                  "registryInfoConfigMapName": oxr["github-oci-registry-info"]["name"]
              }
          }

          wrappedConfigMap = {
              "apiVersion": "kubernetes.crossplane.io/v1alpha2"
              "kind": "Object"
              "spec": {
                  "deletionPolicy": "Delete",
                  "forProvider": {
                      "manifest": configMap
                  }
                  "managementPolicies": ["*"],
                  "providerConfigRef": get(oxr, "spec.kubernetesProviderConfig", {"name": "default"}),
              }
          }

          _items += [wrappedConfigMap]

          #apiVersion: source.toolkit.fluxcd.io/v1beta2
          #kind: HelmRepository
          #metadata:
          #  name: <objName>
          #  namespace: <objNamespace>
          #spec:
          #  type: "oci"
          #  interval: 5m0s
          #  url: oci://ghcr.io/<repoOwner>/charts
          helmRepo = {
              "apiVersion": "source.toolkit.fluxcd.io/v1beta2"
              "kind": "HelmRepository"
              "metadata": {
                  "name": oxr["metadata"]["name"]
                  "namespace": oxr["metadata"]["namespace"]
              }
              "spec": {
                  "type": "oci"
                  "interval": "5m0s"
                  "url": "oci://ghcr.io/" + oxr["spec"]["repository"]["owner"] + "/charts"
              }
          }

          wrappedHelmRepo = {
              "apiVersion": "kubernetes.crossplane.io/v1alpha2"
              "kind": "Object"
              "spec": {
                  "deletionPolicy": "Delete"
                  "forProvider": {
                      "manifest": helmRepo
                  }
                  "managementPolicies": ["*"]
                  "providerConfigRef": get(oxr, "spec.kubernetesProviderConfig", {"name": "default"})
              }
          }

          _items += [wrappedHelmRepo]

          items = _items
        target: ""
    step: function-provision-configmap
  - functionRef:
      name: function-auto-ready
    step: function-auto-ready
