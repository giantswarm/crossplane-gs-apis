apiVersion: apiextensions.crossplane.io/v1
kind: Composition
metadata:
  creationTimestamp: null
  labels:
    provider: github
    type: repository
  name: github-repo
spec:
  compositeTypeRef:
    apiVersion: xgithubrepo.crossplane.giantswarm.io/v1alpha1
    kind: GithubRepo
  mode: Pipeline
  pipeline:
  - functionRef:
      name: function-extra-resources
    input:
      apiVersion: extra-resources.fn.crossplane.io/v1beta1
      kind: Input
      metadata:
        creationTimestamp: null
      spec:
        extraResources:
        - apiVersion: v1
          into: githubAppCredentials
          kind: Secret
          selector:
            matchLabels:
            - key: github-app-secret
              type: FromCompositeFieldPath
              valueFromFieldPath: spec.githubAppSecretLabelValue
            maxMatch: 1
            minMatch: 1
          type: Selector
    step: pull-github-secret
  - functionRef:
      name: function-github-app-get-token
    input:
      apiVersion: github-app-get-token.fn.crossplane.giantswarm.io/v1beta1
      kind: Input
      metadata:
        creationTimestamp: null
      secretKey: githubAppCredentials
    step: get-github-token
  - functionRef:
      name: function-shell-idp
    input:
      apiVersion: template.fn.crossplane.io/v1alpha1
      kind: Parameters
      metadata:
        creationTimestamp: null
      shellCommand: |-
        #!/bin/bash
        set -euo pipefail

        # Added function for logging with timestamps
        log() {
          echo "$(date '+%Y-%m-%d %H:%M:%S') - $*"
        }

        # Check that all required environment variables are set
        for var in GITHUB_TOKEN REPO_OWNER REPO_NAME REGISTRY_DOMAIN BACKSTAGE_ENTITY_OWNER BACKSTAGE_ENTITY_LIFECYCLE REPO_DESCRIPTION REPO_VISIBILITY REPO_TEMPLATE_SOURCE; do
          if [ -z "${!var:-}" ]; then
            echo "Error: $var is not set."
            exit 1
          fi
        done

        log "Starting clone and render pipeline"

        # Create and clone repository using gh CLI
        log "Checking if repository ${REPO_OWNER}/${REPO_NAME} exists"
        REPO_INFO=$(gh repo view "${REPO_OWNER}/${REPO_NAME}" --json owner,name,visibility 2>/dev/null || echo "{}")
        if jq -e . >/dev/null 2>&1 <<<"$REPO_INFO" && [ "$(jq -r '.name' <<<"$REPO_INFO")" != "null" ]; then
          log "Repository ${REPO_OWNER}/${REPO_NAME} already exists, checking configuration"

          REPO_OWNER_ACTUAL=$(echo "$REPO_INFO" | jq -r '.owner.login')
          REPO_NAME_ACTUAL=$(echo "$REPO_INFO" | jq -r '.name')
          REPO_VISIBILITY_ACTUAL=$(echo "$REPO_INFO" | jq -r '.visibility')

          if [ "$REPO_OWNER_ACTUAL" != "$REPO_OWNER" ]; then
            log "Error: Repository owner does not match. Expected: ${REPO_OWNER}, Actual: ${REPO_OWNER_ACTUAL}"
            exit 1
          fi

          if [ "$REPO_NAME_ACTUAL" != "$REPO_NAME" ]; then
            log "Error: Repository name does not match. Expected: ${REPO_NAME}, Actual: ${REPO_NAME_ACTUAL}"
            exit 1
          fi

          REPO_VISIBILITY_EXPECTED=$(echo "$REPO_VISIBILITY" | tr '[:lower:]' '[:upper:]')
          if [ "$REPO_VISIBILITY_ACTUAL" != "$REPO_VISIBILITY_EXPECTED" ]; then
            log "Error: Repository visibility does not match. Expected: ${REPO_VISIBILITY}, Actual: ${REPO_VISIBILITY_ACTUAL}"
            exit 1
          fi

          log "Repository ${REPO_OWNER}/${REPO_NAME} already exists and configuration matches, skipping creation"
        else
          log "Creating repository ${REPO_OWNER}/${REPO_NAME} using gh CLI"
          gh repo create "${REPO_OWNER}/${REPO_NAME}" -d "${REPO_DESCRIPTION}" "--${REPO_VISIBILITY}" -p "${REPO_TEMPLATE_SOURCE}" || true
        fi
        # Change directory: assume local folder is the same as repo name
        cd "${REPO_NAME}"

        # Check if repository was initialized
        GIT_LOG_INIT_MESSAGE="Initial commit: fill in template values"
        git_out=$(git log --grep "^${GIT_LOG_INIT_MESSAGE}\$")
        if [[ -n "$git_out" ]]; then
          log "Repository was already initialized"
          exit 0
        else
          log "Repository wasn't initialized, proceeding with templating."
        fi

        # Template processing (same as previous logic)
        log "Preparing template files."
        NEW_PATH=$(mktemp -d)
        cp -a "./project-template/" "$NEW_PATH/"

        cat >"$NEW_PATH/boilerplate-values.yml" <<EOF
        BackstageEntityOwner: ${BACKSTAGE_ENTITY_OWNER}
        BackstageEntityLifecycle: ${BACKSTAGE_ENTITY_LIFECYCLE}
        ProjectName: ${REPO_NAME}
        RepoOwner: ${REPO_OWNER}
        ImageName: ${REPO_NAME}
        RegistryDomain: ${REGISTRY_DOMAIN}
        RegistryName: ${REPO_OWNER}
        EOF

        # Remove all tracked files before rendering
        git rm -r '*' || true

        log "Running boilerplate command to render template"
        boilerplate --non-interactive --template-url "$NEW_PATH"/project-template --output-folder . --var-file "$NEW_PATH"/boilerplate-values.yml

        git config user.email "crossplane@bots.github.com"
        git config user.name "Crossplane Bot"

        # Stage and commit changes
        git add -A
        set +e
        pre-commit run -a
        set -e
        git add -A

        git config user.email "giant-idp@bots.github.com"
        git config user.name "Giant IDP Bot"
        git commit -am "$GIT_LOG_INIT_MESSAGE"

        log "Pushing changes to main branch"
        git push origin main
        git tag -m "Initial release" "0.1.0"
        git push origin "0.1.0"

        git push origin main

        log "Pipeline finished successfully"
      shellEnvVars:
      - key: GITHUB_TOKEN
        valueRef: context[apiextensions.crossplane.io/github-app-get-token].github-token
      - key: REPO_OWNER
        valueRef: spec.repository.owner
      - key: REPO_NAME
        valueRef: spec.repository.name
      - key: REPO_DESCRIPTION
        valueRef: spec.repository.description
      - key: REPO_VISIBILITY
        valueRef: spec.repository.visibility
      - key: REPO_TEMPLATE_SOURCE
        valueRef: spec.repository.templateSource
      - key: REGISTRY_DOMAIN
        valueRef: ghcr.io
      - key: BACKSTAGE_ENTITY_OWNER
        valueRef: spec.backstageCatalogEntity.owner
      - key: BACKSTAGE_ENTITY_LIFECYCLE
        valueRef: spec.backstageCatalogEntity.lifecycle
      shellEnvVarsRef: {}
    step: execute-gh-script
  - functionRef:
      name: function-kcl
    input:
      apiVersion: krm.kcl.dev/v1alpha1
      kind: KCLInput
      metadata:
        creationTimestamp: null
      spec:
        source: |-
          import regex

          oxr = option("params").oxr
          dxr = option("params").dxr
          ocds = option("params").ocds
          dcds = option("params").dcds

          get = lambda obj: {:}, path: str, default: any -> any {
              """
              Get an item from a dictionary using a dot separated path.
              If the item is not found, return a default value.
              """
              p = regex.split(path, "\.")
              c = p[0]
              y = ".".join(p[1::])
              obj[c] if len(p) == 1 and c in obj else default if c not in obj else get(obj[c], path, default)
          }

          _items = []

          configMap = {
              "apiVersion": "v1"
              "kind": "ConfigMap"
              "metadata": {
                  "name": oxr["metadata"]["name"] + "-info"
                  "namespace": oxr["metadata"]["namespace"]
              }
              "data": {
                  "repoName": oxr["spec"]["repository"]["name"]
                  "repoOwner": oxr["spec"]["repository"]["owner"]
                  "repoVisibility": oxr["spec"]["repository"]["visibility"]
                  "repoProvider": "github"
                  "fluxHelmRepositoryName": oxr["metadata"]["name"]
                  "registryInfoConfigMapName": oxr["github-oci-registry-info"]["name"]
              }
          }

          wrappedConfigMap = {
              "apiVersion": "kubernetes.crossplane.io/v1alpha2"
              "kind": "Object"
              "spec": {
                  "deletionPolicy": "Delete",
                  "forProvider": {
                      "manifest": configMap
                  }
                  "managementPolicies": ["*"],
                  "providerConfigRef": get(oxr, "spec.kubernetesProviderConfig", {"name": "default"}),
              }
          }

          _items += [wrappedConfigMap]

          #apiVersion: source.toolkit.fluxcd.io/v1beta2
          #kind: HelmRepository
          #metadata:
          #  name: <objName>
          #  namespace: <objNamespace>
          #spec:
          #  type: "oci"
          #  interval: 5m0s
          #  url: oci://ghcr.io/<repoOwner>/charts
          helmRepo = {
              "apiVersion": "source.toolkit.fluxcd.io/v1beta2"
              "kind": "HelmRepository"
              "metadata": {
                  "name": oxr["metadata"]["name"]
                  "namespace": oxr["metadata"]["namespace"]
              }
              "spec": {
                  "type": "oci"
                  "interval": "5m0s"
                  "url": "oci://ghcr.io/" + oxr["spec"]["repository"]["owner"] + "/charts"
              }
          }

          wrappedHelmRepo = {
              "apiVersion": "kubernetes.crossplane.io/v1alpha2"
              "kind": "Object"
              "spec": {
                  "deletionPolicy": "Delete"
                  "forProvider": {
                      "manifest": helmRepo
                  }
                  "managementPolicies": ["*"]
                  "providerConfigRef": get(oxr, "spec.kubernetesProviderConfig", {"name": "default"})
              }
          }

          _items += [wrappedHelmRepo]

          items = _items
        target: ""
    step: function-provision-configmap
  - functionRef:
      name: function-auto-ready
    step: function-auto-ready
