apiVersion: apiextensions.crossplane.io/v1
kind: Composition
metadata:
  creationTimestamp: null
  labels:
    component: elasticache
    provider: aws
    type: base
  name: cache-base
spec:
  compositeTypeRef:
    apiVersion: xcache.crossplane.giantswarm.io/v1alpha1
    kind: CacheBase
  mode: Pipeline
  pipeline:
  - functionRef:
      name: function-patch-and-transform
    input:
      apiVersion: pt.crossplane.io/v1beta1
      kind: Resources
      metadata:
        creationTimestamp: null
      patchSets:
      - name: metadata
        patches:
        - fromFieldPath: metadata.labels
          policy:
            toFieldPath: MergeObjects
          toFieldPath: metadata.labels
          type: FromCompositeFieldPath
        - fromFieldPath: spec.region
          toFieldPath: metadata.labels.region
          type: FromCompositeFieldPath
        - fromFieldPath: spec.providerConfigRef
          toFieldPath: spec.providerConfigRef
          type: FromCompositeFieldPath
        - fromFieldPath: spec.deletionPolicy
          toFieldPath: spec.deletionPolicy
          type: FromCompositeFieldPath
      - name: commontags
        patches:
        - fromFieldPath: spec.tags
          policy:
            toFieldPath: MergeObjects
          toFieldPath: spec.forProvider.tags
          type: FromCompositeFieldPath
        - fromFieldPath: metadata.labels
          policy:
            toFieldPath: MergeObjects
          toFieldPath: spec.forProvider.tags
          type: FromCompositeFieldPath
        - fromFieldPath: spec.region
          toFieldPath: spec.forProvider.tags.region
          type: FromCompositeFieldPath
      resources:
      - base:
          apiVersion: kms.aws.upbound.io/v1beta1
          kind: Key
          metadata:
            creationTimestamp: null
          spec:
            forProvider:
              region: null
            initProvider: {}
          status:
            atProvider: {}
        name: kms
        patches:
        - fromFieldPath: spec.region
          toFieldPath: spec.forProvider.region
          type: FromCompositeFieldPath
        - fromFieldPath: status.atProvider.arn
          toFieldPath: status.kmsKeyId
          type: ToCompositeFieldPath
        - fromFieldPath: spec.managementPolicies
          toFieldPath: spec.managementPolicies
          type: FromCompositeFieldPath
        - combine:
            strategy: string
            string:
              fmt: '%s-%s'
            variables:
            - fromFieldPath: spec.claimRef.name
            - fromFieldPath: spec.region
          toFieldPath: spec.forProvider.tags.Name
          type: CombineFromComposite
        - patchSetName: commontags
          type: PatchSet
        - patchSetName: metadata
          type: PatchSet
      - base:
          apiVersion: elasticache.aws.upbound.io/v1beta1
          kind: SubnetGroup
          metadata:
            creationTimestamp: null
          spec:
            forProvider:
              region: null
            initProvider: {}
          status:
            atProvider: {}
        name: subnetgroup
        patches:
        - fromFieldPath: spec.region
          toFieldPath: spec.forProvider.region
          type: FromCompositeFieldPath
        - fromFieldPath: spec.subnetIds
          policy:
            fromFieldPath: Required
          toFieldPath: spec.forProvider.subnetIds
          type: FromCompositeFieldPath
        - patchSetName: commontags
          type: PatchSet
        - fromFieldPath: spec.managementPolicies
          toFieldPath: spec.managementPolicies
          type: FromCompositeFieldPath
        - patchSetName: metadata
          type: PatchSet
        - fromFieldPath: spec.claimRef.name
          policy:
            toFieldPath: MergeObjects
          toFieldPath: spec.forProvider.tags.Name
          type: FromCompositeFieldPath
        - fromFieldPath: status.atProvider.id
          toFieldPath: status.subnetGroupName
          type: ToCompositeFieldPath
        - combine:
            strategy: string
            string:
              fmt: '%s %s elasticache subnet group'
            variables:
            - fromFieldPath: spec.claimRef.name
            - fromFieldPath: spec.region
          toFieldPath: spec.forProvider.description
          type: CombineFromComposite
      - base:
          apiVersion: ec2.aws.upbound.io/v1beta1
          kind: SecurityGroup
          metadata:
            creationTimestamp: null
          spec:
            forProvider:
              region: null
              revokeRulesOnDelete: true
            initProvider: {}
          status:
            atProvider: {}
        name: securitygroup
        patches:
        - fromFieldPath: spec.vpcId
          toFieldPath: spec.forProvider.vpcId
          type: FromCompositeFieldPath
        - fromFieldPath: spec.region
          toFieldPath: spec.forProvider.region
          type: FromCompositeFieldPath
        - patchSetName: commontags
          type: PatchSet
        - fromFieldPath: spec.managementPolicies
          toFieldPath: spec.managementPolicies
          type: FromCompositeFieldPath
        - patchSetName: metadata
          type: PatchSet
        - fromFieldPath: spec.claimRef.name
          policy:
            toFieldPath: MergeObjects
          toFieldPath: spec.forProvider.tags.Name
          type: FromCompositeFieldPath
        - combine:
            strategy: string
            string:
              fmt: '%s %s elasticache security group'
            variables:
            - fromFieldPath: spec.claimRef.name
            - fromFieldPath: spec.region
          toFieldPath: spec.forProvider.description
          type: CombineFromComposite
        - fromFieldPath: status.atProvider.id
          toFieldPath: status.securityGroupId
          type: ToCompositeFieldPath
    step: patch-and-transform
  - functionRef:
      name: function-kcl
    input:
      apiVersion: krm.kcl.dev/v1alpha1
      kind: KCLInput
      metadata:
        creationTimestamp: null
      spec:
        source: |-
          import regex

          oxr = option("params").oxr
          dxr = option("params").dxr
          ocds = option("params").ocds
          dcds = option("params").dcds

          exists = lambda x: any -> bool {
              """
              Check if a value exists.
              """
              x in list(ocds)
          }

          get = lambda x: {:}, y: str, d: any -> any {
              """
              Get an item from a dictionary using a dot separated path.
              If the item is not found, return a default value.

              x: The dictionary to search in.
              y: The path to search for.
              d: The default value to return if the path is not found.
              """
              p = regex.split(y, "\.")
              c = p[0]
              y = ".".join(p[1:])
              x[c] if len(p) == 1 and c in x else d if c not in x else get(x[c], y, d)
          }

          getwparent = lambda x: {:}, p: {:}, y: str, d: any -> any {
              """
              Get with fallback to parent
              Tries to get a path from a dictionary, if it fails,
              tries to get it from the parent dictionary.

              If that fails, falls back to the default value provided.
              """
              get(x, y, get(p, "spec.${y}", d))
          }

          ocdsspec = lambda x: str, y: str, d: any -> any {
              """
              Get an item from the spec of an ocds resource.
              """
              get(ocds, "${x}.Resource.spec.${y}", d)
          }

          ocdsstatus = lambda x: str, y: str, d: any -> any {
              """
              Get an item from the status of an ocds resource.
              """
              _x = None
              if get(ocds, "${x}.Resource.status.atProvider", False):
                  _x = get(ocds, "${x}.Resource.status.atProvider.${y}", d)
              else:
                  _x = get(ocds, "${x}.Resource.status.${y}", d)
              _x if _x else d
          }

          ready = lambda x: str -> bool {
              """
              Check if a value is ready.
              """
              conditionsReady = all_true([
                  get(c, "status", "False") == "True" for c in ocdsstatus(x, "conditions", [])
              ])

              ap = get(ocds, "${x}.Resource.status.atProvider", {})
              objectReady = any_true([
                  ocdsstatus(x, "ready", False),
                  len(list(ap)) > 0,
              ])

              all_true([
                  any_true([exists(x), conditionsReady]),
                  objectReady,
              ])
          }

          readystr = lambda x: str -> str {
              """
              Check if a value is ready.
              """
              "True" if ready(x) else "False"
          }

          allReady = lambda -> bool {
              """
              Check if all managed resources are ready.
              """
              all_true([
                  ready(x)
                  for x in list(ocds)
              ])
          }

          appName = get(oxr, "spec.claimRef.name", "")
          createReplicationGroup = get(oxr, "spec.createReplicationGroup", True)
          dp = get(oxr, "spec.deletionPolicy", "Delete")
          keyId = get(oxr, "status.kmsKeyId", False)
          namespace = get(oxr, "spec.claimRef.namespace", "default")
          region = get(oxr, "spec.region", "eu-central-1")
          pcr = get(oxr, "spec.providerConfigRef", {"name": "default"})
          azs = [
              "${region}${az}"
              for az in get(oxr, "spec.availabilityZones", [])
          ]
          labels = get(oxr, "metadata.labels", {}) | {"region": region}

          tags = labels | get(oxr, "spec.tags", {})

          globalEnabled = all_true([
              False,
              createReplicationGroup,
              get(oxr, "spec.globalReplicationGroup.enabled", False)
          ])

          userNames = get(oxr, "spec.userNames", []) + [appName, "default"]
          mgmtPolicy = get(oxr, "spec.managementPolicies", [])
          publishConnection = get(oxr, "spec.publishConnectionDetailsTo", {})


          globalEndpoint = ocdsstatus("elasticache-replication-group-global", "primaryEndpointAddress", "") if globalEnabled else ""
          globalROEndpoint = ocdsstatus("elasticache-replication-group-global", "readerEndpointAddress", "") if globalEnabled else ""

          cc = get(oxr, "spec.cacheClusters", [])
          rclen = len(cc) if cc else get(oxr, "spec.numCacheClusters", 1)
          clusterEndpoints = [
              e for e in [
                  ocdsstatus("elasticache-cluster-${i}", "clusterAddress", "")
                  for i in range(rclen)
              ]
              if e
          ]

          endpoint = ocdsstatus("elasticache-replication-group-local", "primaryEndpointAddress", "") if createReplicationGroup else clusterEndpoints[0] if clusterEndpoints else ""
          readerep = ocdsstatus("elasticache-replication-group-local", "readerEndpointAddress", "") if createReplicationGroup else endpoint

          _port = 0
          if globalEnabled:
              _port = ocdsstatus("elasticache-replication-group-global", "port", False)
          elif createReplicationGroup:
              _port = ocdsstatus("elasticache-replication-group-local", "port", False)
          else:
              _port = ocdsstatus("elasticache-cluster-0", "port", False)

          # If we are not creating a replication group, check how many cache clusters have
          # been requested and default a list of empty dictionaries as being the cache
          # cluster template.
          requiredClusters = get(oxr, "spec.cacheClusters", []) if get(oxr, "spec.cacheClusters", False) else [
              {}
              for i in range(get(oxr, "spec.numCacheClusters", 1))
              if not get(oxr, "spec.createReplicationGroup", False)
          ]

          if get(oxr, "spec.createReplicationGroup", False):
              assert get(oxr, "spec.engine", "redis") == "redis", "engine must be redis when createReplicationGroup is true"

          clusterModeEnabled = get(oxr, "spec.clusterMode.enabled", False)
          ipgn = get(oxr, "status.parameterGroupName", "") if get(oxr, "spec.allowMajorVersionUpgrade", False) else ""

          securityGroupIds = [
              get(oxr, "status.securityGroupId", None),
          ] + [
              i for r in get(oxr, "spec.securityGroupIds", []) for i in r
          ]

          subnetGroup = get(oxr, "status.subnetGroupName", False)

          # Currently Crossplane does not support the GlobalReplicationGroup resource
          #
          # Until this CRD is implemented, we will be defining, but force disabling the
          # following block - this saves having to extend the composition to support this
          # in the future but would just require re-enabling the block by removing `False`
          # from the `all_true` check.
          # https://github.com/crossplane-contrib/provider-upjet-aws/issues/1333

          # In order to create a global replication group, we must be creating a
          # local replication group as well. Global is secondary.
          primaryGlobalRID = get(oxr, "spec.globalReplicationGroupId", "") if globalEnabled else ""
          replicationGlobalRID = get(oxr, "status.globalReplicationGroupId", "") if globalEnabled else get(oxr, "spec.globalReplicationGroupId", "")

          parameterGroup = [
              {
                  "apiVersion": "elasticache.aws.upbound.io/v1beta1"
                  "kind": "ParameterGroup"
                  "metadata": {
                      "annotations": {
                          "krm.kcl.dev/composition-resource-name": "elasticache-parameter-group"
                          "krm.kcl.dev/ready": readystr("elasticache-parameter-group")
                          "crossplane.io/external-name": appName
                      }
                      "labels": labels
                  }
                  "spec": {
                      "deletionPolicy": dp
                      "forProvider": {
                          "description": appName + " Parameter Group"
                          "family": get(oxr, "spec.parameterGroupFamily", "redis6.x")
                          "name": appName + "-parameter-group"
                          if get(oxr, "spec.parameters", False):
                              "parameter" = [
                                  {
                                      name: k,
                                      value: v,
                                  }
                                  for k, v in get(oxr, "spec.parameterGroupConfiguration.parameters", {})
                              ]
                          "region" = region
                          "tags" = tags | {
                              "Name": "${appName}-${region}"
                          } | get(oxr, "spec.parameterGroupConfiguration.tags", {})
                      }
                      "managementPolicies": mgmtPolicy,
                      "providerConfigRef": pcr
                  }
              }
          ] if get(oxr, "spec.parameterGroupConfiguration", False) else []

          globalReplicationGroup = [{
              "apiVersion": "elasticache.aws.upbound.io/v1beta1"
              "kind": "GlobalReplicationGroup"
              "metadata": {
                  "annotations": {
                      "krm.kcl.dev/composition-resource-name": "global-elasticache-replication-group"
                      "krm.kcl.dev/ready": readystr("global-elasticache-replication-group")
                      "crossplane.io/external-name": appName
                  }
                  "labels": labels
              }
              "spec": {
                  "deletionPolicy": dp
                  "forProvider": {
                      "automaticFailoverEnabled": get(oxr, "spec.globalReplicationGroup.automaticFailoverEnabled", False)
                      "cacheNodeType": get(oxr, "spec.globalReplicationGroup.cacheNodeType", "cache.t3.micro")
                      "globalReplicationGroupIdSuffix": get(oxr, "spec.globalReplicationGroup.suffix", "")
                      "globalReplicationGroupDescription": appName + " Global Replication Group"
                      if get(oxr, "spec.globalReplicationGroup.numNodeGroups", False):
                          "numNodeGroups": get(oxr, "spec.globalReplicationGroup.numNodeGroups", 1)

                      if primaryGlobalRID:
                          "primaryReplicationGroupId": primaryGlobalRID

                      "region": region

                      "tags": tags | {
                          "Name": "${appName}-${region}-global"
                      }
                  }
                  "managementPolicies": mgmtPolicy,
                  "providerConfigRef": pcr
              }
          }] if globalEnabled else []

          enabledReplicationGroups = [
              "global" if globalEnabled else "",
              # We don't want to create the local replication group if global replication
              # is enabled until the GlobalReplicationGroup is ready.
              "local" if any_true([
                  all_true([
                      globalEnabled,
                      ready("global-elasticache-replication-group"),
                  ]),
                  not globalEnabled,
              ]) else "",
          ]

          replicationGroups = [
              {
                  "apiVersion": "elasticache.aws.upbound.io/v1beta2"
                  "kind": "ReplicationGroup"
                  "metadata": {
                      "annotations": {
                          "krm.kcl.dev/composition-resource-name": "elasticache-replication-group-${i}"
                          "krm.kcl.dev/ready": readystr("elasticache-replication-group-${i}")
                          "crossplane.io/external-name": "${appName}-${i}"
                      }
                      "labels": labels
                  }
                  "spec": {
                      "deletionPolicy": dp
                      "initProvider": {
                          if get(oxr, "spec.autoMinorVersionUpgrade", False):
                              if get(oxr, "spec.engineVersion", False):
                                  "engineVersion": get(oxr, "spec.engineVersion", "")
                      }
                      "forProvider": {
                          if get(oxr, "spec.applyImmediately", None) != None:
                              "applyImmediately": get(oxr, "spec.applyImmediately", True)

                          "atRestEncryptionEnabled" = get(oxr, "spec.atRestEncryptionEnabled", True)

                          if get(oxr, "spec.transitEncryptionEnabled", False):
                              "autoGenerateAuthToken": True
                              "authTokenSecretRef": {
                                  "key": "token"
                                  "name": "${appName}-elasticache-auth-token"
                                  "namespace": get(oxr, "spec.claimRef.namespace", "default")
                              }
                              "transitEncryptionEnabled": get(oxr, "spec.transitEncryptionEnabled", True)

                          if get(oxr, "spec.authTokenUpdateStrategy", False):
                              "authTokenUpdateStrategy": get(oxr, "spec.authTokenUpdateStrategy", "ROTATE")
                          if get(oxr, "spec.autoMinorVersionUpgrade", None) != None:
                              "autoMinorVersionUpgrade": get(oxr, "spec.autoMinorVersionUpgrade", True)
                          if get(oxr, "spec.automaticFailoverEnabled", None) != None:
                              "automaticFailoverEnabled": get(oxr, "spec.automaticFailoverEnabled", False)
                          if get(oxr, "spec.dataTieringEnabled", False):
                              "dataTieringEnabled": get(oxr, "spec.dataTieringEnabled", False)

                          if i == "global":
                              "description": appName + " Replication Group ${region} (Global)"

                          if i == "local":
                              "description": appName + " Replication Group ${region} (Local)"

                          if get(oxr, "spec.engine", False):
                              "engine": get(oxr, "spec.engine", "redis")

                          if not get(oxr, "spec.autoMinorVersionUpgrade", False):
                              if get(oxr, "spec.engineVersion", False):
                                  "engineVersion": get(oxr, "spec.engineVersion", "7.x")

                          if get(oxr, "spec.finalSnapshotIdentifier", False):
                              "finalSnapshotIdentifier": get(oxr, "spec.finalSnapshotIdentifier", "")

                          if replicationGlobalRID:
                              "globalReplicationGroupId": replicationGlobalRID

                          if get(oxr, "spec.ipDiscovery", False):
                              "ipDiscovery": get(oxr, "spec.ipDiscovery", "ipv4")

                          "kmsKeyId": keyId

                          if get(oxr, "spec.maintenanceWindow", False):
                              "maintenanceWindow": get(oxr, "spec.maintenanceWindow", "")
                          if get(oxr, "spec.multiAzEnabled", None) != None:
                              "multiAzEnabled": get(oxr, "spec.multiAzEnabled", True)
                          if get(oxr, "spec.networkType", False):
                              "networkType": get(oxr, "spec.networkType", "ipv4")

                          if get(oxr, "spec.notificationTopicArn", False):
                              "notificationTopicArn": get(oxr, "spec.notificationTopicArn", "")

                          if all_true([
                              get(oxr, "spec.numCacheClusters", False),
                              not get(oxr, "spec.numNodeGroups", False),
                              not clusterModeEnabled
                          ]):
                              "numCacheClusters": get(oxr, "spec.numCacheClusters", 1)

                          # numNodeGroups cannot be set if global replication group id is set
                          if any_true([
                              get(oxr, "spec.globalReplicationGroupId", False),
                              i == "global"
                              all_true([
                                  not get(oxr, "spec.globalReplicationGroup.enabled", False),
                                  not get(oxr, "spec.globalReplicationGroupId", False),
                                  i == "local"
                              ])
                          ]):
                              if get(oxr, "spec.nodeType", False):
                                  "nodeType": get(oxr, "spec.nodeType", "cache.t3.micro")
                              if all_true([
                                  clusterModeEnabled,
                                  get(oxr, "spec.numNodeGroups", False)
                              ]):
                                  "numNodeGroups": get(oxr, "spec.numNodeGroups", 1)
                          if ipgn:
                              "parameterGroupName": ipgn

                          if get(oxr, "spec.port", False):
                              "port": get(oxr, "spec.port", 6379)

                          if azs:
                              "preferredCacheClusterAzs": azs

                          if get(oxr, "spec.replicasPerNodeGroup", None) != None:
                              "replicasPerNodeGroup": get(oxr, "spec.replicasPerNodeGroup", 0)

                          "region": region

                          if securityGroupIds:
                              "securityGroupIds": [i for i in securityGroupIds if i]

                          if any_true([
                              all_true([
                                  i == "global",
                                  get(oxr, "status.subnetGroupName", False),
                              ]),
                              all_true([
                                  not get(oxr, "spec.globalReplicationGroup.enabled", False),
                                  i == "local",
                                  get(oxr, "status.subnetGroupName", False),
                              ])
                          ]):
                              "subnetGroupName": subnetGroup

                          if get(oxr, "spec.snapshotRetentionLimit", False):
                              "snapshotRetentionLimit": get(oxr, "spec.snapshotRetentionLimit", 1)
                          if get(oxr, "spec.snapshotWindow", False):
                              "snapshotWindow": get(oxr, "spec.snapshotWindow", "00:00-01:00")
                          if get(oxr, "spec.userGroupIds", False):
                              "userGroupIds": [
                                  get(oxr, "status.userGroupId", "")
                              ]

                          "tags": tags | {
                              "Name": "${appName}-${region}-${i}"
                          }
                      }
                      "managementPolicies": mgmtPolicy,
                      "providerConfigRef": pcr

                      "writeConnectionSecretToRef": {
                          "name": "${appName}-elasticache-${i}"
                          "namespace": get(oxr, "spec.claimRef.namespace", "default")
                      }
                  }
              } for _, i in enabledReplicationGroups if all_true([
                  createReplicationGroup, keyId, i,
                  get(oxr, "spec.engine", "redis") == "redis",
                  any_true([
                      i == "global",
                      all_true([i == "local", not globalEnabled]),
                      all_true([i == "local", globalEnabled, replicationGlobalRID]),
                  ]),
                  get(oxr, "status.subnetGroupName", False)
                  get(oxr, "status.securityGroupId", False)
              ])
          ]

          _items = [
              i for r in [
                  replicationGroups, globalReplicationGroup,
                  parameterGroup
              ] for i in r if i
          ]

          items = _items
        target: ""
    step: function-kcl-create-replicationgroup
  - functionRef:
      name: function-kcl
    input:
      apiVersion: krm.kcl.dev/v1alpha1
      kind: KCLInput
      metadata:
        creationTimestamp: null
      spec:
        source: |-
          import regex

          oxr = option("params").oxr
          dxr = option("params").dxr
          ocds = option("params").ocds
          dcds = option("params").dcds

          exists = lambda x: any -> bool {
              """
              Check if a value exists.
              """
              x in list(ocds)
          }

          get = lambda x: {:}, y: str, d: any -> any {
              """
              Get an item from a dictionary using a dot separated path.
              If the item is not found, return a default value.

              x: The dictionary to search in.
              y: The path to search for.
              d: The default value to return if the path is not found.
              """
              p = regex.split(y, "\.")
              c = p[0]
              y = ".".join(p[1:])
              x[c] if len(p) == 1 and c in x else d if c not in x else get(x[c], y, d)
          }

          getwparent = lambda x: {:}, p: {:}, y: str, d: any -> any {
              """
              Get with fallback to parent
              Tries to get a path from a dictionary, if it fails,
              tries to get it from the parent dictionary.

              If that fails, falls back to the default value provided.
              """
              get(x, y, get(p, "spec.${y}", d))
          }

          ocdsspec = lambda x: str, y: str, d: any -> any {
              """
              Get an item from the spec of an ocds resource.
              """
              get(ocds, "${x}.Resource.spec.${y}", d)
          }

          ocdsstatus = lambda x: str, y: str, d: any -> any {
              """
              Get an item from the status of an ocds resource.
              """
              _x = None
              if get(ocds, "${x}.Resource.status.atProvider", False):
                  _x = get(ocds, "${x}.Resource.status.atProvider.${y}", d)
              else:
                  _x = get(ocds, "${x}.Resource.status.${y}", d)
              _x if _x else d
          }

          ready = lambda x: str -> bool {
              """
              Check if a value is ready.
              """
              conditionsReady = all_true([
                  get(c, "status", "False") == "True" for c in ocdsstatus(x, "conditions", [])
              ])

              ap = get(ocds, "${x}.Resource.status.atProvider", {})
              objectReady = any_true([
                  ocdsstatus(x, "ready", False),
                  len(list(ap)) > 0,
              ])

              all_true([
                  any_true([exists(x), conditionsReady]),
                  objectReady,
              ])
          }

          readystr = lambda x: str -> str {
              """
              Check if a value is ready.
              """
              "True" if ready(x) else "False"
          }

          allReady = lambda -> bool {
              """
              Check if all managed resources are ready.
              """
              all_true([
                  ready(x)
                  for x in list(ocds)
              ])
          }

          appName = get(oxr, "spec.claimRef.name", "")
          createReplicationGroup = get(oxr, "spec.createReplicationGroup", True)
          dp = get(oxr, "spec.deletionPolicy", "Delete")
          keyId = get(oxr, "status.kmsKeyId", False)
          namespace = get(oxr, "spec.claimRef.namespace", "default")
          region = get(oxr, "spec.region", "eu-central-1")
          pcr = get(oxr, "spec.providerConfigRef", {"name": "default"})
          azs = [
              "${region}${az}"
              for az in get(oxr, "spec.availabilityZones", [])
          ]
          labels = get(oxr, "metadata.labels", {}) | {"region": region}

          tags = labels | get(oxr, "spec.tags", {})

          globalEnabled = all_true([
              False,
              createReplicationGroup,
              get(oxr, "spec.globalReplicationGroup.enabled", False)
          ])

          userNames = get(oxr, "spec.userNames", []) + [appName, "default"]
          mgmtPolicy = get(oxr, "spec.managementPolicies", [])
          publishConnection = get(oxr, "spec.publishConnectionDetailsTo", {})


          globalEndpoint = ocdsstatus("elasticache-replication-group-global", "primaryEndpointAddress", "") if globalEnabled else ""
          globalROEndpoint = ocdsstatus("elasticache-replication-group-global", "readerEndpointAddress", "") if globalEnabled else ""

          cc = get(oxr, "spec.cacheClusters", [])
          rclen = len(cc) if cc else get(oxr, "spec.numCacheClusters", 1)
          clusterEndpoints = [
              e for e in [
                  ocdsstatus("elasticache-cluster-${i}", "clusterAddress", "")
                  for i in range(rclen)
              ]
              if e
          ]

          endpoint = ocdsstatus("elasticache-replication-group-local", "primaryEndpointAddress", "") if createReplicationGroup else clusterEndpoints[0] if clusterEndpoints else ""
          readerep = ocdsstatus("elasticache-replication-group-local", "readerEndpointAddress", "") if createReplicationGroup else endpoint

          _port = 0
          if globalEnabled:
              _port = ocdsstatus("elasticache-replication-group-global", "port", False)
          elif createReplicationGroup:
              _port = ocdsstatus("elasticache-replication-group-local", "port", False)
          else:
              _port = ocdsstatus("elasticache-cluster-0", "port", False)

          # If we are not creating a replication group, check how many cache clusters have
          # been requested and default a list of empty dictionaries as being the cache
          # cluster template.
          requiredClusters = get(oxr, "spec.cacheClusters", []) if get(oxr, "spec.cacheClusters", False) else [
              {}
              for i in range(get(oxr, "spec.numCacheClusters", 1))
              if not get(oxr, "spec.createReplicationGroup", False)
          ]

          clusters = [
              {
                  "apiVersion": "elasticache.aws.upbound.io/v1beta1"
                  "kind": "Cluster"
                  "metadata": {
                      "annotations": {
                          "krm.kcl.dev/composition-resource-name": "elasticache-cluster-${i}"
                          "krm.kcl.dev/ready": readystr("elasticache-cluster-${i}")
                          "crossplane.io/external-name": "${appName}-${region}-${i}"
                      }
                      "labels": labels
                  }
                  "spec": {
                      "deletionPolicy": get(oxr, "spec.deletionPolicy", "Delete"),
                      "initProvider": {
                          if get(oxr, "spec.autoMinorVersionUpgrade", False):
                              if get(oxr, "spec.engineVersion", False):
                                  "engineVersion": get(oxr, "spec.engineVersion", "7.x")
                      }

                      "forProvider": {
                          _v = getwparent(cluster, oxr, "applyImmediately",False)
                          if _v:
                              "applyImmediately": _v

                          _v = getwparent(cluster, oxr, "autoMinorVersionUpgrade", False)
                          if _v:
                              "autoMinorVersionUpgrade": _v

                          _az = get(cluster, "availabilityZone", azs[i % len(azs)])
                          if get(cluster, "availabilityZone", False):
                              "availabilityZone": _az

                          if all_true([
                              getwparent(cluster, oxr, "azMode", False),
                              getwparent(cluster, oxr "engine", False) == "memcached",
                          ]):
                              "azMode": getwparent(cluster, oxr, "azMode", "cross-az"),
                              "numCacheNodes" = getwparent(cluster, oxr, "numCacheNodes", len(azs)),

                          _v = getwparent(cluster, oxr, "engine", False)
                          if _v:
                              "engine" = _v

                          if not get(oxr, "spec.autoMinorVersionUpgrade", False):
                              _v = getwparent(cluster, oxr, "engineVersion", False)
                              if _v:
                                  "engineVersion" = _v

                          _v = getwparent(cluster, oxr, "finalSnapshotIdentifier", False)
                          if _v:
                              "finalSnapshotIdentifier" = _v

                          _v = getwparent(cluster, oxr, "ipDiscovery", False)
                          if _v:
                              "ipDiscovery" = _v

                          if all_true([
                              getwparent(cluster, oxr, "engine", "redis") == "redis",
                              getwparent(cluster, oxr, "logDeliveryConfiguration", False),
                          ]):
                              _config = getwparent(cluster, oxr, "logDeliveryConfiguration", [])
                              "logDeliveryConfiguration" = [{
                                  if get(c, "destination", False):
                                      "destination": get(c, "destination", ""),
                                  if get(c, "destinationType", False):
                                      "destinationType" = c.destinationType,
                                  if get(c, "logFormat", False):
                                      "logFormat" = c.logFormat,
                                  if get(c, "logType", False):
                                      "logType" = c.logType,
                              } for c in _config],

                          _v = getwparent(cluster, oxr, "maintenanceWindow", False)
                          if _v:
                              "maintenanceWindow" = _v

                          _v = getwparent(cluster, oxr, "networkType", False)
                          if _v:
                              "networkType" = _v

                          _v = getwparent(cluster, oxr, "nodeType", False)
                          if _v:
                              "nodeType" = _v

                          _v = getwparent(cluster, oxr, "notificationTopicArn", False)
                          if _v:
                              "notificationTopicArn" = _v

                          _om = getwparent(cluster, oxr, "outpostMode", False)
                          _poa = getwparent(cluster, oxr, "preferredOutpostArn", False)
                          if all_true([_om, _poa]):
                              "outpostMode" = _om,
                              "preferredOutpostArn" = _poa

                          _v = get(oxr, "status.parameterGroupName", False)
                          if _v:
                              "parameterGroupName" = _v

                          _v = getwparent(cluster, oxr, "port", False)
                          if _v:
                              "port" = _v

                          if not get(cluster, "availabilityZone", False):
                              "preferredAvailabilityZones" = azs

                          "region" = region

                          if all_true([
                              get(oxr, "spec.createReplicationGroup", False),
                              get(oxr, "status.localReplicationGroupId", False),
                          ]):
                              "replicationGroupId" = get(oxr, "status.localReplicationGroupId", "")

                          if get(oxr, "status.securityGroupId", False):
                              "securityGroupIds" = [
                                  get(oxr, "status.securityGroupId", None),
                              ] + getwparent(cluster, oxr, "securityGroupIds", [])

                          _v = getwparent(cluster, oxr, "snapshotArns", False)
                          if _v:
                              "snapshotArns" = _v

                          _v = getwparent(cluster, oxr, "snapshotName", False)
                          if _v:
                              "snapshotName" = _v

                          _v = getwparent(cluster, oxr, "snapshotRetentionLimit", False)
                          if _v:
                              "snapshotRetentionLimit" = _v

                          _v = getwparent(cluster, oxr, "snapshotWindow", False)
                          if _v:
                              "snapshotWindow" = _v

                          # Only assign subnetGroup if we are not creating a replication group
                          if all_true([
                              get(oxr, "status.subnetGroupName", False),
                              not getwparent(cluster, oxr, "createReplicationGroup", False),
                          ]):
                              _sgn = getwparent(cluster, oxr, "subnetGroupName", "")
                              "subnetGroupName" = get(oxr, "status.subnetGroupName", _sgn)

                          "tags" = tags | get(cluster, "tags", {}) | {
                              "Name": "${appName}-${region}-${_az}"
                          },

                          _v = getwparent(cluster, oxr, "transitEncryptionEnabled", False)
                          if _v:
                              "transitEncryptionEnabled" = _v
                      }
                      "managementPolicies": mgmtPolicy,
                      "providerConfigRef": pcr
                  }
              }
              for i, cluster in requiredClusters
              if all_true([
                  get(oxr, "status.subnetGroupName", False)
                  get(oxr, "status.securityGroupId", False)
              ])
          ]

          port = get(oxr, "status.port", False)
          securityGroupRules = [
              {
                  "apiVersion": "ec2.aws.upbound.io/v1beta1"
                  "kind": "SecurityGroupRule"
                  "metadata": {
                      "annotations": {
                          _cm = regex.replace(cidr, "[^0-9]", "")
                          _resourceName = "security-group-rule-${_cm}"
                          "krm.kcl.dev/composition-resource-name": _resourceName
                          "krm.kcl.dev/ready": readystr(_resourceName)
                          "crossplane.io/external-name": "${appName}-cache-sg-${_cm}"
                      }
                  }
                  "spec": {
                      "deletionPolicy": oxr.spec.deletionPolicy
                      "forProvider": {
                          "cidrBlocks": [cidr],
                          "fromPort": port,
                          "protocol": "tcp",
                          "region": region,
                          "securityGroupId": get(oxr, "status.securityGroupId", ""),
                          "toPort": port,
                          "type": "ingress",
                      }
                      "managementPolicies": mgmtPolicy,
                      "providerConfigRef": get(oxr, "spec.providerConfigRef", {"name": "default"})
                  }
              }
              for i, cidr in get(oxr, "spec.cidrBlocks", [])
              if all_true([
                  get(oxr, "status.securityGroupId", False),
                  port, cidr,
              ])
          ]

          _items = [
              i for r in [clusters, securityGroupRules]
              for i in r if i
          ]

          items = _items
        target: ""
    step: function-kcl-create-cluster
  - functionRef:
      name: function-kcl
    input:
      apiVersion: krm.kcl.dev/v1alpha1
      kind: KCLInput
      metadata:
        creationTimestamp: null
      spec:
        source: |-
          import regex

          oxr = option("params").oxr
          dxr = option("params").dxr
          ocds = option("params").ocds
          dcds = option("params").dcds

          exists = lambda x: any -> bool {
              """
              Check if a value exists.
              """
              x in list(ocds)
          }

          get = lambda x: {:}, y: str, d: any -> any {
              """
              Get an item from a dictionary using a dot separated path.
              If the item is not found, return a default value.

              x: The dictionary to search in.
              y: The path to search for.
              d: The default value to return if the path is not found.
              """
              p = regex.split(y, "\.")
              c = p[0]
              y = ".".join(p[1:])
              x[c] if len(p) == 1 and c in x else d if c not in x else get(x[c], y, d)
          }

          getwparent = lambda x: {:}, p: {:}, y: str, d: any -> any {
              """
              Get with fallback to parent
              Tries to get a path from a dictionary, if it fails,
              tries to get it from the parent dictionary.

              If that fails, falls back to the default value provided.
              """
              get(x, y, get(p, "spec.${y}", d))
          }

          ocdsspec = lambda x: str, y: str, d: any -> any {
              """
              Get an item from the spec of an ocds resource.
              """
              get(ocds, "${x}.Resource.spec.${y}", d)
          }

          ocdsstatus = lambda x: str, y: str, d: any -> any {
              """
              Get an item from the status of an ocds resource.
              """
              _x = None
              if get(ocds, "${x}.Resource.status.atProvider", False):
                  _x = get(ocds, "${x}.Resource.status.atProvider.${y}", d)
              else:
                  _x = get(ocds, "${x}.Resource.status.${y}", d)
              _x if _x else d
          }

          ready = lambda x: str -> bool {
              """
              Check if a value is ready.
              """
              conditionsReady = all_true([
                  get(c, "status", "False") == "True" for c in ocdsstatus(x, "conditions", [])
              ])

              ap = get(ocds, "${x}.Resource.status.atProvider", {})
              objectReady = any_true([
                  ocdsstatus(x, "ready", False),
                  len(list(ap)) > 0,
              ])

              all_true([
                  any_true([exists(x), conditionsReady]),
                  objectReady,
              ])
          }

          readystr = lambda x: str -> str {
              """
              Check if a value is ready.
              """
              "True" if ready(x) else "False"
          }

          allReady = lambda -> bool {
              """
              Check if all managed resources are ready.
              """
              all_true([
                  ready(x)
                  for x in list(ocds)
              ])
          }

          appName = get(oxr, "spec.claimRef.name", "")
          createReplicationGroup = get(oxr, "spec.createReplicationGroup", True)
          dp = get(oxr, "spec.deletionPolicy", "Delete")
          keyId = get(oxr, "status.kmsKeyId", False)
          namespace = get(oxr, "spec.claimRef.namespace", "default")
          region = get(oxr, "spec.region", "eu-central-1")
          pcr = get(oxr, "spec.providerConfigRef", {"name": "default"})
          azs = [
              "${region}${az}"
              for az in get(oxr, "spec.availabilityZones", [])
          ]
          labels = get(oxr, "metadata.labels", {}) | {"region": region}

          tags = labels | get(oxr, "spec.tags", {})

          globalEnabled = all_true([
              False,
              createReplicationGroup,
              get(oxr, "spec.globalReplicationGroup.enabled", False)
          ])

          userNames = get(oxr, "spec.userNames", []) + [appName, "default"]
          mgmtPolicy = get(oxr, "spec.managementPolicies", [])
          publishConnection = get(oxr, "spec.publishConnectionDetailsTo", {})


          globalEndpoint = ocdsstatus("elasticache-replication-group-global", "primaryEndpointAddress", "") if globalEnabled else ""
          globalROEndpoint = ocdsstatus("elasticache-replication-group-global", "readerEndpointAddress", "") if globalEnabled else ""

          cc = get(oxr, "spec.cacheClusters", [])
          rclen = len(cc) if cc else get(oxr, "spec.numCacheClusters", 1)
          clusterEndpoints = [
              e for e in [
                  ocdsstatus("elasticache-cluster-${i}", "clusterAddress", "")
                  for i in range(rclen)
              ]
              if e
          ]

          endpoint = ocdsstatus("elasticache-replication-group-local", "primaryEndpointAddress", "") if createReplicationGroup else clusterEndpoints[0] if clusterEndpoints else ""
          readerep = ocdsstatus("elasticache-replication-group-local", "readerEndpointAddress", "") if createReplicationGroup else endpoint

          _port = 0
          if globalEnabled:
              _port = ocdsstatus("elasticache-replication-group-global", "port", False)
          elif createReplicationGroup:
              _port = ocdsstatus("elasticache-replication-group-local", "port", False)
          else:
              _port = ocdsstatus("elasticache-cluster-0", "port", False)

          # If we are not creating a replication group, check how many cache clusters have
          # been requested and default a list of empty dictionaries as being the cache
          # cluster template.
          requiredClusters = get(oxr, "spec.cacheClusters", []) if get(oxr, "spec.cacheClusters", False) else [
              {}
              for i in range(get(oxr, "spec.numCacheClusters", 1))
              if not get(oxr, "spec.createReplicationGroup", False)
          ]

          users = [
              {
                  "apiVersion": "elasticache.aws.upbound.io/v1beta1"
                  "kind": "User"
                  "metadata": {
                      "annotations": {
                          "krm.kcl.dev/composition-resource-name": "elasticache-user-${name}"
                          "krm.kcl.dev/ready": readystr("elasticache-user-${name}")
                      }
                      "labels": labels
                  }
                  "spec": {
                      "deletionPolicy": dp
                      "forProvider": {
                          if name == "default":
                              "accessString": "off ~* +@all"
                              "authenticationMode": [
                                  {
                                      "type": "no-password-required"
                                  }
                              ]
                          else:
                              "accessString": "on ~* +@all"
                              "authenticationMode": [
                                  {
                                      "passwordsSecretRef": [
                                          {
                                              "key": "password"
                                              if name == appName:
                                                  "name": "elasticache-user-${name}"
                                              else:
                                                  "name": "${appName}-elasticache-user-${name}"
                                              "namespace": namespace
                                          }
                                      ]
                                      "type": "password"
                                  }
                              ]
                          "engine": get(oxr, "spec.engine", "redis")
                          "region": region
                          "tags" = tags | {
                              "Name": "${appName}-${region}-${name}"
                          }
                          "userName": name
                      }
                      "managementPolicies": mgmtPolicy,
                      "providerConfigRef": pcr
                  }
              }
              for name in userNames
          ] if all_true([
              get(oxr, "spec.engine", "redis") == "redis",
              get(oxr, "spec.createReplicationGroup", True),
          ]) else []

          userIds = [
              i for i in [
                  get(item, "Resource.status.atProvider.id", "")
                  for _, item in ocds
                  if all_true([
                      get(item, "Resource.kind", "") == "User",
                      get(item, "Resource.apiVersion", "") == "elasticache.aws.upbound.io/v1beta1",
                  ])
              ] if i
          ]

          userGroup = [{
              "apiVersion": "elasticache.aws.upbound.io/v1beta1"
              "kind": "UserGroup"
              "metadata": {
                  "annotations": {
                      "krm.kcl.dev/composition-resource-name": "elasticache-user-group"
                      "krm.kcl.dev/ready": readystr("elasticache-user-group")
                      "crossplane.io/external-name": appName
                  }
                  "labels": labels
              }
              "spec": {
                  "deletionPolicy": dp
                  "forProvider": {
                      "engine": get(oxr, "spec.engine", "redis")
                      "region": region
                      "tags": tags | {
                          "Name": "${appName}-${region}"
                      }
                      "userIds": userIds
                  }
                  "managementPolicies": mgmtPolicy,
                  "providerConfigRef": pcr
              }
          }] if all_true([
              userIds,
              get(oxr, "spec.engine", "redis") == "redis",
              get(oxr, "spec.createReplicationGroup", True),
          ]) else []

          _items = users + userGroup

          items = _items
        target: ""
    step: function-kcl-create-users
  - functionRef:
      name: function-kcl
    input:
      apiVersion: krm.kcl.dev/v1alpha1
      kind: KCLInput
      metadata:
        creationTimestamp: null
      spec:
        source: |-
          import regex

          oxr = option("params").oxr
          dxr = option("params").dxr
          ocds = option("params").ocds
          dcds = option("params").dcds

          exists = lambda x: any -> bool {
              """
              Check if a value exists.
              """
              x in list(ocds)
          }

          get = lambda x: {:}, y: str, d: any -> any {
              """
              Get an item from a dictionary using a dot separated path.
              If the item is not found, return a default value.

              x: The dictionary to search in.
              y: The path to search for.
              d: The default value to return if the path is not found.
              """
              p = regex.split(y, "\.")
              c = p[0]
              y = ".".join(p[1:])
              x[c] if len(p) == 1 and c in x else d if c not in x else get(x[c], y, d)
          }

          getwparent = lambda x: {:}, p: {:}, y: str, d: any -> any {
              """
              Get with fallback to parent
              Tries to get a path from a dictionary, if it fails,
              tries to get it from the parent dictionary.

              If that fails, falls back to the default value provided.
              """
              get(x, y, get(p, "spec.${y}", d))
          }

          ocdsspec = lambda x: str, y: str, d: any -> any {
              """
              Get an item from the spec of an ocds resource.
              """
              get(ocds, "${x}.Resource.spec.${y}", d)
          }

          ocdsstatus = lambda x: str, y: str, d: any -> any {
              """
              Get an item from the status of an ocds resource.
              """
              _x = None
              if get(ocds, "${x}.Resource.status.atProvider", False):
                  _x = get(ocds, "${x}.Resource.status.atProvider.${y}", d)
              else:
                  _x = get(ocds, "${x}.Resource.status.${y}", d)
              _x if _x else d
          }

          ready = lambda x: str -> bool {
              """
              Check if a value is ready.
              """
              conditionsReady = all_true([
                  get(c, "status", "False") == "True" for c in ocdsstatus(x, "conditions", [])
              ])

              ap = get(ocds, "${x}.Resource.status.atProvider", {})
              objectReady = any_true([
                  ocdsstatus(x, "ready", False),
                  len(list(ap)) > 0,
              ])

              all_true([
                  any_true([exists(x), conditionsReady]),
                  objectReady,
              ])
          }

          readystr = lambda x: str -> str {
              """
              Check if a value is ready.
              """
              "True" if ready(x) else "False"
          }

          allReady = lambda -> bool {
              """
              Check if all managed resources are ready.
              """
              all_true([
                  ready(x)
                  for x in list(ocds)
              ])
          }

          appName = get(oxr, "spec.claimRef.name", "")
          createReplicationGroup = get(oxr, "spec.createReplicationGroup", True)
          dp = get(oxr, "spec.deletionPolicy", "Delete")
          keyId = get(oxr, "status.kmsKeyId", False)
          namespace = get(oxr, "spec.claimRef.namespace", "default")
          region = get(oxr, "spec.region", "eu-central-1")
          pcr = get(oxr, "spec.providerConfigRef", {"name": "default"})
          azs = [
              "${region}${az}"
              for az in get(oxr, "spec.availabilityZones", [])
          ]
          labels = get(oxr, "metadata.labels", {}) | {"region": region}

          tags = labels | get(oxr, "spec.tags", {})

          globalEnabled = all_true([
              False,
              createReplicationGroup,
              get(oxr, "spec.globalReplicationGroup.enabled", False)
          ])

          userNames = get(oxr, "spec.userNames", []) + [appName, "default"]
          mgmtPolicy = get(oxr, "spec.managementPolicies", [])
          publishConnection = get(oxr, "spec.publishConnectionDetailsTo", {})


          globalEndpoint = ocdsstatus("elasticache-replication-group-global", "primaryEndpointAddress", "") if globalEnabled else ""
          globalROEndpoint = ocdsstatus("elasticache-replication-group-global", "readerEndpointAddress", "") if globalEnabled else ""

          cc = get(oxr, "spec.cacheClusters", [])
          rclen = len(cc) if cc else get(oxr, "spec.numCacheClusters", 1)
          clusterEndpoints = [
              e for e in [
                  ocdsstatus("elasticache-cluster-${i}", "clusterAddress", "")
                  for i in range(rclen)
              ]
              if e
          ]

          endpoint = ocdsstatus("elasticache-replication-group-local", "primaryEndpointAddress", "") if createReplicationGroup else clusterEndpoints[0] if clusterEndpoints else ""
          readerep = ocdsstatus("elasticache-replication-group-local", "readerEndpointAddress", "") if createReplicationGroup else endpoint

          _port = 0
          if globalEnabled:
              _port = ocdsstatus("elasticache-replication-group-global", "port", False)
          elif createReplicationGroup:
              _port = ocdsstatus("elasticache-replication-group-local", "port", False)
          else:
              _port = ocdsstatus("elasticache-cluster-0", "port", False)

          # If we are not creating a replication group, check how many cache clusters have
          # been requested and default a list of empty dictionaries as being the cache
          # cluster template.
          requiredClusters = get(oxr, "spec.cacheClusters", []) if get(oxr, "spec.cacheClusters", False) else [
              {}
              for i in range(get(oxr, "spec.numCacheClusters", 1))
              if not get(oxr, "spec.createReplicationGroup", False)
          ]

          esoEnabled = get(oxr, "spec.eso.enabled", False)
          engine = get(oxr, "spec.engine", "redis")
          kubernetesPcr = get(oxr, "spec.kubernetesProviderConfig", {"name": "default"})

          has = all_true([
              esoEnabled,
              kubernetesPcr,
          ])

          if engine == "redis":
              assert esoEnabled, "External Secrets (eso) must be enabled for Redis engine"
              assert has, "Missing required kubernetes ProviderConfig and SecretStore fields for password generation"

          passwordGenerator = {
              "apiVersion": "kubernetes.crossplane.io/v1alpha2"
              "kind": "Object"
              "metadata": {
                  "annotations": {
                      "krm.kcl.dev/composition-resource-name" = "${appName}-pwgen"
                      "krm.kcl.dev/ready": readystr("${appName}-pwgen")
                  }
              }
              "spec": {
                  "deletionPolicy": dp,
                  "forProvider": {
                      "manifest": {
                          "apiVersion": "generators.external-secrets.io/v1alpha1"
                          "kind": "Password"
                          "metadata": {
                              "name": "${appName}-pwgen"
                              "namespace": namespace
                          }
                          "spec": {
                              "length": 42
                              "digits": 5
                              "symbols": 5
                              "symbolCharacters": "-_$@"
                              "noUpper": False
                              "allowRepeat": True
                          }
                      }
                  }
                  "managementPolicies": mgmtPolicy,
                  "providerConfigRef": get(oxr, "spec.kubernetesProviderConfig", {"name": "default"})
              }
          }

          passwords = [
              {
                  "apiVersion": "kubernetes.crossplane.io/v1alpha2"
                  "kind": "Object"
                  "metadata": {
                      "annotations": {
                          "krm.kcl.dev/composition-resource-name": "${appName}-externalsecret-${user}"
                          "krm.kcl.dev/ready": readystr("${appName}-externalsecret-${user}")
                      }
                      "labels": labels
                  }
                  "spec": {
                      "deletionPolicy": dp
                      "forProvider": {
                          "manifest": {
                              "apiVersion": "external-secrets.io/v1beta1"
                              "kind": "ExternalSecret"
                              "metadata": {
                                  "namespace": namespace
                              }
                              "spec": {
                                  "refreshInterval": "1h"
                                  "target": {
                                      if user == appName:
                                          "name": "elasticache-user-${user}"
                                      else:
                                          "name": "${appName}-elasticache-user-${user}"
                                  }
                                  "dataFrom": [
                                      {
                                          "sourceRef": {
                                              "generatorRef": {
                                                  "apiVersion": "generators.external-secrets.io/v1alpha1"
                                                  "kind": "Password"
                                                  "name": "${appName}-pwgen"
                                              }
                                          }
                                      }
                                  ]
                              }
                          }
                      }
                      "managementPolicies": mgmtPolicy,
                      "providerConfigRef": get(oxr, "spec.kubernetesProviderConfig", {"name": "default"})
                  }
              }
              for _, user in userNames
              if all_true([
                  get(oxr, "spec.engine", "redis") == "redis",
                  get(oxr, "spec.createReplicationGroup", True),
                  # don't create a password for the default user
                  # as this will be disabled
                  user != "default"
              ])
          ]

          _endpoint = globalEndpoint if globalEnabled else endpoint
          esoConnectionSecret = {
              "apiVersion": "kubernetes.crossplane.io/v1alpha2"
              "kind": "Object"
              "metadata": {
                  "annotations": {
                      "krm.kcl.dev/composition-resource-name": "${appName}-connection-secret"
                      "krm.kcl.dev/ready": readystr("${appName}-connection-secret")
                  }
              }
              "spec": {
                  "deletionPolicy": dp
                  "forProvider": {
                      "manifest": {
                          "apiVersion": "external-secrets.io/v1beta1"
                          "kind": "ExternalSecret"
                          "metadata": {
                              "name": "${appName}-cache-connection-secret"
                              "namespace": namespace
                          }
                          "spec": {
                              "refreshInterval": "1h"
                              "secretStoreRef": {
                                  "kind": "SecretStore",
                                  "name": get(oxr, "spec.eso.kubernetesSecretStore", ""),
                              },
                              "target": {
                                  "name": "${appName}-cache-connection-details"
                                  "template": {
                                      "engineVersion": "v2"
                                      "mergePolicy": "Merge"
                                      "templateFrom": [
                                          {
                                              "target": "Data",
                                              "literal": """
                                                  host: ${_endpoint}
                                                  port: ${_port}
                                                  username: ${appName}
                                                  password:  {{ index . "password" }}
                                              """
                                          }
                                      ],
                                  },
                              },
                              "dataFrom": [
                                  {
                                      "extract": {
                                          "key": "elasticache-user-${appName}",
                                      }
                                  }
                              ],
                          }
                      }
                  }
                  "managementPolicies": mgmtPolicy,
                  "providerConfigRef": get(oxr, "spec.kubernetesProviderConfig", {"name": "default"})
              }
          } if _endpoint and _port else {}

          _items = [
              c for c in passwords + [passwordGenerator, esoConnectionSecret]
              if esoEnabled and c
          ]

          items = _items
        target: ""
    step: function-kcl-create-password-generator
  - functionRef:
      name: function-kcl
    input:
      apiVersion: krm.kcl.dev/v1alpha1
      kind: KCLInput
      metadata:
        creationTimestamp: null
      spec:
        source: |-
          import regex

          oxr = option("params").oxr
          dxr = option("params").dxr
          ocds = option("params").ocds
          dcds = option("params").dcds

          exists = lambda x: any -> bool {
              """
              Check if a value exists.
              """
              x in list(ocds)
          }

          get = lambda x: {:}, y: str, d: any -> any {
              """
              Get an item from a dictionary using a dot separated path.
              If the item is not found, return a default value.

              x: The dictionary to search in.
              y: The path to search for.
              d: The default value to return if the path is not found.
              """
              p = regex.split(y, "\.")
              c = p[0]
              y = ".".join(p[1:])
              x[c] if len(p) == 1 and c in x else d if c not in x else get(x[c], y, d)
          }

          getwparent = lambda x: {:}, p: {:}, y: str, d: any -> any {
              """
              Get with fallback to parent
              Tries to get a path from a dictionary, if it fails,
              tries to get it from the parent dictionary.

              If that fails, falls back to the default value provided.
              """
              get(x, y, get(p, "spec.${y}", d))
          }

          ocdsspec = lambda x: str, y: str, d: any -> any {
              """
              Get an item from the spec of an ocds resource.
              """
              get(ocds, "${x}.Resource.spec.${y}", d)
          }

          ocdsstatus = lambda x: str, y: str, d: any -> any {
              """
              Get an item from the status of an ocds resource.
              """
              _x = None
              if get(ocds, "${x}.Resource.status.atProvider", False):
                  _x = get(ocds, "${x}.Resource.status.atProvider.${y}", d)
              else:
                  _x = get(ocds, "${x}.Resource.status.${y}", d)
              _x if _x else d
          }

          ready = lambda x: str -> bool {
              """
              Check if a value is ready.
              """
              conditionsReady = all_true([
                  get(c, "status", "False") == "True" for c in ocdsstatus(x, "conditions", [])
              ])

              ap = get(ocds, "${x}.Resource.status.atProvider", {})
              objectReady = any_true([
                  ocdsstatus(x, "ready", False),
                  len(list(ap)) > 0,
              ])

              all_true([
                  any_true([exists(x), conditionsReady]),
                  objectReady,
              ])
          }

          readystr = lambda x: str -> str {
              """
              Check if a value is ready.
              """
              "True" if ready(x) else "False"
          }

          allReady = lambda -> bool {
              """
              Check if all managed resources are ready.
              """
              all_true([
                  ready(x)
                  for x in list(ocds)
              ])
          }

          appName = get(oxr, "spec.claimRef.name", "")
          createReplicationGroup = get(oxr, "spec.createReplicationGroup", True)
          dp = get(oxr, "spec.deletionPolicy", "Delete")
          keyId = get(oxr, "status.kmsKeyId", False)
          namespace = get(oxr, "spec.claimRef.namespace", "default")
          region = get(oxr, "spec.region", "eu-central-1")
          pcr = get(oxr, "spec.providerConfigRef", {"name": "default"})
          azs = [
              "${region}${az}"
              for az in get(oxr, "spec.availabilityZones", [])
          ]
          labels = get(oxr, "metadata.labels", {}) | {"region": region}

          tags = labels | get(oxr, "spec.tags", {})

          globalEnabled = all_true([
              False,
              createReplicationGroup,
              get(oxr, "spec.globalReplicationGroup.enabled", False)
          ])

          userNames = get(oxr, "spec.userNames", []) + [appName, "default"]
          mgmtPolicy = get(oxr, "spec.managementPolicies", [])
          publishConnection = get(oxr, "spec.publishConnectionDetailsTo", {})


          globalEndpoint = ocdsstatus("elasticache-replication-group-global", "primaryEndpointAddress", "") if globalEnabled else ""
          globalROEndpoint = ocdsstatus("elasticache-replication-group-global", "readerEndpointAddress", "") if globalEnabled else ""

          cc = get(oxr, "spec.cacheClusters", [])
          rclen = len(cc) if cc else get(oxr, "spec.numCacheClusters", 1)
          clusterEndpoints = [
              e for e in [
                  ocdsstatus("elasticache-cluster-${i}", "clusterAddress", "")
                  for i in range(rclen)
              ]
              if e
          ]

          endpoint = ocdsstatus("elasticache-replication-group-local", "primaryEndpointAddress", "") if createReplicationGroup else clusterEndpoints[0] if clusterEndpoints else ""
          readerep = ocdsstatus("elasticache-replication-group-local", "readerEndpointAddress", "") if createReplicationGroup else endpoint

          _port = 0
          if globalEnabled:
              _port = ocdsstatus("elasticache-replication-group-global", "port", False)
          elif createReplicationGroup:
              _port = ocdsstatus("elasticache-replication-group-local", "port", False)
          else:
              _port = ocdsstatus("elasticache-cluster-0", "port", False)

          # If we are not creating a replication group, check how many cache clusters have
          # been requested and default a list of empty dictionaries as being the cache
          # cluster template.
          requiredClusters = get(oxr, "spec.cacheClusters", []) if get(oxr, "spec.cacheClusters", False) else [
              {}
              for i in range(get(oxr, "spec.numCacheClusters", 1))
              if not get(oxr, "spec.createReplicationGroup", False)
          ]

          localClusterName = "elasticache-replication-group-local"
          _connectionSecretName = ""
          if ready(localClusterName):
              _connectionSecretName = ocdsspec(localClusterName, "writeConnectionSecretToRef.name", "")

          globalClusterName = "elasticache-replication-group-global"
          _globalConnectionSecretName = ""
          if ready(globalClusterName):
              _globalConnectionSecretName = ocdsspec(globalClusterName, "writeConnectionSecretToRef.name", "")

          _globalReplicationId = ocdsstatus("elasticache-replication-group-global", "id", "")
          _localReplicationId = ocdsstatus("elasticache-replication-group-local", "id", "")

          _ipgn = get(oxr, "spec.parameterGroupName", "")
          if get(oxr, "spec.parameterGroupConfiguration", False):
              _ipgn = get(oxr, "spec.parameterGroupConfiguration.name", "")

          _ugId = ocdsstatus("elasticache-user-group", "id", "")

          instancesCreated = [
              i
              for i in ocds if i.startswith("elasticache-cluster-")
          ]

          readyState = all_true([
              allReady(),
              any_true([
                  ready("elasticache-replication-group-local"),
                  len(instancesCreated) == len(requiredClusters),
              ])
          ])

          newdxr = {
              **dxr,
              **{
                  "status": {
                      if _connectionSecretName:
                          "connectionSecret" = _connectionSecretName,

                      if clusterEndpoints:
                          "clusterEndpoints" = clusterEndpoints,

                      if endpoint:
                          "endpoint" = endpoint,

                      if _globalConnectionSecretName:
                          "globalConnectionSecret" = _globalConnectionSecretName,

                      if globalEndpoint:
                          "globalEndpoint" = globalEndpoint,

                      if globalROEndpoint:
                          "globalReaderEndpoint" = globalROEndpoint,

                      if _globalReplicationId:
                          "globalReplicationGroupId" = _globalReplicationId,

                      if _localReplicationId:
                          "replicationGroupId" = _localReplicationId,

                      if _ipgn:
                          "parameterGroupName": _ipgn,

                      if _port:
                          "port" = _port,

                      if readerep:
                          "readerEndpoint" = readerep,

                      if _ugId:
                          "userGroupId" = _ugId,

                      "ready" = readyState,
                  },
              }
          }

          _items = [newdxr]

          items = _items
        target: ""
    step: function-kcl-dynamic-patching
  - functionRef:
      name: function-auto-ready
    step: function-auto-ready
